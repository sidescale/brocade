#!/bin/sh
#
#    Copyright (c) 2004-2013 Brocade Communications Systems, Inc.
#    All rights reserved.
#
#    Description:
#
#        This pre-install script will be run before firmware
#        download or firmwarerestore starts. 
#
MSG="
There  is  a  problem  with  the  firmware  image  installed  on  the  server.
The preinst file is in DOS format. Please reload the firmware image on server,
using the right tool/options  (to prevent  DOS style  ASCII file conversions),
and then retry firmwaredownload.  "; # comment so ^M will not impact MSG.

check4dos() { if [ $# -gt 1 ] ; then echo "$MSG" ;  exit 5 ; fi ; } ; check4dos 1  
#
# Note the extra space (above) at the end of the call "check4dos 1 "
# This space is very important for it to work correctly.
# In case of dos conversion it will add a ^M at the end of this space.
# That will make it look like calling check4dos with 2 parameters,
# and result in $MSG being printed out instead of the current failure
# ": not a signal specification" which does not convey what exactly went wrong.
#
# This will not address all types of conversion errors though.
# We have seen cases wher ^M was added at the end of PATH below.
# To address that a space has been added at the end of that line
#

#################################################################################
# Attention!                                            						# 
#																				#
# Please do not remove these lines in all future merges. This define indicates	#
# 8548 Rev 3.1 CPU is supported by this firmware. This define is not used in	#
# the preinstall script, but it will be  used by the check_cpu script later!	#
#																				#
CP31_ZENTRON4_SUPPORTED="Version Supports 8548 Rev 3.1 CP"
NON_DFE_SUPPORTED="Version Supports NON DFE"
QSFPP_ICL_SUPPORTED="Version Supports QSFPP ICL"
BUF_OP_MODE_SUPPORTED="Version Supports BufOpMode"
#################################################################################

# Trap / Ignore SIGINT so user cannot interrupt this script with ^C
trap "" 2
trap "" SIGPIPE
PATH=/bin:/usr/bin:/sbin:/usr/sbin # adding comment to protect from DOS conversion

#
# Passed in version numbers
#
TO_MAJOR=$1
TO_MINOR=$2
TO_PATCH=$3

CUR_MAJOR=0
CUR_MINOR=0
CUR_PATCH=0
PREINST="preinstall"
ENC_VERSION_STR="6.1.1_enc"
ENC_VERSION_STR_DEV="6.1.1orion"
CEE_VERSION_STR="6.1.2_cee"
RELEASE_FILE="/tmp/release.plist"
RESTORE_FILE="/mnt/fabos/share/release"
DISPLAY_MARATHON_STRIKER_WARN_MSG=0
#
# When firmwaredownload is invoking this script,
# TYPE should be NULL; when firmwarerestore is
# invoking it, TYPE is "restore"
#
TYPE=$4

#
# Common variables
#
CHASSISCONFIG=/bin/getchassisconfig
NULL=/dev/null
if [ "$DEBUG" = 1 ]; then
	ECHO='echo -e'
else
	ECHO=:
fi

# This should match the file name in src/lib/upgrade/upgrade.c
STATUS_FILE=/tmp/fwdl_err.txt
BNA_STATUS_FILE=/tmp/bna_fwdl_err.txt
# clear status file
echo > $STATUS_FILE
echo " " > $STATUS_FILE
echo > $BNA_STATUS_FILE
echo " " > $BNA_STATUS_FILE
if [ -z $TYPE ]; then
	echo "The following item(s) need to be addressed before downloading the specified firmware:" >> $STATUS_FILE
else
	echo "The following items need to be addressed before restoring the specified firmware:" >> $STATUS_FILE
fi

#
# Error codes - these have to match the error codes
# in fwdl.h.
#
STS_OK=0
ERR_CONF_LSANMATRIX=75		# FWDL_ERR_SECMODE 0x51
STS_ERR=255

RET_CODE=${STS_OK}
RET=${STS_OK}
OVERALL_STS=$STS_OK

FWDL_PREINST_SWITCHNAME="/tmp/fwdl_preinst_switchname"
export CHASSIS_ROLEID=0
if /fabos/bin/fosconfig --show | grep "Virtual Fabric" | grep enabled > /dev/null 2>&1 ; then VF_ENABLED=$STS_ERR; else VF_ENABLED=$STS_OK; fi

#
# Key vault Defeinitions
#
KEY_VAULT_TYPE_LKM=0x1
KEY_VAULT_TYPE_RSA=0x2
KEY_VAULT_TYPE_EFCM=0x3
KEY_VAULT_TYPE_SKM=0x5
KEY_VAULT_TYPE_NCKA=0x6
KEY_VAULT_TYPE_TKLM=0x7
KEY_VAULT_TYPE_KMIP=0x8

#
# cpid
#
# Retrieve the current Control Processor ID
#
cpid() {
    sed -n -e 's/^Control.\+No: \([[:digit:]]\{1,\}\)$/\1/gp'
}

#
# swbd
#
# Retrieve the current system platform name, of the form "SWBDn", where n
# is cardinal number, assuming a sin/hinv input stream.
#
swbd() {
    sed -n -e 's/^.\+\(SWBD[[:digit:]]\{1,\}\).\+$/\1/gp'
}

# Determine the system platform identifier.
SWBD=`sin | swbd 2> ${NULL}`
CPID=`sin | cpid 2> ${NULL}`


otherhost(){
#        printf 10.0.0.$((5+$(othercp)))
	case ${SWBD##SWBD} in
	'62')
	    printf 127.1.1.$((8 - CPID % 2))
	    ;;
	'77')
	    printf 127.1.1.$((6 - CPID % 2))
	    ;;
	*)
	    printf 10.0.0.$((6 - CPID % 2))
	    ;;
	esac
}

HASHOW="$(/fabos/bin/hashow)"
hashow_cmd=$(ls /fabos/cliexec/hashow)
if [ "$hashow_cmd" != "/fabos/cliexec/hashow" ]; then
       	hashow_cmd="/fabos/bin/hashow"
fi

othercp(){
        that=${HASHOW#*Remote CP \(Slot}
        that="${that%%,*}"
        printf $(($that - 5))
}

add_err_status(){
	echo -e "$1" >> $STATUS_FILE
	if [ "$#" -eq 1 ]; then
		echo -e "$1" >> $BNA_STATUS_FILE
	elif [ "$#" -eq 2 ]; then
		echo -e "$2" >> $BNA_STATUS_FILE
	fi	
}

ha_role() {
 	case "$($hashow_cmd | ( read a; echo $a ))" in
	    *Local*Active*)
	    printf "ACTIVE"
 	    ;;
	    *Local*Standby*)
	    printf "STANDBY"
 	    ;;
	    *"Not supported"*)
	    printf "ACTIVE"
 	    ;;
	    *)
	    printf "STANDBY"
	    ;;
	esac
}

if [ $(ha_role) == "ACTIVE" ]; then
    ACTIVECP=1
fi

ha_state() {
    sync=`/fabos/cliexec/hashow | sed -n -e 's/^.\+\(State sync\).\+$/\1/gp'`

    if [ "$sync" != "State sync" ]; then
	    printf "NOSYNC"
    else
	    printf "SYNC"
    fi
}

is_fwdl_arg() {

	#
	# Reads command line args passed to firmwaredownload
	# and checks if the required argument is specified
	#
	for arg in $(/usr/bin/tr '\0' ' ' < /proc/$PPID/cmdline)
	do
            case $arg in
            (-*$1*)
		return $STS_OK
		;;
            esac
        done
        return $STS_ERR
}

allow_nondisruptive_fwdl() {
	# Skip for restore
	if [ -n "$TYPE" ]; then
		$ECHO " running firmwarerestore"
		return $STS_OK
	fi

    # Allow 6.1.2_cee <-> 6.3 HCL on Elara
    # For others, allow only disruptive fwdl
    case ${SWBD##SWBD} in
    '76')
        ;;
    *)
		is_fwdl_arg "s"
		local singlemode=$?
		is_fwdl_arg "f"
		local forcemode=$?
		if [ $singlemode -ne 0 -o $forcemode -ne 0 ]; then
			return $STS_ERR
		fi
		;;
	esac

	return $STS_OK
}

allow_disruptive_single_mode_fwdl() {
	# Skip for restore
	if [ -n "$TYPE" ]; then
		$ECHO " running firmwarerestore"
		return $STS_OK
	fi

	is_fwdl_arg "s"
	local singlemode=$?
	if [ $singlemode -ne 0 ]; then
		return $STS_ERR
	fi

	return $STS_OK
}

check_for_non_disruptive_fwdl() {
	# Skip for restore
	if [ -n "$TYPE" ]; then
		$ECHO " running firmwarerestore"
		return $STS_ERR
	fi

	is_fwdl_arg "s"
	local singlemode=$?
	if [ $singlemode -ne 0 ]; then
		return $STS_OK
	fi

	return $STS_ERR
} 

check_autoreboot_opt() {
	# Skip for restore
	if [ -n "$TYPE" ]; then
		$ECHO " running firmwarerestore"
		return $STS_OK
	fi

	is_fwdl_arg "b"
	local auto_reboot=$?
	if [ $auto_reboot -eq 0 ]; then
		return $STS_ERR
	fi

	return $STS_OK
}

TEST() {

	$ECHO  -n "TEST $1 "
	if [ $(ha_role) == "STANDBY" ] && [ $(ha_state) == "NOSYNC" ]; then
	    return $STS_OK
	fi

	$1
 	if [ $? -ne $STS_OK ]; then
		$ECHO "failed"
		if [ "$#" -eq 2 ]; then
			add_err_status "$2"
		elif [ "$#" -eq 3 ]; then
			add_err_status "$2"	"$3"
		fi		
		RET_CODE=$STS_ERR
		return $STS_ERR
	fi

	$ECHO "passed"
	return $STS_OK
}


CHASSISCMD=""
cliidx=0
export PATH=/fabos/link_bin:/bin:/usr/bin:/sbin:/usr/sbin:/fabos/link_abin:/fabos/link_sbin:/fabos/factory:/fabos/xtool
export VFROLEMAP=-1:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0

context_switch()
{
    if [ $VF_ENABLED -ne $STS_OK ]; then
        if [ "$1" != "chassis" ]
        then
            eval $(/fabos/cliexec/lscfg_util --switch $1)
        else
            eval $(/fabos/cliexec/lscfg_util --chassis)
            #export CHASSIS_ROLEID=0
        fi
    fi
    export ROLE_ID=root
}

cmd_chassis() {

  context_switch chassis

  if [ "$CONFIG" = "TRUE" ]; then
    echo -n . > $TTY
    cliidx=`/usr/bin/expr $cliidx + 1`
    echo "$cliidx $1 $2 $3 $4 $5 $6 $7 $8 $9" >> $cshow
    echo -e "$1 $2 $3 $4 $5 $6 $7 $8 $9:"
      echo "** $1 $2 $3 $4 $5 $6 $7 $8 $9: Command:$rc **" >> $cshow
  else
    echo -e "$1 $2 $3 $4 $5 $6 $7 $8 $9:"
    $1 $2 $3 $4 $5 $6 $7 $8 $9
  fi
}


# Helper function. It sets the global variable CONTEXTS to be a list of fabric IDs.
# Typical usage is seen in the function for_all_contexts, where we use CONTEXTS if it
# is defined, and otherwise call this function. This means we only need to do
# the configshow once for each run of preinst, rather than once for each test
# that wants to run in all contexts
#get_all_contexts(){
#	CONTEXTS=$($CHASSISCMD /fabos/cliexec/configshow -all | sed -n 's/Fabric ID =//p')
#	echo $CONTEXTS
#}
	CONTEXTS=$($CHASSISCMD /fabos/cliexec/configshow -all | sed -n 's/Fabric ID =//p')



glb_ls_id=-1
glb_vf_id=255
def_vf_id=128

# Helper function. Loop over the valid fabric IDs running the test that is passed as
# a parameter. As soon as one test fails then return $STS_ERR. If all pass then
# return $STS_OK.
# WARNING. This command will change to a random context (The first one that fails
# the test or the last context if all pass). Random terms in case someone is searching
# this file, VF Virtual Fabric AD setcontext FID context and wants to find this warning
for_all_contexts(){
	for FID in ${CONTEXTS} ; do
		context_switch $FID
		glb_vf_id="$CURRENT_VF"
		glb_ls_id="$FABOS_SWITCHNO"
		if "$@"
		then	$ECHO -n "$FID-passed "
		else	$ECHO -n "$FID-failed "
				return $STS_ERR
		fi
	done
	return $STS_OK
}

for_all_contexts_standby(){
	rval=$STS_OK
	/bin/ln -s /fabos/cliexec/lscfg_util /fabos/link_sbin/lscfg_test 2> /dev/null
	local_flag=$?
	export PATH=/fabos/link_bin:/bin:/usr/bin:/sbin:/usr/sbin:/fabos/link_abin:/fabos/link_sbin:/fabos/factory:/fabos/xtool
	lscfg_test --all | grep -e "[0-9]" | grep -v "Total" |
	while read glb_ls_id glb_vf_id role
	do
		context_switch $glb_vf_id
		if "$@"
		then	$ECHO -n "$glb_vf_id-passed "
		else	$ECHO -n "$glb_vf_id-failed "
			# note the following return just return from the "|" subshell
			return $STS_ERR
		fi
	done
	if [ $? -ne $STS_OK ]; then rval=$STS_ERR; fi
	if [ $local_flag -eq 0 ];then /bin/rm /fabos/link_sbin/lscfg_test 2> /dev/null; fi
	return $rval
}


###################################################
### The messages are for firmwarerestore.	###
###################################################
FWDL_RUNNING_MSG="Firmwaredownload or firmwarecommit is already running. Please wait for it to complete first."
FWRESTORE_DISALLOWED_MSG="No need to run firmwarerestore because firmware has already been committed, or there is no firmwaredownload performed."
FWRESTORE_VER_DISALLOWED_MSG="Firmwarerestore from v6.3.x to v6.1.2_cee is not supported. Please run firmwarecommit first and then download the new firmware."

###################################################
###################################################
####                                           ####
####                                           ####
####     PRESINSTALL MESSAGES SECTION          ####
####    ------------------------------         ####
####                                           ####
###################################################
###################################################
SCIMITARMSG="The FA4-18 (type 33) blade is not supported by the target firmware. Please use slotshow to find out which slot it is in and remove it first."
XENONMSG="The FC10-6 (type 39) blade is not supported by the target firmware. Please use slotshow to find out which slot it is in and remove it first."
QUATTROMSG="The FC8-64 (type 77) blade is not supported by the target firmware. Please use slotshow to find out which slot it is in and remove it first. For VF enabled switch, use \"lscfg --restore_to_default FID\" to move all vacant ports in this slot to the default after removing the blade."
MARATHONMSG="The FR4-18i(type 24) blade is not supported by the target firmware. Please use slotshow to find out which slot it is in and remove it first."
UNSUPPORTED_DL_VERMSG="Cannot downgrade to 6.4 or lower. Please downgrade to 7.0 first and then download the desired firmware version."
UNSUPPORTED_UP_VERMSG="Cannot upgrade directly to 7.2. Please upgrade to 7.0 first and then upgrade to 7.2."
UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL="Non disruptive firmwaredownload is not supported when firmwaredownload with two versions apart. Please try to use \"firmwaredownload\" with single mode option enabled."
UNSUPPORTED_AUTOREBOOT_OPT_WARN_MSG="auto reboot option is not allowed with single mode when upgrade from 6.3 to 7.0. Please make sure that auto-reboot is not enabled before proceeding."
UNSUPPORTEDPLATFORMMSG="Cannot download the requested firmware because the firmware doesn't support this platform. Please enter another firmware path."
SWITCH_FAULTY_MSG="Firmwaredownload is not allowed since the switchState is Faulty. Use \"switchShow\" to see the switch state. Please recover the switch before proceeding."

UNSUPPORTED_EEMON_ON_DOWNGRADE="Downgrade is not allowed when end to end monitors are installed in AG. Please use \"perfDelEEMonitor \" to clear the end to end monitors installed before downgrading."
UNSUPPORTED_FMON_ON_DOWNGRADE="Downgrade is not allowed when frame monitors are installed in AG. Please use \"fmMonitor --delete \" to clear the frame monitors installed before downgrading."
UNSUPPORTED_LICENSES_ON_DOWNGRADE="Downgrade is not allowed because enhanced licenses are installed. Please remove them before downgrading."
UNSUPPORTED_STATICFPORTS_CONFIG_ON_DOWNGRADE="Downgrade is not allowed because static F-ports are configured. Please use \"ag --show \" to check for static F-ports and \"ag --staticdel <N-port> <F-ports>\" to delete the static mapping before downgrading."
UDROLE_FWDL_DISALLOWED_MSG="Downgrade is not allowed because user-defined roles are present. Please use \"roleconfig --show -all\" to check all the UD Roles and \"userconfig --show -all\" to check any users assigned these roles.If there are such users, use \"userconfig --change\" to assign default roles to the users or \"userconfig --delete\" to delete the users. Then remove the UD Roles with \"roleconfig --delete\""
UNSUPPORTED_ZONE_SIZE="Downgrade is not allowed because the existing zone configuration is more than 1MB. To downgrade to lower firmware version modify the existing zone configuration to 1MB or lesser."
PORTNAME_LEN_DISALLOWED_MSG="Downgrade is not allowed because one or more ports name length is greater than 32 bytes. Please use \"portname\" CLI to check and fix the port name/length before downgrading."
PORTSPEED_DISALLOWED_MSG="Downgrade is not allowed because one or more ports have speed configured as 10G/16G speed. Please remove unsupported blades CR8510(4)-16/CR8510-16 if present and use \"portcfgspeed\" CLI to change the speed before downgrading."
PAD_FEATURE_CHECK_MSG="Downgrade is not allowed because for one or more ports Port Auto Disable (PAD) is enabled with no options configured. Need to disable PAD for those ports first. Use \"portcfgautodisable\" CLI for command usage."
CONDOR3_BLADE_IS_PRESENT="FC16-32, FC16-48, CR8510(4)-16, and CR8510(8)-16 are not supported by the targeted firmware. Please use slotshow to determine which of these are installed and remove them before continuing."
UNSUPPORTED_ENCRYPTION_VERSIONING_DEC="Downgrade is not allowed for this key vault type as device decommission feature is in use. Please use \"cryptocfg --delete -decommissionedkeyids\" to disable device decommission. Make sure that there is no lun undergoing decommission, or is in failed state."
UNSUPPORTED_ENCRYPTION_VERSIONING_KMIP="Downgrade is not allowed when key vault type is KMIP. Please use \"cryptocfg --set -keyvault type\" to set a different keyvault type other than KMIP to disable the feature."
FCOE_PROVISION_CONFIG_MSG="With the current upgrade/downgrade, the CEE start up configuration dcf.conf file will be incompatible with FCoE provisioning changes as part of this build. CEE start up configuration file, dcf.conf can be backed up for future use. The user can save the configuration as backup and apply it once upgrade/downgrade is complete, to restore the switch configuration in its respective build version. If you wish to save the configuration file please abort firmware download and save the configuration file before proceeding."
UNSUPPORTED_INTEROP_MODE="Upgrade to 7.0 or above is not allowed when interopmode is enabled. To upgrade, please disable interopmode."
XFCIP_FEATURE_RESTRICTION="Downgrade is not allowed because some FCIP features are enabled and are not supported on the selected version. Please address these unsupported features before downgrading."
CONDOR_EX_PORT_RESTRICTION="Downgrade to selected version is not allowed because EX-Ports are configured on FR4-18i blade(s). Please remove EX-port configuration using \"portcfgexport\" CLI on the ports."
McDATA_EX_PORT_RESTRICTION="Upgrade to selected version is not allowed because Ex or VEx Ports are configured in McData/Open interop-mode. Please disable McData interopmode configuration using \"portcfgexport\" or \"portcfgvexport\" CLI on the ports."
NOS_EX_PORT_RESTRICTION="Downgrade to selected version is not allowed because EX-Ports are configured in Brocade NOS Interop-mode. Please remove EX-port configuration using \"portcfgexport\" CLI on the ports."
ENC_COMP_EX_PORT_RESTRICTION="Downgrade to selected version is not allowed because EX-Ports are configured  with encryption/compression feature. Please remove EX-port configuration using \"portcfgexport\" CLI or disable encryption/compression on the ports."
LONGDIST_BUFFER_OPTION_RESTRICTION="Downgrade to selected version is not allowed because few ports are configured  with Longdistance -buffers option. Please remove the configuration using \"portcfglongdistance L0\" CLI or change the configuration with -distance option."
UNSUPPORTED_VEPORT_THRESHOLD_CONFIG="Downgrade is not allowed because high/low threshold for VE-Port on the switch(s) is configured to decimal value. Kindly configure the threshold to a integer value and downgrade."
UNSUPPORTED_MULTIPLE_EMAIL_FW_ALERT="Downgrade is not allowed because Multiple recipient addresses might have been configured on any of the logical switches for any of the class to receive Fabric Watch email alerts. Please use "fwMailCfg" CLI command to configure single recipient address before downgrading."
UNSUPPORTED_BRCD_CERTIFICATE_DATABASE_VALUE="Downgrade to 7.0 is not allowed because either 1) FCAP authentication to one of the neighboring switches is configured to use Brocade issued certificates, or 2) Brocade Certificate files exist. Please remove or set the configuration to thirdparty and delete certificate files using \"pkiremove\" before upgrading."
CHECK_LDAP_CONFIGURED_OVER_IPv6="Downgrade is not allowed because IPv6 configuration for LDAP is in use. Please remove all the IPv6 configuration for LDAP using \"aaaconfig --remove\" before downgrading."
UNSUPPORTED_IPFILTER_POLICY="Downgrade is not allowed because IPFILTER forwarding rule(s) is enabled. To Downgrade to lower version please delete the FORWARD rule(s) from IPFILTER policy"
MARATHON_STRIKER_ERR_MSG="Firmware migration is not allowed since the FX8-24 and FR4-18i blades are both present.\nPlease remove the FR4-18i blades before proceeding with the firmwaredownload command."
MARATHON_STRIKER_WARN_MSG="After the firmware migration has completed, the FR4-18i blade(s) needs to be removed if the FX8-24 blade(s) is to be plugged into the chassis."
UNSUPPORTED_FWCONFIGURE1="Upgrade to 7.0 or above is not allowed because the threshold configuration changed alarm is set"
UNSUPPORTED_FWCONFIGURE2="Similar configuration may exist for other classes and areas and on other FIDs. Please use \"fwconfigure\" to unset the same."
UNSUPPORTED_CHECK_SECOND_TIMEBASE1="Upgrade is not allowed because timebase is configured as seconds"
UNSUPPORTED_CHECK_SECOND_TIMEBASE2="Similar configurations may exist for other classes and areas and on other FIDs. Please Configure the timebase to other unit using \"fwconfigure/thconfig/portthconfig\" and upgrade."
UNSUPPORTED_TSTIMEZONE="Downgrade is not allowed because tstimezone is configured with three sections input. please change the configuration with two sections and proceed."
VPWWN_CONFIGURED="Downgrade is not allowed because Fabric Assigned PWWN is configured in one or more partitions. Please delete all the Fabric Assigned PWWN configurations before downgrading."
FLOW_MANAGER_CONFIGURED="Downgrade is not allowed because Flow Vision is configured. Please delete all the flows using \"flow\" CLI."
VE_AS_XISL_CONFIGURED="Downgrade is not allowed, as there is a VE Port in the Base switch that could be used as an XISL and there is at least one logical switch with \"ALLOW XISL Use\" enabled. Either remove all VE Ports from the Base switch or disable XISL use in all logical switches and repeat the downgrade attempt."
FCIP_LS_WITH_XISL_ON="Downgrade is not allowed, as there is a VE Port in a logical switch that has \"ALLOW XISL Use\" enabled.  Please disable \"ALLOW XISL Use\" in all logical switches that include VE ports, and retry the downgrade attempt."
UNSUPPORTED_RRDY_BASE_SWITCH="Upgrade to 7.0 or above is not allowed since base switch has R_RDY enabled ports. Please disable the R_RDY enabled ports in base switch using portcfgislmode command."
UNSUPPORTED_IODDELAY_ON_UPGRADE="Upgrade to 7.0 or above is not allowed due to the presence of ioddelay configuration. Please reset the feature with \"ioddelayreset\" before upgrading to v7.0."
FCFW_NOT_SUPPORTED="Upgrade to 7.0 or above is not allowed because FC Fastwrite is not supported on this version. Please use \"fastwritecfg\" to deconfigure FC Fastwrite for all slots and try again."
BSTR_NOT_SUPPORTED="Upgrade to 7.0 or above is not allowed because TCP Byte Streaming is not supported on this version. Please use \"portcfg\" to deconfigure TCP Byte Streaming for all tunnels and try again."
UNSUPPORTED_DUP_PORT_WWN="Upgrade to 7.0 or above is not allowed because duplicate PWWN devices are detected in one or more partitions. Please configure the devices with unique PWWNs or disable the ports and remove the devices with duplicate PWWNs before upgrading the firmware."
SERDES_TUNE_ENABLED="Downgrade is not allowed because FC8-16 serdestunemode is enabled. Please use \"serdestunemode --show\" to view the mode and \"serdestunemode --reset\" to disable the feature before downgrading."
ENHANCED_FC8_BLADE_IS_PRESENT="FC8-32E and FC8-48E are not supported by the targeted firmware. Please use slotshow to determine which of these are installed and remove them before continuing."
UNSUPPORTED_DBR_ON_DOWNGRADE="Downgrade is not allowed because Device Based Routing is configured. Please use \"aptpolicy\" to change the routing policy."
FC8_BLADE_IS_PRESENT="FC8-16, FC8-32 and FC8-48 are not supported by the targeted firmware. Please use slotshow to determine which of these are installed and remove them before continuing."
D_PORT_R_RDY_NOT_SUPPORTED="Downgrade is not allowed because R-RDY flow control ports are configured as D-Ports. Please use \"portdporttest --show all\" to view the port list and \"portcfgdport --disable\" to disable before downgrading."
D_PORT_DWDM_NOT_SUPPORTED="Downgrade is not allowed because D-Port is configured with DWDM mode. Please use \"portcfgshow\" to view the port list and \"portdisable [slot/]port; portcfgdport --disable -dwdm [slot/]port\" to reset DWDM mode before downgrading."
DOWNGDAOQ_SAO_REQ="Downgrade is not allowed as AoQ is active on server or HBA ports without Server Application Optimization license. To proceed further with downgrade either install Server Application Optimization license, or set QoS mode on AoQ enabled ports to OFF if it is ON/AE and then toggle these AoQ enabled ports to disable AoQ. Please use \"switchshow\" to view list of F_Port with AoQ feature enabled and use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF. To toggle the ports use \"portdisable [slot/]port and portenable [slot/]port\"."
DOWNGDAOQ_AN_REQ="Downgrade is not allowed as AoQ is active on device ports without Adaptive Networking license. To proceed further with downgrade either install Adaptive Networking license, or set QoS mode on AoQ enabled ports to OFF if it is ON/AE and then toggle these AoQ enabled ports to disable AoQ. Please use \"switchshow\" to view list of F_Port with AoQ feature enabled and use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF. To toggle the ports use \"portdisable [slot/]port and portenable [slot/]port\"."
DOWNGDAOQ_AN_SAO_REQ="Downgrade is not allowed as AoQ is active on server or HBA ports without Server Application Optimization license and Adaptive Networking license. To proceed further with downgrade either install Server Application Optimization license and Adaptive Networking license, or set QoS mode on AoQ enabled ports to OFF if it is ON/AE and then toggle these AoQ enabled ports to disable AoQ. Please use \"switchshow\" to view list of F_Port with AoQ feature enabled and use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF. To toggle the ports use \"portdisable [slot/]port and portenable [slot/]port\"."
DOWNGDQOS_AN_REQ_MSG1="Downgrade is not allowed as QoS mode is enabled (ON) on some of the ports and there is no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license, or set QoS mode to OFF/AE. Please use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF or use \"portcfgqos --default [slot/]port\" to set QoS mode on these ports to AE."
DOWNGDCSCTL_AN_REQ="Downgrade is not allowed as CSCTL mode is enabled (ON) on some of the ports and there is no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license, or set CSCTL mode to OFF. Please use \"portcfgqos --disable [slot/]port csctl_mode\" to set CSCTL mode on these ports to OFF."
DOWNGDRATELIMIT_AN_REQ="Downgrade is not allowed as Rate Limit is enabled (ON) on some of the ports and there is no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license, or reset Rate Limit to OFF. Please use \"portcfgqos --resetratelimit [slot/]port\" to reset Rate Limit on these ports to OFF."
DOWNGDQOS_AN_REQ_MSG3="Downgrade is not allowed as QoS is active on E_Port(s) with no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license on the switch, or turn OFF QoS on these ports. Please use \"islshow\" to view the list of E_Port(s) with QoS. In case these E_Port(s) are trunked, use \"trunkShow\" to list all the ports in the trunk group. Finally, use \"portcfgqos --disable [slot/]port\" to disable QoS on the ports."
DEFAULT_QOS_WARN_MSG="This action will set default QoS port configuration from AE to OFF because Adaptive Networking License is not installed on the switch."
FMS_LOSSLESS_XISL_CHECK_ERROR="FMS, Lossless and XISL feature combination error in downgrading from 7.1.x (and above) to 7.0.x (and below)"
ENC_COMP_FWDL_RESTRICTION="Downgrade to selected version is not allowed because more than 2 ports per Chip are configured with Encryption/Eompression feature. Please restrict encryption/compression configuration to 2 ports per Chip. Please use portenccompshow command to determine  which ports in the chip are configured for encryption/compression feature."
CHECK_AAA_TAC_SUPPORT="Firmware download is not allowed because TACACS+ protocol is enabled/configured in AAA configuration. Please use \"aaaconfig --authspec\" to change authspec mode other than TACACS+ or use \"aaaconfig --remove\" to remove TACACS+ server configuration."
UNSUPPORTED_AUTH_SWITCH_POLICY="Firmwaredownload is not allowed because switch authentication policy is either \"ON, ACTIVE or PASSIVE\". Please use \"authutil --policy -sw off\" to change switch authentication mode."
UNSUPPORTED_SWITCH_ENFORCED_LOGIN="Firmwaredownload is not allowed because switch enforce_login policy is set to value 2, please set the value to 0 or 1 using \" configure \" to proceed with firmwaredownload."
REMOVE_DPORT_CONFIGURATION="Downgrade is not allowed because switch is in AG mode and D-Ports are configured.\nPlease use \"switchshow\" to view the D-port list and use\n\"portcfgdport --disable <port_no>\" to disable it before downgrading."
CHECK_PASSWDCFG_SUPPORT="Firmwaredownload is not allowed because passwdcfg expiration policies are configured for per user basis. Please use \"passwdcfg --deleteuser -all\" to delete the per user expiration policy in passwdcfg and try firmwaredownload."
D_PORT_ICL_NOT_SUPPORTED="Downgrade is not allowed because ICL ports are configured as D-Ports.\nPlease use \"switchshow\" to view the D-port list and use\n\"portcfgdport --disable <port_no>\" to disable it before downgrading."
EX_PORT_ICL_NOT_SUPPORTED="Firmware downgrade is not allowed because ICL ports are configured as EX-Ports. Please use \"portcfgshow\" to view the ICL EX ports and use \"portcfgexport\" to disable the EX feature on those ports before downgrading."
REMOVE_CREDITRECOVERY_CONFIGURATION="Downgrade is not allowed because one or more ports have credit recovery enabled.Please use \"portcfgcreditrecovery --disable\" command to disabled credit recovery." 
DUPLICATE_SWITCHNAME="Firmwaredownload is not allowed since duplicate switch names are detected for the Logical Switches. Please use \"switchname\" command to configure unique switch names before performing firmware download."
FEC_ACTIVE="Please use \"portcfgfec --disable\" command to disable the FEC feature of the F-Ports before performing firmwaredownload."
CR_ACTIVE="Please use \"portcfgcreditrecovery --disable\" command to disable the CR feature of the F-Ports before performing firmwaredownload."
AUTO_CSCTL_ACTIVE="Auto CSCTL feature is enabled. If you are downgrading the firmware, please disable the auto csctl mode using\"configurechassis\" command and following that either perform powercycle on each non-CP blades or reboot the system before performing firmwaredownload."
REMOVE_FEC_CONFIGURATION="Downgrade is not allowed because one or more ports have FEC enabled.Please use \"portcfgfec --disable\" command to disabled FEC."
MAPS_ACTIVE="WARNING: The Monitoring and Alerting Policy Suite (MAPS) is enabled. Downgrading will revert back to Fabric Watch monitoring using last known active thresholds."
SPIKE_VF_ENABLED="7800 Virtual Fabric mode is enabled in the switch and it requires version v7.1.0 or higher. Please delete all non-default logical switches and then, use the \"fosconfig --disable vf\" command to disable VF Mode and retry."
LOCATION_ID_CONFIGURED="Please use the \"configure\" command to clear the Location ID"
UNSUPPORTED_SNMP_TRAPOID="Customized SNMP trap OID configuration (snmp.trapEnterpriseFlag) is not supported from version v7.1.0."
UNSUPPORTED_SNMP_PRIVPROTOCOL="Some snmpv3 users have unsupported private protocols configured. Please use snmpconfig --default snmpv3 to make default configurations or use snmpconfig --set snmpv3 and change private protocols as DES or AES128."
BNA_UNSUPPORTED_SNMP_PRIVPROTOCOL="Some snmpv3 users have unsupported private protocols configured. 3DES, AES192, AES256 are unsupported in 7.2.0. Please default the snmp configurations or change it to DES or AES128."
UNSUPPORTED_ICL_PORT_CONFIGURATION="Firmware upgrade to Fabric OS 7.1.0 or higher is not allowed when there are more than 4 chassis interconnected through Inter-Chassis Links (ICLs) and the Enterprise ICL (EICL) license is not installed in the system. Note that even with an EICL license installed, only 10 chassis are allowed to interconnect through ICLs. You can either install an EICL license, or you must disable the additional ICL links before performing a firmware upgrade."
ENABLE_TRUNK_CONFIGURATION="Downgrade is not allowed because switch is in AG mode and Trunking is disabled on some of the ports.\nPlease use \"portcfgshow\" to get port list and use \"portcfgtrunkport <port_no> 1\" to enable it before downgrading."
EPORT_CREDIT_FWDL_RESTRICTION="Downgrade to selected version is not allowed. Please remove E-Port Credit configuration using \"portcfgdefault\" or \"portcfgeportcredits --disable\" CLI on these ports."
SPEED_10G_PRESENT_ERROR="Downgrade is not allowed because there are few ports other than the first octet of the blade/switch configured for octet speed combo 2 or 3.\nPlease change the octet speed combo of those ports to 1 using \"portcfgoctetspeedcombo\" CLI and change their speeds using \"portcfgspeed\" CLI."
TACACS_LEN_ERROR_MSG="Downgrade to pre-7.2 Fabric OS versions is not allowed. Please configure TACACS+ keys of length in the range (8-40) characters using aaaconfig CLI {Usage: aaaconfig --change <server> -conf tacacs+ [-s <secret>], before performing a firmware downgrade."
MAPS_ENABLED="Downgrade is not allowed because Monitoring and Alerting Policy Suite (MAPS) is enabled. Please disable MAPS using \"mapsconfig --disable\" before proceeding"
FIPS_ENABLED="Upgrade to 7.2.1 and above is not allowed because FIPS is enabled. Please upgrade to 7.2.0 first before upgrading to this version."
AUTHUTIL_CONFIGURATION_HASHSET="Downgrade is not allowed because sha256 is set as hash type for DH-CHAP/FCAP in atleast one of the logical switches,\nPlease change the configuration to sha1 in all the logical switches using authutil CLI {Usage : authutil --set -h}."
BUFOPMODE_ENABLED="Downgrade is not allowed. Please disable bufopmode using the CLI \"bufopmode --reset <slot>\" or \"bufopmode --resetall\" \n"
#######################################################
### The messages are for firmwarerestore from BNA.	###
#######################################################
BNA_FWDL_RUNNING_MSG="Firmware download or firmware commit is already running. Please wait for it to complete first."
BNA_FWRESTORE_DISALLOWED_MSG="No need to run firmware restore because firmware has already been committed, or there is no firmware download performed."
BNA_FWRESTORE_VER_DISALLOWED_MSG="Firmware restore from v6.3.x to v6.1.2_cee is not supported. Please run firmware commit first and then download the new firmware."
###################################################
###################################################
####                                           ####
####                                           ####
####     PRESINSTALL MESSAGES SECTION FOR BNA  ####
####    -------------------------------------  ####
####                                           ####
###################################################
###################################################
BNA_SCIMITARMSG="The FA4-18 (type 33) blade is not supported by the target firmware. Please use Element Manager to find out which slot it is in and remove it first."
BNA_XENONMSG="The FC10-6 (type 39) blade is not supported by the target firmware. Please use Element Manager to find out which slot it is in and remove it first."
BNA_QUATTROMSG="The FC8-64 (type 77) blade is not supported by the target firmware. Please use Element Manager to find out which slot it is in and remove it first. For a VF enabled switch, use Logical Switches to move all vacant ports in this slot to the default after removing the blade."
BNA_UNSUPPORTED_DL_VERMSG="Cannot downgrade to 6.4 or lower. Please downgrade to 7.0 first and then download the desired firmware version."
BNA_UNSUPPORTED_UP_VERMSG="Cannot upgrade directly to 7.2. Please upgrade to 7.0 first and then upgrade to 7.2."
BNA_UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL="Non disruptive firmware download is not supported when firmware download with two versions apart. Please try to use Element Manager with single mode option enabled."
BNA_UNSUPPORTED_AUTOREBOOT_OPT_WARN_MSG="auto reboot option is not allowed with single mode when upgrade from 6.3 to 7.0. Please make sure that auto-reboot is not enabled before proceeding."
BNA_UNSUPPORTEDPLATFORMMSG="Cannot download the requested firmware because the firmware doesn't support this platform. Please select another firmware."
BNA_SWITCH_FAULTY_MSG="Firmwaredownload is not allowed since the switchState is Faulty. Please recover the switch before proceeding."
BNA_UNSUPPORTED_EEMON_ON_DOWNGRADE="Downgrade is not allowed when end to end monitors are installed in AG. Please clear the end to end monitors installed before downgrading."
BNA_UNSUPPORTED_FMON_ON_DOWNGRADE="Downgrade is not allowed when frame monitors are installed in AG. Please clear the frame monitors installed before downgrading."
BNA_UNSUPPORTED_LICENSES_ON_DOWNGRADE="Downgrade is not allowed because enhanced licenses are installed. Please use the Element Manager to remove them before downgrading."
BNA_UNSUPPORTED_STATICFPORTS_CONFIG_ON_DOWNGRADE="Downgrade is not allowed because static F-ports are configured. Please use the Element manager to check for static F-ports and delete the static mapping before downgrading."
BNA_UDROLE_FWDL_DISALLOWED_MSG="Downgrade is not allowed because user-defined roles are present. Please use the Element Manager to check all the UD Roles and to check if any users assigned these roles. If there are such users, assign them default roles or delete them. Then remove the UD Roles." 
BNA_UNSUPPORTED_ZONE_SIZE="Downgrade is not allowed because the existing zone configuration is more than 1 MB. To downgrade to lower firmware version modify the existing zone configuration to 1 MB or less."
BNA_PORTNAME_LEN_DISALLOWED_MSG="Downgrade is not allowed because one or more port names are greater than 32 characters. Please check and fix the port name/length before downgrading." 
BNA_PORTSPEED_DISALLOWED_MSG="Downgrade is not allowed because one or more ports have speed configured as 10G/16G speed. Please remove unsupported blades CR8510(4)-16/CR8510-16 if present and use the Element Manager to change the speed before downgrading." 
BNA_PAD_FEATURE_CHECK_MSG="Downgrade is not allowed because for one or more ports Port Auto Disable (PAD) is enabled with no options configured. Use Port Auto Disable to disable PAD for those ports first." 
BNA_CONDOR3_BLADE_IS_PRESENT="FC16-32, FC16-48, CR8510(4)-16, and CR8510(8)-16 are not supported by the targeted firmware. Please use Element Manager to determine which of these are installed and remove them before continuing."
BNA_UNSUPPORTED_ENCRYPTION_VERSIONING_DEC="Downgrade is not allowed because Device decommission feature is in use. Please disable Device decommission. Make sure that there is no lun undergoing decommission, or is in failed state." 
BNA_FCOE_PROVISION_CONFIG_MSG="With the current upgrade/downgrade, the CEE start up configuration dcf.conf file will be incompatible with FCoE provisioning changes as part of this build. CEE start up configuration file, dcf.conf can be backed up for future use. The user can save the configuration as backup and apply it once upgrade/downgrade is complete, to restore the switch configuration in its respective build version. If you wish to save the configuration file please abort firmware download and save the configuration file before proceeding."
BNA_UNSUPPORTED_INTEROP_MODE="Upgrade to 7.0 or above is not allowed when interop mode is enabled. To upgrade, please disable interop mode." 
BNA_XFCIP_FEATURE_RESTRICTION="Downgrade is not allowed because some FCIP features are enabled and are not supported on the selected version. Please address these unsupported features before downgrading."
BNA_CONDOR_EX_PORT_RESTRICTION="Downgrade to selected version is not allowed because EX-Ports are configured on FR4-18i blade(s). Please use the Element Manager to remove EX-port configuration on the ports." 
BNA_McDATA_EX_PORT_RESTRICTION="Upgrade to selected version is not allowed because Ex or VEx Ports are configured in McData/Open interop mode. Please disable McData interop mode configuration using the Element Manager." 
BNA_NOS_EX_PORT_RESTRICTION="Downgrade to selected version is not allowed because EX-Ports are configured in Brocade NOS Interop mode. Please use the Element Manager to remove EX-port configuration on the ports." 
BNA_UNSUPPORTED_VEPORT_THRESHOLD_CONFIG="Downgrade is not allowed because high/low threshold for VE-Port on the switch(s) is configured to decimal value. Use the Element Manager to configure the threshold to an integer value and downgrade."
BNA_UNSUPPORTED_MULTIPLE_EMAIL_FW_ALERT="Downgrade is not allowed because Multiple recipient addresses might have been configured on any of the logical switches for any of the class to receive Fabric Watch email alerts. Please use the "fwMailCfg" CLI command to configure single recipient address before downgrading."
BNA_UNSUPPORTED_BRCD_CERTIFICATE_DATABASE_VALUE="Downgrade to 7.0 is not allowed because either 1) FCAP authentication to one of the neighboring switches is configured to use Brocade issued certificates, or 2) Brocade Certificate files exist. Please remove or set the configuration to thirdparty and delete certificate files using \"pkiremove\" before upgrading."
BNA_CHECK_LDAP_CONFIGURED_OVER_IPv6="Downgrade is not allowed because IPv6 configuration for LDAP is in use. Please use the Element Manager to remove all the IPv6 configuration for LDAP before downgrading."
BNA_UNSUPPORTED_IPFILTER_POLICY="Downgrade is not allowed because IPFILTER forwarding rule(s) is enabled. Please use the Element Manager to delete the FORWARD rule(s) from IPFILTER policy before downgrading." 
BNA_MARATHON_STRIKER_ERR_MSG="Firmware migration is not allowed since the FX8-24 and FR4-18i blades are both present.\nPlease remove the FR4-18i blades before proceeding with the firmware load."
BNA_MARATHON_STRIKER_WARN_MSG="After the firmware migration has completed, the FR4-18i blade(s) needs to be removed if the FX8-24 blade(s) is to be plugged into the chassis."
BNA_UNSUPPORTED_FWCONFIGURE1="Upgrade to 7.0 or above is not allowed because the threshold configuration changed alarm is set."
BNA_UNSUPPORTED_FWCONFIGURE2="Similar configuration may exist for other classes and areas and on other FIDs. Please unset the same." 
BNA_UNSUPPORTED_CHECK_SECOND_TIMEBASE1="Upgrade is not allowed because timebase is configured as seconds."
BNA_UNSUPPORTED_CHECK_SECOND_TIMEBASE2="Similar configurations may exist for other classes and areas and on other FIDs. Please use the Element Manager to configure the timebase to other unit and upgrade." 
BNA_UNSUPPORTED_TSTIMEZONE="Downgrade is not allowed because tstimezone is configured with three sections input. Please change the configuration with two sections and proceed." 
BNA_VPWWN_CONFIGURED="Downgrade is not allowed because Fabric Assigned PWWN is configured in one or more partitions. Please delete all the Fabric Assigned PWWN configurations before downgrading."  
BNA_VE_AS_XISL_CONFIGURED="Downgrade is not allowed, as there is a VE Port in the Base switch that could be used as an XISL and there is at least one logical switch with \"ALLOW XISL Use\" enabled. Either remove all VE Ports from the Base switch or disable XISL use in all logical switches and repeat the downgrade attempt."
BNA_FCIP_LS_WITH_XISL_ON="Downgrade is not allowed, as there is a VE Port in a logical switch that has \"ALLOW XISL Use\" enabled.  Please disable \"ALLOW XISL Use\" in all logical switches that include VE ports, and retry the downgrade attempt."
BNA_UNSUPPORTED_RRDY_BASE_SWITCH="Upgrade to 7.0 or above is not allowed since base switch has R_RDY enabled ports. Please disable the R_RDY enabled ports in base switch." 
BNA_UNSUPPORTED_IODDELAY_ON_UPGRADE="Upgrade to 7.0 or above is not allowed due to the presence of iod delay configuration. Please reset the feature with the CLI command \"ioddelayreset\" before upgrading to v7.0."
BNA_FCFW_NOT_SUPPORTED="Upgrade to 7.0 or above is not allowed because FC Fastwrite is not supported on this version. Please use the Element Manager to deconfigure FC Fastwrite for all slots and try again. "
BNA_BSTR_NOT_SUPPORTED="Upgrade to 7.0 or above is not allowed because TCP Byte Streaming is not supported on this version. Please use FCIP Tunnels to deconfigure TCP Byte Streaming for all tunnels and try again." 
BNA_UNSUPPORTED_DUP_PORT_WWN="Upgrade to 7.0 or above is not allowed because duplicate PWWN devices are detected in one or more partitions. Please configure the devices with unique PWWNs or disable the ports and remove the devices with duplicate PWWNs before upgrading the firmware." 
BNA_SERDES_TUNE_ENABLED="Downgrade is not allowed because FC8-16 serdestune mode is enabled. Please use the CLI command \"serdestunemode --show\" to view the mode and \"serdestunemode --reset\" to disable the feature before downgrading." 
BNA_ENHANCED_FC8_BLADE_IS_PRESENT="FC8-32E and FC8-48E are not supported by the targeted firmware. Please use Element Manager to determine which of these are installed and remove them before continuing." 
BNA_UNSUPPORTED_DBR_ON_DOWNGRADE="Downgrade is not allowed because Device Based Routing is configured. Please use the Element Manager to change the routing policy." 
BNA_FC8_BLADE_IS_PRESENT="FC8-16, FC8-32 and FC8-48 are not supported by the targeted firmware. Please use Element Manager to determine which of these are installed and remove them before continuing."
BNA_D_PORT_R_RDY_NOT_SUPPORTED="Downgrade is not allowed because R-RDY flow control ports are configured as D-Ports. Please use the Element Manager to disable these D-Ports before downgrading." 
BNA_D_PORT_DWDM_NOT_SUPPORTED="Downgrade is not allowed because D-Port is configured with DWDM mode. Please use \"portcfgshow\" to view the port list and \"portdisable [slot/]port; portcfgdport --disable -dwdm [slot/]port\" to reset DWDM mode before downgrading."
BNA_DIAGPOST_SKIP_MSG="Firmware download is not allowed because diagpost is enabled. Please use the CLI command \"diagpost --disable\" command to disable diagpost."
BNA_MAPS_ACTIVE="WARNING: The Monitoring and Alerting Policy Suite (MAPS) is enabled. Downgrading will revert back to Fabric Watch monitoring using last known active thresholds."
BNA_LOCATION_ID_CONFIGURED="Please use the \"configure\" command to clear the Location ID"
BNA_DOWNGDAOQ_SAO_REQ="Downgrade is not allowed as AoQ is active on server or HBA ports without Server Application Optimization license. To proceed further with downgrade either install Server Application Optimization license, or set QoS mode on AoQ enabled ports to OFF if it is ON/AE and then toggle these AoQ enabled ports to disable AoQ. Please use \"switchshow\" to view list of F_Port with AoQ feature enabled and use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF. To toggle the ports use \"portdisable [slot/]port and portenable [slot/]port\"."
BNA_DOWNGDAOQ_AN_REQ="Downgrade is not allowed as AoQ is active on device ports without Adaptive Networking license. To proceed further with downgrade either install Adaptive Networking license, or set QoS mode on AoQ enabled ports to OFF if it is ON/AE and then toggle these AoQ enabled ports to disable AoQ. Please use \"switchshow\" to view list of F_Port with AoQ feature enabled and use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF. To toggle the ports use \"portdisable [slot/]port and portenable [slot/]port\"."
BNA_DOWNGDAOQ_AN_SAO_REQ="Downgrade is not allowed as AoQ is active on server or HBA ports without Server Application Optimization license and Adaptive Networking license. To proceed further with downgrade either install Server Application Optimization license and Adaptive Networking license, or set QoS mode on AoQ enabled ports to OFF if it is ON/AE and then toggle these AoQ enabled ports to disable AoQ. Please use \"switchshow\" to view list of F_Port with AoQ feature enabled and use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF. To toggle the ports use \"portdisable [slot/]port and portenable [slot/]port\"."
BNA_DOWNGDQOS_AN_REQ_MSG1="Downgrade is not allowed as QoS mode is enabled (ON) on some of the ports and there is no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license, or set QoS mode to OFF/AE. Please use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF or use \"portcfgqos --default [slot/]port\" to set QoS mode on these ports to AE"
BNA_DOWNGDCSCTL_AN_REQ="Downgrade is not allowed as CSCTL mode is enabled (ON) on some of the ports and there is no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license, or set CSCTL mode to OFF. Please use \"portcfgqos --disable [slot/]port csctl_mode\" to set CSCTL mode on these ports to OFF."
BNA_DOWNGDRATELIMIT_AN_REQ="Downgrade is not allowed as Rate Limit is enabled (ON) on some of the ports and there is no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license, or reset Rate Limit to OFF. Please use \"portcfgqos --resetratelimit [slot/]port\" to reset Rate Limit on these ports to OFF."
BNA_DOWNGDQOS_AN_REQ_MSG3="Downgrade is not allowed as QoS is active on E_Port(s) with no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license on the switch, or turn OFF QoS on these ports. Please use \"islshow\" to view the list of E_Port(s) with QoS. In case these E_Port(s) are trunked, use \"trunkShow\" to list all the ports in the trunk group. Finally, use \"portcfgqos --disable [slot/]port\" to disable QoS on the ports."
BNA_DEFAULT_QOS_WARN_MSG="This action will set default QoS port configuration from AE to OFF."
BNA_SPIKE_VF_ENABLED="7800 Virtual Fabric mode is enabled in the switch and it requires version v7.1.0 or higher. Please delete all non-default logical switches and then disable VF Mode on the switch and retry the firmware downgrade."
BNA_UNSUPPORTED_ICL_PORT_CONFIGURATION="Firmware upgrade to Fabric OS 7.1.0 or higher is not allowed when there are more than 4 chassis interconnected through Inter-Chassis Links (ICLs) and the Enterprise ICL (EICL) license is not installed in the system. Note that even with an EICL license installed, only 10 chassis are allowed to interconnect through ICLs. You can either install an EICL license, or you must disable the additional ICL links before performing a firmware upgrade."
BNA_10G_SPEED_PRESENT_ERROR="Downgrade is not allowed because there are few ports other than the first octet of the blade/switch configured for 10G/N10 speeds.\nPlease change the octet speed combo of those ports to 1 using \"portcfgoctetspeedcombo\" CLI and change their speeds using \"portcfgspeed\" CLI."
BNA_MAPS_ENABLED="Downgrade is not allowed because Monitoring and Alerting Policy Suite (MAPS) is enabled.  Please disable MAPS before proceeding"
SIM_PORT_ENABLED="Downgrade is not allowed because SIM ports are configured on one or more switches.Please use  \"flow --control -simport [SlotNumber/]PortNumber -disable\" command to remove SIM port configuration."
BNA_FIPS_ENABLED="Upgrade to 7.2.1 and above is not allowed because FIPS is enabled. Please upgrade to 7.2.0 first before upgrading to this version."
UNSUPPORTED_DOWNGRADE_721="v7.2.1 FIPS complaint parameters are configured.Please use \"fipscfg --disable dh \" and \"fipscfg --disable sha256 \" before downgrading."
BNA_BUFOPMODE_ENABLED="Downgrade is not allowed. Please disable bufopmode using the CLI \"bufopmode --reset <slot>\" or \"bufopmode --resetall\" \n"
###################################################
###################################################
####                                           ####
####                                           ####
####       PRESINSTALL CHECK SECTION           ####
####    ------------------------------         ####
####                                           ####
###################################################
###################################################


correcthost() {
    if [ $ACTIVECP ]; then
	"$@"
    else
	/usr/bin/rsh -n $(otherhost) ROLE_ID=root LOGIN_ID=root CURRENT_AD=0 "$@"
    fi
}

#
# both Active and Standby have the information of
# VF and logical switches configured.
#
# VF case: on Standby CP, in order to login to each logical switch, 
# we need to set CHASSIS_ROLEID FABOS_SWITCHNO CURRENT_VF in rsh.
#
correcthost_to_curr_vfid() {
	if [ $ACTIVECP ] ; then
		# for_all_context already did "context_switch --switch vfid"
		"$@"
	else
		if [ $VF_ENABLED -eq $STS_OK ]; then
			# VF disabled
			/usr/bin/rsh -n $(otherhost) ROLE_ID=root LOGIN_ID=root CURRENT_AD=0 "$@"
		else
			# VF enabled, for_all_context changed glb_ls_id and glb_vf_id to each logical switch's
			/usr/bin/rsh -n $(otherhost) ROLE_ID=root LOGIN_ID=root CHASSIS_ROLEID=0 FABOS_SWITCHNO=$glb_ls_id CURRENT_VF=$glb_vf_id CURRENT_AD=0 "$@"
		fi
	fi
}

# 7800/FX8-24
# executes the provided function in the context of all configured virtual
# fabrics, and logical switches on the active and standby CP's to determine
# if a critera is met
correcthost_all_vfs() {
	if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF is enabled
		if [ $ACTIVECP ] ; then
			for_all_contexts correcthost_to_curr_vfid $@
		else
			# this is the standby cp, examine the configuration of the
			# active cp
			for_all_contexts_standby correcthost_to_curr_vfid $@
		fi
	else
		correcthost_to_curr_vfid $@
	fi
	if [ $? -eq 0 ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#
# chassisopt
#
# Retrieve the current chassisconfig option.
#
chassisopt() {
	sed -n -e 's/^Cur.\+on: \([[:digit:]]\{1,\}\).*$/\1/gp'
}

#
# marathon_present
#
# Check whether there are any marathon blades enabled in the system.
#
marathon_present() {

	MARATHON=$(/fabos/cliexec/slotshow | grep " 24 " | wc -l)
	return $MARATHON
}

#
# scimitar_present
#
# Check whether there are any marathon blades enabled in the system.
#
scimitar_present() {

	SCIMITAR=$(/fabos/cliexec/slotshow | grep " 33 " | wc -l)
	return $SCIMITAR
}

#
# xenon_present
#
# Check whether there are any marathon blades enabled in the system.
#
xenon_present() {

	XENON=$(/fabos/cliexec/slotshow | grep " 39 " | wc -l)
	return $XENON
}

#
# lance_present
#
# Check whether there are any lance blades enabled in the system.
#
lance_present() {

	LANCE=$(/fabos/cliexec/slotshow | grep " 43 " | wc -l)
	return $LANCE
}

#
# mace_present
#
# Check whether there are any mace blades enabled in the system.
#
mace_present() {

	MACE=$(/fabos/cliexec/slotshow -d576 | grep " 42 " | wc -l)
	return $MACE
}

#
# europa_present
#
# Check whether there are any europa blades enabled in the system.
#
europa_present() {

	EUROPA=$(/fabos/cliexec/slotshow -d576 | grep " 74 " | wc -l)
	return $EUROPA
}

#
# striker_present
#
# Check whether there are any striker blades enabled in the system.
#
striker_present() {

    STRIKER=$(/fabos/cliexec/slotshow -d576 | grep " 75 " | wc -l)
    return $STRIKER
}

#
# quattro_present
#
# Check whether there are any quattro blades enabled in the system.
#
quattro_present() {

    QUATTRO=$(/fabos/cliexec/slotshow -d576 | grep " 77 " | wc -l)
    return $QUATTRO
}

#
# pluto_chassis
#
# Check whether there are any zontron blades enabled in the system.
#
pluto_chassis() {

    	case ${SWBD##SWBD} in
        '77')
		return $STS_ERR
		;;
	*)
	        return $STS_OK
		;;
	esac
}


#
# Routing policy
#
# Check what routing policy it is.
#
routing_policy() {
	/fabos/sbin/aptpolicy | sed -n -e 's/^ Cur.\+Policy: \([[:digit:]]\{1,\}\).*$/\1/gp'
}

#
# check_ag_staticfports
# Check whether static F-ports configured or not
#

check_ag_staticfports() {

ag_mode=`/fabos/bin/ag --modeshow | grep -c "NOT enabled"`
if [ $ag_mode -eq 0 ]; then
	num_nsfports=`/fabos/cliexec/configshow | grep "ag.port.nsfporttopo." | wc -l`
	/fabos/cliexec/configshow | grep "ag.port.nsfporttopo." > /tmp/tmp_sfport.log

	staticflag=0
	nsfpt_pno=0
	while [ "$nsfpt_pno" -lt "$num_nsfports" ]
	do
		keyisthere=0
		keyisthere=`grep -wc "ag.port.nsfporttopo.$nsfpt_pno" /tmp/tmp_sfport.log`
		if [ "$keyisthere" -eq "1" ]; then

			left=`grep -w "ag.port.nsfporttopo.$nsfpt_pno" /tmp/tmp_sfport.log | cut -d : -f 2 |
			cut -d , -f 1 | grep -c "0x00000000"`
			right=`grep -w "ag.port.nsfporttopo.$nsfpt_pno" /tmp/tmp_sfport.log | cut -d : -f 2 |
			cut -d , -f 2 | grep -c "0x00000000"`
			other=`grep -wc "ag.port.nsfporttopo.$nsfpt_pno:0x0" /tmp/tmp_sfport.log`

			if [ "$other" -eq "0" ]; then
				
				if [ "$left" -eq "0" -o "$right" -eq "0" ]; then
					staticflag=1;
					break;
				fi

			fi

		fi
		nsfpt_pno=`/usr/bin/expr $nsfpt_pno + 1`
	done

    /bin/rm -f /tmp/tmp_sfport.log

	if [ "$staticflag" -eq "1" ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
fi

}

#
# check_ag_eemon_installed
# Check whether end to end monitors are installed in AG mode
#

check_ag_eemon_installed() {
	
    ag_mode=`/fabos/bin/ag --modeshow | grep -c "NOT enabled"`
    if [ $ag_mode -eq 0 ]; then
        eemon_count=`/fabos/link_bin/perfResourceShow --eeRes | grep "EEMON" | grep -c "[1-9]  |"`
        if [ $eemon_count -eq 0 ]; then
            return $STS_OK
        else
            return $STS_ERR
        fi
    fi
}
 
#
# check_ag_fmon_installed
# Check whether frame monitors are installed in AG mode
#

check_ag_fmon_installed() {
	
    ag_mode=`/fabos/bin/ag --modeshow | grep -c "NOT enabled"`
    if [ $ag_mode -eq 0 ]; then
        count=`/fabos/link_bin/fmMonitor --show -all | awk '{print $1}' | grep -c "[0-9]|"`
        if [ $count -eq 0 ]; then
            return $STS_OK
        else
            return $STS_ERR
        fi
    fi
}

#
# check_enhanced_licenses_installed
# Check whether any enhanced licenses are installed
#

check_enhanced_licenses_installed() {
	
    enh_licenses_installed=`/fabos/bin/licenseshow | grep -c "Feature name:"`
    if [ $enh_licenses_installed -eq 0 ]; then
        return $STS_OK
    else
        return $STS_ERR
    fi
}

#
# auto_csctl_enabled
#
# Check whether the switch is currently in auto csctl mode
#

auto_csctl_enabled() {

	context_switch chassis
	csctl_mode=`/fabos/cliexec/config get fos.csctlMode 2`
	return $csctl_mode
}

#
# ag_mode_enabled
#
# Check whether the switch is currently in AG mode
#
# JOE
ag_mode_enabled() {

	ag_mode=$(correcthost /fabos/link_bin/switchshow | grep -c "Access Gateway Mode")
	return $ag_mode

}

#
# check_ipfilter_forward_rule
#
# Check whether IPFILTER FORWARD rule is configured
#
check_ipfilter_forward_rule() {
	ip_forward=`/fabos/abin/ipfilter --show -a | grep -c "FWD"`
	
	if [ $ip_forward -gt 1 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

pid_format_two() {
	#
	# Block upgrade if PID format is set to 2
	#
	pid_format=`/fabos/cliexec/configshow | grep pidFormat | cut -f 2 -d ':'`
	if [ $pid_format -eq 2 ]; then
	    return $STS_ERR
	fi
	return $STS_OK
}

perf_mon_check() {

	# Run this check only on C2 and GEYE2 family of platforms.
	case ${SWBD##SWBD} in
		'71'|'62'|'66'|'64'|'77'|'42'|'72'|'73'|'75'|'67')
		#
		# Block upgrade if TT monitor are installed
		#
		/fabos/cliexec/configshow | grep "ttmonc" > /dev/null 2>&1
		rc=$?
		if [ $rc -eq 0 ]; then
			check_fcr_enabled
			if [ $? -ne $STS_OK ]; then
				return $STS_ERR
			fi
		fi
		;;
	*)
		return $STS_OK
		;;
	esac

	return $STS_OK
}

# Check if certificate is installed.
# Presence of non-zero length files under /etc/fabos/certs/sw0 directory
# implies certificate is installed on the switch.

check_nz_cert() {
   shopt -s nullglob
   for i in /etc/fabos/certs/sw0/*
   do
      [ ! -z "$i" ] && return 0
   done
      return 1
}

check_http_enabled() {
    F=/etc/fabos/fabos.0.conf

    #
    # If http.enabled is set to 1, return OK.
    #
    grep -q '^http\.enabled:1' $F  && return $STS_OK

    #
    # if certs are  not installed (chck_nz_cert == 1)
    # return error.
    #
    check_nz_cert || return $STS_ERR

    #
    # if certs are  installed but http.ssl.enabled is set to 0
    # return error.
    #
    grep -q '^http\.ssl\.enabled:0' $F && return $STS_ERR
    return $STS_OK
}


check_trunkarea_configured() {

    case $(correcthost /fabos/sbin/porttrunkarea --show enabled 2>&1) in
	("No ports have Trunk Area enabled") return $STS_OK;;
	("Error: This command is not supported in AG mode") return $STS_OK;;
	(*"No such file or directory") return $STS_OK;;
	(*) return $STS_ERR;;
	esac
}

#
# check if any TI over FCR zones are configured.
# i.e. look for a -1 or WWN in zone --show output.
# define local variable dd == 2 hex digits for ease of readability
# of the case pattern
#
check_ti_over_fcr_zone_configured() {
	local dd='[0-9a-fA-F][0-9a-fA-F]'
	local v=$(correcthost /fabos/cliexec/zone --show 2>/${NULL})
    case "$v" in
	(*$dd:$dd:$dd:$dd:$dd:$dd:$dd:$dd*) return $STS_ERR;;
	(*-1*) return $STS_ERR;;
	(*) return $STS_OK;;
	esac
}

#
# if upgrading to 6.3 make sure that
# no zones or configs are named with the msfr prefix
#
check_for_msfr_zone_names() {



	# check for msfr zone and config names
	# return good if both the zone name and config name are found
	# this is to protect agenst a Downgrade upgrade action where msfr zones
	# could be valid.  This will only throw an error if the zone name or the
	# config name match the msfr header but not both.

	if correcthost /fabos/cliexec/cfgshow | grep -q msfr_zn_; then
		if correcthost /fabos/cliexec/cfgshow | grep -q msfr_cfg_; then
			return $STS_OK
		else
			return $STS_ERR
		fi
	fi
	if correcthost /fabos/cliexec/cfgshow | grep -q msfr_cfg_; then
			return $STS_ERR
	fi

        return $STS_OK
}

im2_mode=" "
im3_mode=" "
im2_enable=0
im3_enable=0
check_interop_support() {
	# first check interop
	local tmp_mode=`correcthost_to_curr_vfid /fabos/cliexec/configshow | grep switch.interopMode`
	local im_mode=${tmp_mode//[^0-9]}

	tmp_mode=`correcthost_to_curr_vfid /fabos/cliexec/configshow | grep switch.mcdtFabricMode`
	local mcdt_mode=${tmp_mode//[^0-9]}

	if [ "$im_mode" == "0" ] && [ "$mcdt_mode" == "1" ]; then
		im2_enable=1
		if [ "$im2_mode" == " " ]; then
			im2_mode="$im2_mode $CURRENT_VF"
		else
			im2_mode="$im2_mode, $CURRENT_VF"
		fi
	elif [ "$im_mode" == "1" ] && [ "$mcdt_mode" == "1" ]; then
		im3_enable=1
		if [ "$im3_mode" == " " ]; then
			im3_mode="$im3_mode $CURRENT_VF"
		else
			im3_mode="$im3_mode, $CURRENT_VF"
		fi
	fi
}

check_interop_in_contexts() {
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		for_all_contexts check_interop_support
	else
		check_interop_support
	fi

	if [ "$im2_enable" == "1" ]; then
		add_err_status " * WARNING!!! McDATA Fabric mode(IM2) is enabled on the following FID(s)$im2_mode."
	fi

	if [ "$im3_enable" == "1" ]; then
		add_err_status " * WARNING!!! McDATA Open Fabric mode(IM3) is enabled on the following FID(s)$im3_mode."
	fi

	if [ "$im2_enable" == "1" ] || [ "$im3_enable" == "1" ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

check_snmp_trapEnterpriseFlag() 
{
	TRAPFLAG=`/fabos/cliexec/configshow -chassis | grep snmp.trapEnterpriseFlag: | cut -f 2 -d ':'`
	SYSOID=`/fabos/cliexec/configshow -chassis | grep sysObjectID: | cut -f 2 -d ':'`
	if [ "$TRAPFLAG" == "0" ] && [ "$SYSOID" != "1588.2.1.1.1" ]; then
		echo -e "\n$UNSUPPORTED_SNMP_TRAPOID\n"
		echo -e "$UNSUPPORTED_SNMP_TRAPOID" >> $BNA_STATUS_FILE
	fi
	return "$STS_OK"
}

check_snmp_priv_protocol()
{
	for (( i = 0; i < 6; i++ ))
	do
		if [ $ACTIVECP ]; then
		PRIVPROTO=`/fabos/cliexec/configshow -chassis | grep snmp.snmpv3Usm.$i.usmPrivProtocol: | cut -f 2 -d ':'`
		else
		cmd="PATH=/fabos/sbin:$PATH  CHASSIS_ROLEID=0 FABOS_SWITCHNO=0 CURRENT_VF=128 /fabos/cliexec/configshow -chassis | grep snmp.snmpv3Usm.$i.usmPrivProtocol: | cut -f 2 -d ':'"
		PRIVPROTO=`correcthost  $cmd`;
		fi
		if [ "$PRIVPROTO" -ge "3" ] && [ "$PRIVPROTO" != 4 ]; then
			return "$STS_ERR"
		fi
	done

	return "$STS_OK"
}

#
#
#   If any threshold for change is configured, do not allow
#	If any changed configurations are present, 
#	check whether the value is greater than 0
#   Defect: 388296 If Switch in ag mode and if there are E-port reated configuration 
#   allow upgrade to 7.x. 
#
check_fwconfigure_change()
{
	change_conf_count=$(correcthost_to_curr_vfid /fabos/cliexec/configshow | 
		grep thresh.cust | grep changed | wc -l)
	ag_enabled=$(correcthost /fabos/link_bin/switchshow | grep -c "Access Gateway Mode")
	if [ $change_conf_count -gt 0 ]; then
		correcthost_to_curr_vfid /fabos/cliexec/configshow | grep thresh.cust | 
		grep "changed" | 
		while read line 
		do 
			if [ $(echo $line | cut -d: -f2) -gt 0 ]; then
				class=`echo $line | cut -d "." -f3`
				area=`echo $line | cut -d "." -f4`
				if [ $ag_enabled -eq 0 ]; then
					add_err_status "$UNSUPPORTED_FWCONFIGURE1 for class $class,	area $area on FID $CURRENT_VF." "$BNA_UNSUPPORTED_FWCONFIGURE1 for class $class, area $area on FID $CURRENT_VF."
					return $STS_ERR
				else
					if [ "$class" != "eport" ]; then
						add_err_status "$UNSUPPORTED_FWCONFIGURE1 for class $class,	area $area on FID $CURRENT_VF." "$BNA_UNSUPPORTED_FWCONFIGURE1 for class $class, area $area on FID $CURRENT_VF."
						return $STS_ERR
					fi
				fi
			else
				continue
			fi
		done
	fi
}
#
#   Check for mulitiple switches including logical switches
#
check_multi_fwconfigure_change() {


    if [ $VF_ENABLED -ne $STS_OK ]; then
		if [ $ACTIVECP ] ; then
		        for_all_contexts check_fwconfigure_change
		else
			for_all_contexts_standby check_fwconfigure_change
		fi
    else
        check_fwconfigure_change
    fi
}

#
#  Allow downgrade if the encryption feature versioning  maj.min <  downgrade maj.min
#

check_feature_enabled()
{
    feature=$1
    if [ `/fabos/cliexec/configshow | grep "$feature" |wc -l` -gt 0 ]; then
        state=`/fabos/cliexec/configshow | grep "$feature" | cut -d ":" -f2`
        if [ $state == "Disabled" ]
        then
            return $STS_OK
        else
            return $STS_ERR
        fi
    else
        return $STS_OK
    fi
}

# This routine checks whether any of the 7.0.1 software
# features are active
check_71_0_enc_sw_features()
{       
        
    $ECHO check_71_0_enc_sw_features
        
    TEST check_feature_kmip  "${UNSUPPORTED_ENCRYPTION_VERSIONING_KMIP}"
    TEST check_feature_decommission_non_rkm_lkm "${UNSUPPORTED_ENCRYPTION_VERSIONING_DEC}" "${BNA_UNSUPPORTED_ENCRYPTION_VERSIONING_DEC}"
    return $RET_CODE
}

check_feature_kmip()
{
    KVTYPE=`/fabos/cliexec/configshow | grep spm.encrGrp.kvType | cut -f 2 -d ':'`
    if [ -z "$KVTYPE" ]; then
        return $STS_OK;
    fi
    if [ "$KVTYPE" == "$KEY_VAULT_TYPE_KMIP" ]; then
        return $STS_ERR
    fi
    return $STS_OK
}

check_feature_decommission_non_rkm_lkm()
{    
    KVTYPE=`/fabos/cliexec/configshow | grep spm.encrGrp.kvType | cut -f 2 -d ':'`
    if [ -z "$KVTYPE" ]; then
        return $STS_OK;
    fi
    if [ "$KVTYPE" == "$KEY_VAULT_TYPE_RSA" ] ||
       [ "$KVTYPE" == "$KEY_VAULT_TYPE_LKM" ] ; then
        return $STS_OK;
    fi

	ENC_LANCE=$(/fabos/cliexec/slotshow | grep " 43 " | wc -l)
	ENC_MACE=$(/fabos/cliexec/slotshow -d576 | grep " 42 " | wc -l)
	if [ "x$TYPE" != "xrestore" ]; then
		if [ 1 -eq $ENC_MACE -o 0 -ne $ENC_LANCE ]
		then
    		check_feature_enabled "cryptoDev.swEncFeatureMode.decom_non_rkm_lkm"
			if [ $? -ne 0 ]
			then
				return $STS_ERR
			fi
		fi
	fi

    return $STS_OK
}

check_feature_tklm()
{
	ENC_LANCE=$(/fabos/cliexec/slotshow | grep " 43 " | wc -l)
	ENC_MACE=$(/fabos/cliexec/slotshow -d576 | grep " 42 " | wc -l)
	if [ "x$TYPE" != "xrestore" ]; then
		if [ 1 -eq $ENC_MACE -o 0 -ne $ENC_LANCE ]
		then
			check_feature_enabled "cryptoDev.swEncFeatureMode.tklm"
			if [ $? -ne 0 ]
			then
				return $STS_ERR
			fi
		fi
	fi
	return $STS_OK
}

check_multiple_email_address_set_FW_alert() {

	MULTI_EMAIL=`/fabos/cliexec/configshow  | grep multi_rcpt | grep item_112 | grep -E  ','| wc -l`

	if [ $MULTI_EMAIL -gt 0 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

check_multi_email_set_allinstances() {


	if [ $VF_ENABLED -ne $STS_OK ]; then
		for_all_contexts check_multiple_email_address_set_FW_alert
	else
		check_multiple_email_address_set_FW_alert
	fi
}

check_tstimezone_with_three_sections() {

	key=`/fabos/bin/configshow -a | grep ts.tz`
	value=`echo $key | grep ts.tz | cut -f 2 -d ':'`
	no_fields=`echo $value |awk -F'/' '{print NF}'`
	no_fields=`expr $no_fields - 1`

	if [ $no_fields -eq 2 ]; then
                return $STS_ERR
        else
                return $STS_OK
        fi
}

check_tstimezone_with_three_sections_allinstances() {


	if [ $VF_ENABLED -ne $STS_OK ]; then
		for_all_contexts check_tstimezone_with_three_sections
	else
		check_tstimezone_with_three_sections
	fi
}

MAX_PARTITION=8
#print all the switches FID which have CR/FEC enabled F-ports.
check_for_switches_with_CR_FEC_FPorts_enabled() {
	partition=0
        switches="$1 is active on one or more F_Ports of these switches: "
        while [ $partition -le $MAX_PARTITION ]
        do
        	if [ -f /proc/fabos/switch/$partition/CR_FEC_F_Port ]
                then
                	if [ "$1" == "Credit Recovery" ]
                        then
                        	cr_ena=$(correcthost cat /proc/fabos/switch/$partition/CR_FEC_F_Port | grep "CR enabled" | cut -d ":" -f2)
                                if [ $cr_ena -ne 0 ]
                                then
                                	switches="$switches `cat /proc/fabos/switch/$partition/info  | grep "LS Attributes:" | cut -d "," -f1 | awk '{print $4}'`"
                                fi
			else
                                fec_ena=$(correcthost cat /proc/fabos/switch/$partition/CR_FEC_F_Port | grep "FEC enabled" | cut -d ":" -f2)
                                if [ $fec_ena -ne 0 ]
                                then
                                        switches="$switches `cat /proc/fabos/switch/$partition/info  | grep "LS Attributes:" | cut -d "," -f1 | awk '{print $4}'`"
                                fi
                        fi

                 fi

		partition=`expr $partition + 1`
	done
                add_err_status "$switches"


}

check_for_CR_FPorts_enabled() {
	ag_mode_enabled
	if [ $? -eq 0 ]; then
		partition=0
		while [ $partition -le $MAX_PARTITION ]
		do
			if [ -f /proc/fabos/switch/$partition/CR_FEC_F_Port ]
			then
				cr_ena=$(correcthost cat /proc/fabos/switch/$partition/CR_FEC_F_Port | grep "CR enabled" | cut -d ":" -f2)
				if [ $cr_ena -ne 0 ]
				then
					check_for_switches_with_CR_FEC_FPorts_enabled "Credit Recovery"
					return $STS_ERR
				fi
			fi
			partition=`expr $partition + 1`
		done
		return $STS_OK
	else
		return $STS_OK
	fi
}

check_for_FEC_FPorts_enabled() {
	ag_mode_enabled
	if [ $? -eq 0 ]; then 
		partition=0
		while [ $partition -le $MAX_PARTITION ]
		do
			if [ -f /proc/fabos/switch/$partition/CR_FEC_F_Port ]
			then
				fec_ena=$(correcthost cat /proc/fabos/switch/$partition/CR_FEC_F_Port | grep "FEC enabled" | cut -d ":" -f2)
				if [ $fec_ena -ne 0 ]
				then
					check_for_switches_with_CR_FEC_FPorts_enabled "FEC"
					return $STS_ERR
				fi
			fi
			partition=`expr $partition + 1`
		done
		return $STS_OK
	else
		return $STS_OK
	fi
}

check_for_vpwwns_configuration() {
	case ${SWBD##SWBD} in
        '62'|'77'|'109'|'71'|'66'|'64'|'92')
		context_switch chassis
		total_vpwwns=`/fabos/cliexec/fapwwn --show -totalcount | cut -d ' ' -f 6`
		if [ $total_vpwwns -gt 0 ]; then
			return $STS_ERR
		else
			return $STS_OK
		fi
        ;;
    	*)
        return $STS_OK
        ;;
    esac
}

MAX_PARTITION=8
check_flow_on_all_partitions() {
	partition=0
	counter=0
	fids=""
	while [ $partition -le $MAX_PARTITION ]; do
		if [ -f /etc/fabos/np.$partition.conf ]; then
			flows=`grep "np.meta.nflows:" /etc/fabos/np.$partition.conf | cut -d ":" -f2 | awk '{print $1}'`
			if [ "$flows" != "" ] && [ $flows -ne 0 ]; then
				fids="$fids `cat /proc/fabos/switch/$partition/info | grep "LS Attributes:" | cut -d "," -f1 | awk '{print $4}'`"
				counter=`expr $counter + 1`
			fi
		fi
		partition=`expr $partition + 1 `
	done

	if [ $counter -gt 0 ]; then
		if [ $VF_ENABLED -ne $STS_OK ]; then
			add_err_status "Flows are configured on FID(s): $fids"
		fi
		return $STS_ERR
	else
		return $STS_OK
	fi

}

#check if zone size greater than 1MB
check_max_zone_size() {
	size=`/fabos/cliexec/cfgsize | grep committed | cut -d ' ' -f 10`
	if [ $size -gt 1045274 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

#check if zone size greater than 1MB in all contexts
check_max_zone_size_in_contexts() {
    if [ $VF_ENABLED -ne $STS_OK ]; then
        CHASSISCMD="cmd_chassis"
        for_all_contexts check_max_zone_size
    else
        check_max_zone_size
    fi
}

#check if rrdy is enabled in base switch
check_rrdy_base_switch () {
	BASE=`/fabos/bin/switchshow | grep "Base Switch:" | cut -d ' ' -f 6 | cut -d ',' -f 1`

	if [ "$BASE" == "Yes" ]; then
		PORTCFG=`/fabos/link_bin/portcfgshow | grep "ISL R_RDY Mode" | grep "ON" | wc -l`

		if [ $PORTCFG -gt 0 ]; then
			return $STS_ERR
		else
			return $STS_OK
		fi
	else
		return $STS_OK
	fi
}

#check if rrdy enabled in all contexts
check_rrdy_mode_in_contexts() {
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		for_all_contexts check_rrdy_base_switch
	else
		return $STS_OK
	fi
}

#
#
# credit_recovery_check_active
# This checks the active CP for any credit recovery active ports.
#
credit_recovery_check_active() {
	string=`/fabos/cliexec/islshow | grep -c "CR_RECOV"`
	return $string
}

#
# credit_recovery_check_standby
# This is run for stand by CP. Run rsh to check from active CP for credit recovery ports.
#
credit_recovery_check_standby() {
	string=`/usr/bin/rsh -n $(otherhost) ROLE_ID=root LOGIN_ID=root CURRENT_AD=0 /fabos/cliexec/islshow | grep -c "CR_RECOV"`
	return $string
}

#
# credit_recovery_enabled
#
# Check if credit recovery is enabled on any local ports. If it is
# configured we fail the firmware downgrade cases.
#
credit_recovery_enabled() {

    if [ $ACTIVECP ]; then
	credit_recovery_check_active
    else
	credit_recovery_check_standby
    fi
}

#
# check_ag_trunk_configured
#
# Check whether any of N_Port trunks are enabled or not
#
check_ag_trunk_configured() {
	if [ -f "/etc/fabos/ag_platform.0" ]; then
		/fabos/bin/switchshow | grep -c Trunk > /dev/null 2>&1
		rc=$?
		if [ $rc -eq 0 ]; then
			return $STS_ERR
		else
			return $STS_OK
		fi
	else
	    return $STS_OK
	fi
}

#
# FCFW
# Check if FC Fastwrite enabled
#
fcfw_configured()
{
	FCFWCHECK=`correcthost_all_vfs /fabos/cliexec/configshow | grep -c "portCfg.*FCFW"`

	if [ $FCFWCHECK -gt 0 ]; then
      echo -e "`correcthost_all_vfs /fabos/cliexec/configshow | grep FCFW | sed -e 's/portCfg.S/Slot /' -e 's/.P/ Port GE/' -e 's/.MODE:/ mode is /'`\n"
		return $STS_ERR
	fi
	return $STS_OK
}

#
# BSTR
# Check if TCP Byte Streaming enabled
#
bstr_configured()
{
	BSTRCHECK=`correcthost_all_vfs /fabos/cliexec/configshow | grep -c "TcpStr=1"`

	if [ $BSTRCHECK -gt 0 ]; then
		return $STS_ERR
	fi
	return $STS_OK
}

#
# FCoE Provision warning message.
#
fcoe_provision_warn_msg()
{
	if [ ${SWBD##SWBD} == '62' ] || [ ${SWBD##SWBD} == '77' ]; then
		# Check if any Europa blades are present or not.
		europa_present
		if [ $? -gt 0 ]; then
			echo -e $FCOE_PROVISION_CONFIG_MSG
			echo -e $BNA_FCOE_PROVISION_CONFIG_MSG >> $BNA_STATUS_FILE
		fi
	fi
	return $STS_OK
}

#
# 7800/FX8-24
# Check is any FCIP restrictions are exceeded.
#
check_xfcip_features()
{
    ret=$STS_OK

    # Make special note of FCOE build as this has new FCIP features
    if [ -z $TYPE ]; then
        /bin/cat /tmp/release.plist  2> /dev/null | grep -i "6.4.1_fcoe"  > ${NULL} 2>&1
    else
        /bin/cat /mnt/fabos/share/release  2> /dev/null | grep -i "6.4.1_fcoe" > ${NULL} 2>&1
    fi
    if [ $? -eq 0 ]; then
		FCOE="_fcoe"
    else
		FCOE=""
    fi

	ACTIVE_MAJOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Major://gp'`
	if [ $ACTIVE_MAJOR -ge 7 ]; then
		case ${SWBD##SWBD} in
			'62' | '77' | '83')
				if correcthost_all_vfs /fabos/link_bin/portShow fciptunnel all --validate ${TO_MAJOR}.${TO_MINOR}.${TO_PATCH}${FCOE} | grep . >> $STATUS_FILE; then
					ret=$STS_ERR
				fi
				if correcthost_all_vfs /fabos/link_bin/portShow ipif all --validate ${TO_MAJOR}.${TO_MINOR}.${TO_PATCH}${FCOE} | grep . >> $STATUS_FILE; then
					ret=$STS_ERR
				fi
			;;
			*)
				ret=$STS_OK
			;;
		esac
	else
		ret=$STS_OK
	fi

    return $ret
}

#
# 7800/FX8-24
# Check if inband management is configured
#
check_xfcip_inband_configured()
{
	if correcthost_all_vfs /fabos/cliexec/configshow | grep -q "XMGMTIF"; then
		return $STS_ERR
	fi
	if correcthost_all_vfs /fabos/cliexec/configshow | grep -q "XMGMTRTE"; then
		return $STS_ERR
	fi
	return $STS_OK
}

#
# vf_enabled
#
# Check whether VF is enabled
# both Active and Standby have this information
#
check_vf_enabled() {
	/fabos/bin/fosconfig --show | grep "Virtual Fabric" | grep enabled > /dev/null 2>&1

	if [ $? -eq 0 ]; then
        return $STS_ERR
    else
        return $STS_OK
    fi

}

check_if_ioddelay_set_in_activecp ()
{
    delay_val=`/fabos/cliexec/configshow | grep -i "route.iodDelay" | cut -d ":" -f2`

    #
    # Check if any of the configured value is GT 0. This is because
    # -1 is default value.
    #
    for i in $delay_val; do
        if [ $i -gt 0 ]; then
            # Iod delay is configured. Fail the downgrade process.
            return $STS_ERR
        fi
    done
    return $STS_OK
}

check_if_ioddelay_set_in_standby ()
{
    delay_val=`/usr/bin/rsh -n $(otherhost) ROLE_ID=root LOGIN_ID=root CURRENT_AD=0 /fabos/cliexec/configshow | grep -i "route.iodDelay" | cut -d ":" -f2`

    for i in $delay_val; do
        if [ $i -gt 0 ]; then
            # Iod delay is configured on standby. Fail downgrade process
            return $STS_ERR
        fi
    done
    return $STS_OK
}

check_for_ioddelay_set()
{
	if [ $ACTIVECP ]; then
		check_if_ioddelay_set_in_activecp
	else
		check_if_ioddelay_set_in_standby
	fi
}

check_ioddelay_set_in_contexts()
{
	if [ $VF_ENABLED -ne $STS_OK ]; then
		for_all_contexts check_if_ioddelay_set_in_activecp
	else
		check_if_ioddelay_set_in_activecp
	fi
}

#
# This routine checks whether any of the 6.4 hardware
# is active, e.g. whether a 6.4 blade/switch is enabled
# or present.
#
check_64_hw_features()
{
	$ECHO check_64_hw_features

	TEST quattro_present "$QUATTROMSG" "$BNA_QUATTROMSG"

	return $RET_CODE
}

#
# This routine checks whether any of the pre ElDorado hardware
# is active or present.
#
check_pre_71_hw_features()
{
	$ECHO check_pre_71_hw_features

	if [ $CUR_MAJOR -eq 6 ]; then
		TEST scimitar_present "$SCIMITARMSG" "$BNA_SCIMITARMSG"
	fi		

	TEST marathon_present "$MARATHONMSG"

	TEST xenon_present "$XENONMSG" "$BNA_XENONMSG"
	
	return $RET_CODE
}

lsan_matrix_supported()
{
	fcrmatrix=`/fabos/bin/fcrlsanmatrix | grep -E "FCR Matrix is activated"| wc -l`
	return $fcrmatrix
}

#Check for EX_PORT Interop Modes.
#Before firmware download to v7.1.0
#check if any EXport is configured in IM2 or IM3.
#If so firmware download should not happen and 
#proper error messge should be displayed
check_ex_ports_IM() {
	if [ $TO_MAJOR -ge 7 -a $TO_MINOR -ge 1 -a $TO_PATCH -ge 0 ]; then
	$ECHO $TO_MAJOR $TO_MINOR $TO_PATCH
		ACTIVE_MAJOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Major://gp'`
		ACTIVE_MINOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Minor://gp'`
		fcrdbgport=`correcthost_to_curr_vfid ls -1 /fabos/cliexec | grep fcrdbgport_cfg_exports | wc -l`

		if [ $ACTIVE_MAJOR -ge 7 -a $ACTIVE_MINOR -ge 2 -a $fcrdbgport -ge 1 ] || 
			[ $ACTIVE_MAJOR -gt 7 ]; then
			check_fcrdbg_ex_ports_IM_configured
			if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
		else
			if [ $VF_ENABLED -ne $STS_OK ]; then
				# VF enabled
				CHASSISCMD="cmd_chassis"
				for_all_contexts check_ex_ports_IM_configured
			else
				# VF disabled
				check_ex_ports_IM_configured
			fi
			if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
		fi
	fi
	return $STS_OK
}

check_ex_ports_IM_configured() {
     if `correcthost_to_curr_vfid /fabos/bin/slotshow |grep "ENABLED" 1>/dev/null 2>&1` ;
        then
            correcthost_to_curr_vfid /fabos/bin/switchshow |
                  /bin/grep -E '\<(EX-Port|Disabled|No_Sync|In_Sync|No_Module|No_Light|Offline)\>'|
            while read index slot port restyy
            do
                $ECHO $slot $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
               if `correcthost_to_curr_vfid /fabos/link_bin/portcfgexport $slot/$port |
                grep -q "Operate mode.*McDATA*\|Operate mode.*Open"` ; then
                add_err_status " * One or more EX-port on slot $slot is configured in McData/Open interop-mode"

                # due to the pipe, return is just like break from current while
                # loop.
                return $STS_ERR
                fi
            done
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
            # The return above exits the subshell started by the pipe
            # return here if the subshell exited early.
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi

     else
            correcthost_to_curr_vfid /fabos/bin/switchshow |
                /bin/grep -E '\<(EX-Port|Disabled|No_Sync|In_Sync|No_Module|No_Light|Offline)\>'|
            while read index port restyy
            do
                $ECHO $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
                if `correcthost_to_curr_vfid /fabos/link_bin/portcfgexport $port |
                grep -q "Operate mode.*McDATA*\|Operate mode.*Open"` ; then
                add_err_status " * One or more EX-port on slot $slot is configured in McData/Open interop-mode"
                # due to the pipe, return is just like break from current while
                # loop.
                return $STS_ERR
                fi
            done
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
            #The return above exits the subshell started by the pipe
            #return here if the subshell exited early.
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
     fi
     return $STS_OK
}
check_fcrdbg_ex_ports_IM_configured() {

	# Verify EX-Port is configured with the Mcdata or Open mode
	if `correcthost_to_curr_vfid /fabos/cliexec/fcrdbgport_cfg_exports --allport |
	    grep "enabled" | grep "McDATA\|Open" 1>/dev/null 2>&1` ; then
		add_err_status " * One or more EX-port is configured in McData/Open interop-mode"
		return $STS_ERR
	fi
	#return here if the subshell exited early.
	if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	return $STS_OK
}
#Check for VEX_PORT Modes.
#Before firmware download to v7.1.0
#check if any EXport is configured in IM2 or IM3.
#If so firmware download should not happen and 
#proper error messge should be displayed
check_vex_ports_IM() {
	if [ $TO_MAJOR -ge 7 -a $TO_MINOR -ge 1 -a $TO_PATCH -ge 0 ]; then

		ACTIVE_MAJOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Major://gp'`
		ACTIVE_MINOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Minor://gp'`
		
		fcrdbgport=`correcthost_to_curr_vfid ls -1 /fabos/cliexec | grep fcrdbgport_cfg_exports | wc -l`

		if [ $ACTIVE_MAJOR -ge 7 -a $ACTIVE_MINOR -ge 2 -a $fcrdbgport -ge 1 ] || 
			[ $ACTIVE_MAJOR -gt 7 ]; then
			# call to verify the EX-port
			check_fcrdbg_vex_ports_IM_configured
			if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
		else
			if [ $VF_ENABLED -ne $STS_OK ]; then
				# VF enabled
				CHASSISCMD="cmd_chassis"
				for_all_contexts check_vex_ports_IM_configured
			else
				# VF disabled
				check_vex_ports_IM_configured
			fi
			if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
		fi
	fi
	return $STS_OK
}

check_fcrdbg_vex_ports_IM_configured() {
	if `correcthost_to_curr_vfid /fabos/cliexec/fcrdbgport_cfg_exports --vex |
	    grep "enabled" | grep "McDATA\|Open" 1>/dev/null 2>&1` ; then
		add_err_status " * One or more VEX-port is configured in McData interop-mode"
		return $STS_ERR
	fi
	#return here if the subshell exited early.
	if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	return $STS_OK
}

check_vex_ports_IM_configured() {
		if `correcthost_to_curr_vfid /fabos/bin/slotshow |grep "ENABLED" 1>/dev/null 2>&1` ;
		then
            correcthost_to_curr_vfid /fabos/bin/switchshow |
                  /bin/grep -E '\<(VEX-Port|Disabled|No_Sync|In_Sync|No_Module|No_Light|Offline)\>'|
            while read index slot port restyy
            do
                $ECHO $slot $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
               if `correcthost_to_curr_vfid /fabos/link_bin/portcfgvexport $slot/$port |
                grep -q "Operate mode.*McDATA*\|Operate mode.*Open"` ; then
                add_err_status " * One or more VEX-port on slot $slot is configured in McData interop-mode"

                # due to the pipe, return is just like break from current while
                # loop.
                return $STS_ERR
                fi
            done
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
            # The return above exits the subshell started by the pipe
            # return here if the subshell exited early.
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
        else
            correcthost_to_curr_vfid /fabos/bin/switchshow |
                /bin/grep -E '\<(VEX-Port|Disabled|No_Sync|In_Sync|No_Module|No_Light|Offline)\>'|
            while read index port restyy
            do
                $ECHO $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
                if `correcthost_to_curr_vfid /fabos/link_bin/portcfgvexport $port |
                grep -q "Operate mode.*McDATA*\|Operate mode.*Open"` ; then
                add_err_status " * One or more VEX-port on slot $slot is configured in McData interop-mode"
                # due to the pipe, return is just like break from current while
                # loop.
                return $STS_ERR
                fi
            done
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
            #The return above exits the subshell started by the pipe
            #return here if the subshell exited early.
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
        fi
    return $STS_OK
}
# Check for VE XISL s/w feature port configuration
# before going down to 6.3 or 6.4. Prevent download
# if a VE XISL is configuration is present. This needs to do
# this for Striker.
#
check_for_ve_xisl_configuration() {
	case ${SWBD##SWBD} in
		'62' | '77')

		striker="75"
		if `correcthost_to_curr_vfid /fabos/bin/slotshow | grep "${striker}" 1>/dev/null 2>&1`;
		then
			$ECHO "Striker Blade is present in SWBD" ${SWBD##SWBD}
			if [ $VF_ENABLED -ne $STS_OK ]; then
				# VF enabled
				# Get FID of Base switch, Default swich and List of LS switches
				/bin/ln -sf /fabos/cliexec/lscfg_util /fabos/link_sbin/lscfg_test
				X_BS=`lscfg_test --all | grep Base | awk {'print $2'}`

				if [ "x${X_BS}" == "x" ]
				then
					# If no base switch, no need to check anything else. 
					context_switch chassis
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"
					return $STS_OK
				fi

				X_DS=`lscfg_test --all | grep Default | awk {'print $2'}`

				X_max=`lscfg_test --all | grep Logical | awk {'print $2'} | wc -l`

				if [ $X_max -gt 0 ]
				then
					X_LS=( `lscfg_test --all |grep Logical | awk {' print $2 '} ` )
				else
					context_switch chassis
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"
					return $STS_OK
				fi
				
				X_Flag=0
				for i_index in ${X_LS[@]}
				do
					context_switch $i_index
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"

					XISL_use=`correcthost_to_curr_vfid /fabos/link_bin/switchshow | grep "Allow XISL" | awk '{ print $4 }'`
					if [ "${XISL_use}" == "ON" ]
					then
						X_Flag=1
					fi
				done

				if [ ${X_Flag} -eq 1 ]
				then
					context_switch $X_BS
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"

					if [ `correcthost_to_curr_vfid /fabos/link_bin/switchshow | grep "VE" | wc -l` -gt 0 ]
					then
						context_switch chassis
						glb_vf_id="$CURRENT_VF"
						glb_ls_id="$FABOS_SWITCHNO"
						return $STS_ERR
					fi
				fi	

				context_switch chassis
				glb_vf_id="$CURRENT_VF"
				glb_ls_id="$FABOS_SWITCHNO"
				return $STS_OK		

			else
				# VF disabled
				return $STS_OK		
			fi
		fi
	esac
	return $STS_OK
}

#
# Check for VE Resources in a LS with Allow XISL Use enabled. 
# before going down to 6.3 or 6.4. Prevent any download
# that has FCIP Resources that could use an XISL. 
#
check_for_fcip_using_xisl_configuration() {
	case ${SWBD##SWBD} in
		'62' | '77')

		striker="75"
		if `correcthost_to_curr_vfid /fabos/bin/slotshow | grep "${striker}" 1>/dev/null 2>&1`;
		then
			$ECHO "Striker Blade is present in SWBD" ${SWBD##SWBD}
			if [ $VF_ENABLED -ne $STS_OK ]; then
				# VF enabled

				# Get FID of Base switch, Default swich and List of LS switches

				/bin/ln -sf /fabos/cliexec/lscfg_util /fabos/link_sbin/lscfg_test
				X_BS=`lscfg_test --all | grep Base | awk {'print $2'}`
				if [ "x${X_BS}" == "x" ]
				then
					# If no base switch, no need to check anything else. 
					context_switch chassis
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"
					return $STS_OK
				fi

				X_DS=`lscfg_test --all | grep Default | awk {'print $2'}`

				X_max=`lscfg_test --all | grep Logical | awk {'print $2'} | wc -l`

				if [ $X_max -gt 0 ]
				then
					X_LS=( `lscfg_test --all |grep Logical | awk {' print $2 '} ` )
				else
					context_switch chassis
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"
					return $STS_OK
				fi
				
				for i_index in ${X_LS[@]}
				do
					context_switch $i_index
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"

					XISL_use=`correcthost_to_curr_vfid /fabos/link_bin/switchshow | grep "Allow XISL" | awk '{ print $4 }'`
					if [ "${XISL_use}" == "ON" ]
					then
						if [ `correcthost_to_curr_vfid /fabos/link_bin/switchshow | grep "VE" | wc -l` -gt 0 ]
						then
							context_switch chassis
							glb_vf_id="$CURRENT_VF"
							glb_ls_id="$FABOS_SWITCHNO"
							return $STS_ERR
						fi
					fi
				done

				context_switch chassis
				glb_vf_id="$CURRENT_VF"
				glb_ls_id="$FABOS_SWITCHNO"
				return $STS_OK		

			else
				# VF disabled
				return $STS_OK		
			fi
		fi
	esac
	return $STS_OK
}

#
# Check for NOS mode (IM5) EX_PORT before downgrading to lower version of
# v7.0.1 (Toro release). This is wrapper function which will be executed per LS
# if VF is enabled. We need to call this function for all the allowable
# downgrade version of v7.0.1 (both disruptive/non-disruptive)
#

check_nos_ex_ports() {
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -gt 0 ]; then
		 if [ $TO_MAJOR -eq 7 -a $TO_MINOR -eq 0 -a $TO_PATCH -eq 0 ] || [ $TO_MAJOR -eq 6 ]; then
			ACTIVE_MAJOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Major://gp'`
			ACTIVE_MINOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Minor://gp'`

			fcrdbgport=`correcthost_to_curr_vfid ls -1 /fabos/cliexec | grep fcrdbgport_cfg_exports | wc -l`

			if [ $ACTIVE_MAJOR -ge 7 -a $ACTIVE_MINOR -ge 2 -a $fcrdbgport -ge 1 ] || 
				[ $ACTIVE_MAJOR -gt 7 ]; then
				check_fcrdbg_nos_ex_ports_configured
				if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
			else
				if [ $VF_ENABLED -ne $STS_OK ]; then
					# VF enabled
						CHASSISCMD="cmd_chassis"
						for_all_contexts check_nos_ex_ports_configured
				else
					# VF disabled
						check_nos_ex_ports_configured
				fi
				if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
			fi
		fi
	fi
	return $STS_OK
}

check_nos_ex_ports_configured() {
	if `correcthost_to_curr_vfid /fabos/bin/slotshow |grep "ENABLED" 1>/dev/null 2>&1` ;
	then
		correcthost_to_curr_vfid /fabos/bin/switchshow |
			/bin/grep -E '\<(EX-Port|Disabled|No_Sync|In_Sync|No_Module|No_Light)\>'|
		while read index slot port restyy
		do
			$ECHO $slot $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
			if `correcthost_to_curr_vfid /fabos/link_bin/portcfgexport $slot/$port |
				grep -q "Operate mode.*NOS"` ; then
				add_err_status " * One or more EX-Port on slot $slot is configured in Brocade NOS Interop-mode"

				# due to the pipe, return is just like break from current while
				# loop.
				return $STS_ERR
				fi
		done
		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
			# The return above exits the subshell started by the pipe
			# return here if the subshell exited early.
		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	else 
		check_nos_ex_ports_configured_pizzabox
		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	fi
	return $STS_OK
}

check_fcrdbg_nos_ex_ports_configured() {
	if `correcthost_to_curr_vfid /fabos/cliexec/fcrdbgport_cfg_exports --allport |
	   grep "enabled" | grep "NOS" 1>/dev/null 2>&1` ; then
		add_err_status " * One or more EX-Port is configured in Brocade NOS Interop-mode"
		return $STS_ERR
	fi
	# return here if the subshell exited early.
	if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	return $STS_OK
}



check_nos_ex_ports_configured_pizzabox() {
        correcthost_to_curr_vfid /fabos/bin/switchshow |
			grep -E '\<(EX-Port|Disabled|No_Sync|In_Sync|No_Module|No_Light)\>'| 
		while read index port restyy
        do
            $ECHO $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
            if `correcthost_to_curr_vfid /fabos/link_bin/portcfgexport $port |
                grep -q "Operate mode.*NOS"` ; then
                add_err_status " * One or more EX-Port is configured in Brocade NOS Interop-mode"

                # due to the pipe, return is just like break from current while
                # loop.
				return $STS_ERR
            fi
        done
    	if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	    # The return above exits the subshell started by the pipe
	    # return here if the subshell exited early.
    		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi

	return $STS_OK
}

#
# Check for long distance ports with -buffers option before downgrading to lower version of
# v7.1.0 (Eldorado release). This is wrapper function which will be executed per LS
# if VF is enabled. We need to call this function for all the allowable
# downgrade version of v7.1.0 (both disruptive/non-disruptive)
#
check_longdist_buffer_option_ports() {
		if [ $VF_ENABLED -ne $STS_OK ]; then
			CHASSISCMD="cmd_chassis"
		# VF enabled
			if [ $ACTIVECP ]; then
				for_all_contexts check_longdistance_buffer_option_ports_configured
			else
				for_all_contexts_standby check_longdistance_buffer_option_ports_configured
			fi
		else
		# VF disabled
			check_longdistance_buffer_option_ports_configured
		fi
		if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
		return $STS_OK

}

check_longdistance_buffer_option_ports_configured() {
		if `correcthost_to_curr_vfid /fabos/bin/slotshow |grep "ENABLED" 1>/dev/null 2>&1` ;
		then
	        correcthost_to_curr_vfid /fabos/bin/switchshow |
    	          /bin/grep -E '\<(LS|LD)\>'|
        	while read index slot port restyy
	        do
            	$ECHO $slot $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
				if `correcthost_to_curr_vfid /fabos/link_bin/portcfgshow $slot/$port |
					grep -q "Desired Buffers.*"` ; then
						add_err_status " * $slot/$port is configured as longdistance with -buffers option"

						# due to the pipe, return is just like break from current while
						# loop.
						return $STS_ERR
				fi
	        done
    		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
		    # The return above exits the subshell started by the pipe
		    # return here if the subshell exited early.
    		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
		else 
			check_longdistance_buffer_option_ports_configured_pizzebox
    		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
		fi
	return $STS_OK
}

check_longdistance_buffer_option_ports_configured_pizzebox() {
        correcthost_to_curr_vfid /fabos/bin/switchshow |
    	          /bin/grep -E '\<(LS|LD)\>'|
		while read index port restyy
        do
            $ECHO $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
			if `correcthost_to_curr_vfid /fabos/link_bin/portcfgshow $port |
				grep -q "Desired Buffers"` ; then
					add_err_status " * $port is configured as Longdistance -buffers option "

					# due to the pipe, return is just like break from current while
					# loop.
					return $STS_ERR
			fi
        done
   		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	    # The return above exits the subshell started by the pipe
	    # return here if the subshell exited early.
   		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi

	return $STS_OK
}

check_portcfg_eport_credit() {
	eport_credit_ret=`correcthost_to_curr_vfid  /fabos/bin/portcfg_eport_credit | grep "E-Port"`
	if [ $? -eq 0 ]; then  
		add_err_status "$eport_credit_ret"
		return $STS_ERR;
	fi      
	return $STS_OK 
}

#
# Check for SIM port Configuration on all partition and if found 
# firmware downgrade v7.2.0 --> v7.1.0 or  7.2.0--> v7.0.0 will fail. 
#

MAX_PARTITION=8
check_sim_port_enabled () {
        partition=0
	counter=0
        switches="SIM ports configured switches: "
        while [ $partition -le $MAX_PARTITION ]
        do
                if [ -f /etc/fabos/np.$partition.conf ]
                then
						simport_present=`grep "np.meta.simport:" /etc/fabos/np.$partition.conf | cut -d ":" -f2 | awk '{print $1}'`
                        if [ "$simport_present" != "" ]
						then	
							switches="$switches `cat /proc/fabos/switch/$partition/info  | grep "LS Attributes:" | cut -d "," -f1 | awk '{print $4}'`"
							counter=`expr $counter + 1`
                        fi
                fi

                partition=`expr $partition + 1 `
        done

	if [ $counter -gt 0 ]; then
		if [ $VF_ENABLED -ne $STS_OK ]; then
			add_err_status "$switches"
		fi
		return $STS_ERR
	else
		return $STS_OK
	fi
}


#
# Check for Encryption and Compression on EX_PORT before downgrading to lower version of
# v7.1.0 (Eldorado release).
#
# Check if more than 2 port per chip are configured for for Encryption and Compression
# before downgrading to lower version of v7.1.0 (Eldorado release).
#
check_enc_comp_fwdl() {
		if `correcthost_to_curr_vfid /fabos/bin/enccomp_fwdl_check | grep -q "chip"`; then
			add_err_status  "$ENC_COMP_FWDL_RESTRICTION"
			return $STS_ERR
		elif `correcthost_to_curr_vfid /fabos/bin/enccomp_fwdl_check | grep -q "EX-Ports"`; then
			add_err_status  "$ENC_COMP_EX_PORT_RESTRICTION"
			return $STS_ERR
		else
			return $STS_OK
		fi
}

#
# Check for Marathon EX_PORT port configuration
# before upgrading to 7.0. prevent any download
#
check_condor_ex_ports_configured() {
	case ${SWBD##SWBD} in
		'62' | '77')

		marathon="24"
		correcthost_to_curr_vfid /fabos/bin/slotshow | grep "${marathon}" 1>/dev/null 2>&1
		if [ $? -eq 0 ]
		then
			if [ $VF_ENABLED -ne $STS_OK ]; then
				# VF enabled
					CHASSISCMD="cmd_chassis"
					for_all_contexts check_marathon_ex_ports_configured
			else
				# VF disabled
				check_marathon_ex_ports_configured
			fi
			if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
		fi
	esac
	return $STS_OK
}

#
# check if EX port configured on any marathon blade in every logical switch
# If so fail the upgrade to 7.0
#
check_marathon_ex_ports_configured() {
    marathon="24"

    correcthost_to_curr_vfid /fabos/bin/slotshow | grep "${marathon}" |
    while read str_slot restyy
    do
        correcthost_to_curr_vfid /fabos/bin/switchshow -slot $str_slot | grep "FC" |
        while read index slot port restyy
        do
            $ECHO $slot $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
            if `correcthost_to_curr_vfid /fabos/link_bin/portcfgexport $slot/$port |
                grep -q "Admin.*enabled"` ; then
                add_err_status " * One or more port on slot $slot is configured as EX-Port."

                # due to the pipe, return is just like break from current while
                # loop.
				return $STS_ERR
            fi
        done
    	if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
    done

    # The return above exits the subshell started by the pipe
    # return here if the subshell exited early.
    if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi

	return $STS_OK
}
check_csctl() {
    if correcthost_to_curr_vfid /fabos/link_bin/portcfgshow | grep "CSCTL mode" | grep -q ON; then
        return $STS_ERR
    else
        return $STS_OK
    fi
}
locked_eport() {

	if correcthost_to_curr_vfid /fabos/link_bin/portcfgshow | grep "Locked E_Port" | grep -q ON; then
		return $STS_ERR
	fi
	return $STS_OK
}

# Check for portname length > 32bytes and prevent downgrade from 7.0
# to Pre v6.4.3 
# if any port having portname length > 32bytes.
#
check_portname_len() {
	#
	# Check portname length only if downgrading to Pre v6.4.3
	#
	if [ $TO_MAJOR -eq 6 -a $TO_MINOR -eq 4 -a $TO_PATCH -ge 3 ]; then
		return $STS_OK
	fi

	if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF enabled
		CHASSISCMD="cmd_chassis"
		for_all_contexts port_namelen
	else
		# VF disabled
		port_namelen
	fi
	if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
}

# check for Condor3 blade is present or not
check_C3_blades() {
	if `/fabos/bin/slotshow | grep -E "96|97|98|99" 1>/dev/null 2>&1`;
	then
		return $STS_ERR
	fi
	return $STS_OK
}

# check for Enhanced FC8 blade is present or not
check_ENHANCED_FC8_blades() {
	if `/fabos/bin/slotshow | grep -E "125|126" 1>/dev/null 2>&1`;
	then
		return $STS_ERR
	fi
	return $STS_OK
}

# Check for PAD feature without option/events configured
check_PAD_feature() {
	CHASSISCMD="cmd_chassis"
	for_all_contexts check_PAD_enabled
	if [ $? -eq 0 ]; then
        return $STS_OK
    else
        return $STS_ERR
    fi
}

check_PAD_enabled() {
	/fabos/sbin/portcfgautodisable fwdl_downgrade | grep "PAD" | grep enabled > /dev/null 2>&1;
	if [ $? -eq 0 ]; then
        return $STS_ERR
    else
        return $STS_OK
    fi
}

# Check for configured fillword and prevent downgrade from 6.4 if
# any port is configured as > 1 .
# 2- /-idle-arbff  - IDLE  in Link Init, ARBFF as fill word (SW)
# 3- /-aa-then-ia  - If ARBFF/ARBFF failed, then do IDLE/ARBFF
#
check_cfg_fill_word_all_instances() {

	if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF enabled
		CHASSISCMD="cmd_chassis"
		for_all_contexts check_cfg_fill_word
	else
		check_cfg_fill_word
	fi
	if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
}

port_namelen() {
	correcthost_to_curr_vfid /fabos/sbin/portname | grep "port" |
	while read -ers line
	do
		name=${line#*: }
		size=${#name}
		if [ $size -gt 32 ]; then
			return $STS_ERR
		fi
	done
	if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	return $STS_OK
}

check_cfg_fill_word() {

	if correcthost_to_curr_vfid /fabos/link_bin/portcfgshow | grep "Fill Word" | grep -q " 2 "; then
		return $STS_ERR
	fi

	if correcthost_to_curr_vfid /fabos/link_bin/portcfgshow | grep "Fill Word" | grep -q " 3 "; then
		return $STS_ERR
	fi
	return $STS_OK
}

# Check for configured 16G/10G speed  and prevent downgrade from 7.0 if
# any port is configured.
#       
check_cfg_speed() {
	if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF enabled
		CHASSISCMD="cmd_chassis"
		for_all_contexts port_speedcheck
	else
		port_speedcheck
	fi
	if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
}

port_speedcheck() {
	if correcthost_to_curr_vfid /fabos/link_bin/switchshow | awk '{ if ($8 != "FCoE") print $6;}' | grep -qi -e "10G" -e "16G"; then
		return $STS_ERR
	fi
	return $STS_OK
}

#
# fcr_enabled
#
# Check whether FCR is enabled
#
check_fcr_enabled() {

	/fabos/bin/fosconfig --show | grep "FC Routing service" | grep enabled > /dev/null 2>&1
	if [ $? -eq 0 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

#
# check_hcl_switchstate
#
# Check the switchState if it is Faulty to block HCL
#
check_hcl_switchstate()
{
	hashow_cmd="/fabos/bin/hashow"

	case "$($hashow_cmd | ( read a; echo $a ))" in
		*"Not supported"*)
		;;
		*)
		return $STS_OK
		;;
	esac

	switch_state=`/fabos/bin/switchshow | sed -n -e 's/switchState://gp' | tr -d '\t'`

	if [ "$switch_state" == "Faulty" ]; then
		is_fwdl_arg "s"
		if [ $? -ne 0 ]; then
			return $STS_ERR
		fi
	fi

	return $STS_OK

}

CMSH_DEBUG="/fabos/factory/cmsh_debug"

#
# Check if usres with user-defined roles on 7.0 switch
#
check_udrole_users_presence()
{
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -ge 0 ]; then
	if [  $TO_MAJOR -le 6 ]; then
		/fabos/libexec/userdb_convert $CUR_MAJOR.$CUR_MINOR $TO_MAJOR.$TO_MINOR $PREINST > /dev/null 2>&1
		if [ $? -ne 0 ]; then
			return $STS_ERR;
		fi
	fi
	fi


	return $STS_OK
}

#
# Check if there is any entry in certificate configuratio database
# that is configured to use third party issued certificates with
# the peer switch.
#
check_sec_auth_certificate_database()
{
    FCAP_DIR="/etc/fabos/pki/tp"
    FCAP_SWCERT_FILE="switch.0.crt"
    FCAP_CACERT_FILE="switch.0.rootcrt"
    FCAP_SWCSR_FILE="switch.0.csr"

    if ! ( [ $CUR_MAJOR -eq 7 ] && [ $CUR_MINOR -eq 0 ] && [ $TO_MAJOR -eq 6 ] && [ $TO_MINOR -eq 3 ] ); then
        MAX_NUM_SW=8
        for (( i = 0 ; i <= $MAX_NUM_SW ; i++ ))
        do
            FCAP_CONF_FILE=`echo /etc/fabos/auth.$i.fcap.conf`

            if [ -f $FCAP_CONF_FILE ]; then
                IFS_=${IFS}; IFS=$'\n'
                for LINE in `cat $FCAP_CONF_FILE`
                do
                    CONF_VAL=`echo "$LINE" | awk ' {print $2} '`
                    if [ $CONF_VAL -eq 1 ]; then
                        return $STS_ERR
                    fi
                done
                IFS=${IFS_}
            fi
        done
    fi

    if [ -s $FCAP_DIR/$FCAP_SWCERT_FILE ]; then
	    return $STS_ERR
    fi

    if [ -s $FCAP_DIR/$FCAP_CACERT_FILE ]; then
 	    return $STS_ERR
    fi

    if [ -s $FCAP_DIR/$FCAP_SWCSR_FILE ] ; then
	    return $STS_ERR
    fi

    return $STS_OK
}

#           
# Check if there is any entry in certificate configuration database
# that is configured to use Brocade issued certificates with
# the peer switch or if the Brocade issued certificate is installed
# in the switch.
#
check_sec_auth_certificate_database_for_brcd()
{
    FCAP_DIR="/etc/fabos/pki"
    FCAP_SWCERT_FILE="switch.0.crt"
    MAX_NUM_SW=8
    for (( i = 0 ; i <= $MAX_NUM_SW ; i++ ))
    do  
    FCAP_CONF_FILE=`echo /etc/fabos/auth.$i.fcap.conf`

    if [ -f $FCAP_CONF_FILE ]; then
        IFS_=${IFS}; IFS=$'\n'
		for LINE in `cat $FCAP_CONF_FILE`
		do
				CONF_VAL=`echo "$LINE" | awk ' {print $2} '`
					if [ $CONF_VAL -eq 0 ]; then
				return $STS_ERR
			fi
		done
		IFS=${IFS_}
	fi
	done

    if [ -s $FCAP_DIR/$FCAP_SWCERT_FILE ]; then
        return $STS_ERR
    fi

    return $STS_OK
}
		
#
# Check if Secondary RKM keyvault is configured
# before upgrading to v6.3,0
#
check_sec_rkm_kv()
{
	KVTYPE=`/fabos/cliexec/configshow | grep spm.encrGrp.kvType | cut -f 2 -d ':'`

	if [ -z "$KVTYPE" ]; then
		return $STS_OK;
	fi

	if [ "$KVTYPE" = "0x2" ]; then
		SECKV=`/fabos/cliexec/configshow | grep spm.encrGrp.secKV.cert.ip | cut -f 2 -d ':'`

		if [ -z "$SECKV" ]; then
			return $STS_OK;
		else
			return $STS_ERR;
		fi
	fi
	return $STS_OK;
}

#Check for Europa blade count
check_europa_blade_count_support() {
	
	EUROPA_BLADE_COUNT=`/fabos/cliexec/slotshow | grep " 74 " | wc -l`

	if [ $EUROPA_BLADE_COUNT -gt 2 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}
check_feature_state()
{
    feature=$1
    if [ `/fabos/cliexec/configshow | grep "$feature" |wc -l` -gt 0 ]; then
        state=`/fabos/cliexec/configshow | grep "$feature" | cut -d ":" -f2`
        if [ $state == "0x0" ]
        then
            return $STS_OK
        else
            return $STS_ERR
        fi
    else
        return $STS_OK
    fi
}


#
# Check if  Europa blade is power on.
#
check_if_Europa_blade_is_power_on() {
	
	EUROPA_POWER_ON=`/fabos/cliexec/slotshow | grep " 74 " | grep -v "INSERTED, NOT POWERED ON" | wc -l`

	if [ $EUROPA_POWER_ON -gt 0 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

# From Matador (7.0), seconds timebase is not supported on Fabric watch

check_fw_seconds_timebase_allinstances()
{

	if [ $VF_ENABLED -ne $STS_OK ]; then
		for_all_contexts check_fw_seconds_timebase
	else
		check_fw_seconds_timebase
	fi

}

check_fw_seconds_timebase()
{
	LISTTIMEBASE=`/fabos/cliexec/configshow | grep "thresh" | grep -F ".tb"`

	for i in $LISTTIMEBASE
	do
		SECONDSTIMEBASE=`echo $i | cut -d ":" -f 2` 

		if [ $SECONDSTIMEBASE -eq 1 ]; then
			class=`echo $i | cut -d "." -f3`
			area=`echo $i | cut -d "." -f4`
			add_err_status "$UNSUPPORTED_CHECK_SECOND_TIMEBASE1 for class $class, area $area on FID $CURRENT_VF." "$BNA_UNSUPPORTED_CHECK_SECOND_TIMEBASE1 for class $class, area $area on FID $CURRENT_VF." 
			return $STS_ERR
		fi
	done 

	return $STS_OK

}

check_veport_threshconfig_allinstances()
{

	if [ $VF_ENABLED -ne $STS_OK ]; then
	   for_all_contexts check_veport_threshconfig
	else
	   check_veport_threshconfig
	fi
}

check_veport_threshconfig()
{
	POSTDECIMAL=`/fabos/cliexec/configshow | grep "Pktloss" | cut -d "." -f 6`
	if [ -z $POSTDECIMAL ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi

}

check_flt_mon_config_allinstances()
{

   if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF is enabled
		if [ $ACTIVECP ]; then
        	for_all_contexts check_flt_mon_config
		else
			return $STS_OK
		fi
    else
        check_flt_mon_config
    fi
}

check_flt_mon_config ()
{
	# Check if fmconfig is enabled.
	# If enabled then firmwaredownload is allowed.
    fm=`/fabos/cliexec/config get perf.framemon.enabled 1`
    if [ $fm -eq 1 ]; then
        return "$STS_OK"
	else
		#
		# If not enabled then check if filter monitor configurations are
		# present.
		#
		/bin/rm -f /tmp/flt.dbg
		/fabos/link_bin/ps_dump -f > /dev/null 2>&1
	
		# If file empty then no filter monitor configurations are present.
		if [ ! -s /tmp/flt.dbg ]; then
			return "$STS_OK"
		else
			#If filter monitor configurations are present then return error.
			flt=`sed -n '/PS_VFID/,/Port/p' /tmp/flt.dbg | sed -e 's/PS_V/;/g'`
			for i in `seq 2 9`; do
				echo $flt | cut -d ';' -f $i | grep "FID $glb_vf_id" | grep Port > /dev/null
				if [ $? -eq 0 ]; then 
					return $STS_ERR
				fi
			done
		fi
	fi
	return "$STS_OK"
}
#check if buffer optimization mode is enabled
check_buf_op_enabled()
{
# this has been moved to check_features.
# leaving this here as comments for reference
: <<'COMMENT'
	icl_slots=`correcthost_to_curr_vfid /fabos/bin/slotshow -m | grep "CORE" | awk {'print $1'}`
	for slt in $icl_slots
	do
	correcthost_to_curr_vfid /fabos/sbin/bufopmode --show $slt | grep "On" > /dev/null 
	if [ $? -eq 0 ]; then 
			bufop_enabled=1
			add_err_status "Bufopmode is enabled on core blade $slt."
			return $STS_ERR        
	else    
			bufop_enabled=0
	fi      
	done
	c3_slots=`correcthost_to_curr_vfid /fabos/bin/slotshow -m | grep "FC16" | awk {'print $1'}`
	for slt in $c3_slots
	do
	correcthost_to_curr_vfid /fabos/sbin/bufopmode --show $slt | grep "On" > /dev/null 
	if [ $? -eq 0 ]; then 
			bufop_enabled=1
			add_err_status "Bufopmode is enabled on FC16 based port blade $slt."
			return $STS_ERR        
	else    
			bufop_enabled=0
	fi      
	done
	if [ $bufop_enabled -eq 1 ]; then
		return $STS_ERR        
	else
		return $STS_OK         
	fi
COMMENT
}

#check if serdes tuning mode is enabled
check_serdes_tune_enabled()
{
	if [ -f "/fabos/sbin/serdestunemode" ]; then
		/fabos/sbin/serdestunemode --show| grep "enabled" > /dev/null 2>&1

		if [ $? -eq 0 ]; then
			return $STS_ERR
		else
			return $STS_OK
		fi
	else
		return $STS_OK
	fi
}

remove_swstatus_cfg_key() {

	for  key in `/fabos/bin/configshow | grep percentage.MarginalPorts | cut -f 1 -d ':'`
	do
		/fabos/cliexec/config remove $key
	done

	for  key1 in `/fabos/bin/configshow | grep percentage.FaultyPorts | cut -f 1 -d ':'`
	do
		/fabos/cliexec/config remove $key1
	done

	for key2 in `/fabos/bin/configshow | grep percentage.MissingSFPs | cut -f 1 -d ':'`
	do
		/fabos/cliexec/config remove $key2
	done

	/fabos/cliexec/configcommit ;
}

check_swstatus_cfg_key() {
	if [ $VF_ENABLED -ne $STS_OK ]; then
		for_all_contexts remove_swstatus_cfg_key
	else
		remove_swstatus_cfg_key
	fi
}

#check if LDAP is configured over IPv6
check_ldap_ipv6_configuration()
{
        rval=$STS_OK
	if [ -f "/etc/fabos/ldap.conf" ]; then
		more /etc/fabos/ldap.conf | cut -f1 |
		while read a
		do
			echo $a | cut -f2,3 -d":" | grep -q ":"
			if test $? -eq 0
			then
				return $STS_ERR
			fi
		done;
		if [ $? -ne $STS_OK ]; then rval=$STS_ERR; fi
	fi
        return $rval
}

check_rte_policy()
{		
	dbr=`aptpolicy | grep Current | grep 2 | wc -l`
	if [ $dbr -eq 1 ]; then
		if [ $VF_ENABLED -ne $STS_OK ]; then
			add_err_status "firmware downgrade is not allowed because Device Based Routing is used in FID $CURRENT_VF."
		else
			add_err_status "firmware downgrade is not allowed because Device Based Routing is used."
		fi
		return $STS_ERR
	else
		return $STS_OK
	fi

}

check_rte_policy_in_contexts()
{
	if [ $VF_ENABLED -ne $STS_OK ]; then
		if [ $ACTIVECP ] ; then
			for_all_contexts check_rte_policy
		else
			for_all_contexts_standby check_rte_policy
		fi
	else
		check_rte_policy
	fi
}

#Checks any d_port configured as DWDM mode
check_dwdm_d_port_config()
{
	D_PORT_DWDM=/tmp/tmp_dwdm.txt
	correcthost_to_curr_vfid /fabos/link_bin/portdporttest --show all | grep "[0-9]" > $D_PORT_DWDM

	SLOT_NUM=`correcthost_to_curr_vfid /fabos/link_bin/portdporttest --show all | grep -i "slot" | wc -l`
	while read line
	do
		if [ $SLOT_NUM -eq 1 ]; then
			slot=`echo $line | grep "[0-9]" | cut -d " " -f1`
			port=`echo $line | grep "[0-9]" | cut -d " " -f2`
			PORT_NUM="$slot/$port"
		else
			PORT_NUM=`echo $line | grep "[0-9]" | cut -d " " -f1`
		fi

		dwdm=`correcthost_to_curr_vfid /fabos/link_bin/portcfgshow $PORT_NUM | grep "D-Port over DWDM" | grep "ON" | wc -l | sed 's/ //g'`

		if [ "$dwdm" == "1" ]; then
			return $STS_ERR
		fi
	done < $D_PORT_DWDM
	return $STS_OK

}

#check any dwdm mode port is configured as d_port
check_d_port_dwdm_support()
{

    if [ $VF_ENABLED -ne $STS_OK ]; then
        CHASSISCMD="cmd_chassis"
        if [ $ACTIVECP ] ; then
           for_all_contexts check_dwdm_d_port_config
        else
           for_all_contexts_standby check_dwdm_d_port_config
        fi
    else
        check_dwdm_d_port_config
    fi

    if [ $? -eq $STS_OK ]; then
        return $STS_OK
    else
        return $STS_ERR
    fi

}

# check for user wise passwdcfg support 
check_passwdcfg_support()
{
	context_switch chassis
	/fabos/cliexec/config get passwdcfg.perusercfg 5 > /dev/null 2>&1
	ret=$?
	if [ $ret -eq 0 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

#check for TACACS+ in authspec more
#DEFECT TR000421027: check if TACACS+ has configured
check_aaa_tacacs_support()
{
	if [ -s "/etc/fabos/tacplus.conf" ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
#	authspec=`/fabos/cliexec/configshow -all | grep -i authspec.mode |  cut -f 2 -d ':'`
#	if [ "${authspec}" -gt 12 ]; then
#		return $STS_ERR
#	else
#		return $STS_OK
#	fi
}

#Prevent firmware downgrade from FOS7.2 to any pre-7.2 versions, 
#if any TACACS+ secret key configured is of length <= 7
check_tacacs_secret_length_lessthan8()
{
		#obtain tac+ secret key from configshow output
		tac_secret=`/fabos/cliexec/configshow -chassis | grep tacacs.server.*.secret | cut -d ":" -f2`
		for i in $tac_secret; do
			if [ ${#i} -le 7 ]; then	
				return $STS_ERR
			fi
		done
		return $STS_OK

}

#Checks any r_rdy mode port is configured as d_port
check_r_rdy_d_port_config()
{
    local isl_ports=`correcthost_to_curr_vfid /fabos/link_bin/portcfgshow | grep "ISL R_RDY Mode" | grep "ON" | wc -l | sed 's/ //g'`
    local d_ports=`correcthost_to_curr_vfid /fabos/link_bin/portcfgshow | grep "D-Port mode" | grep "ON" | wc -l | sed 's/ //g'`

    PORT_NUM=0

    #Either no r-rdy ports or d_ports
    if [ "$isl_ports" == "0" ] || [ "$d_ports" == "0" ]; then
        return $STS_OK
    fi

    D_PORT_CONF=/tmp/tmp_dport_show_tmp.txt
    correcthost_to_curr_vfid /fabos/link_bin/portdporttest --show all | grep "[0-9]" > $D_PORT_CONF

    NEED_SLOT_NUM=`correcthost_to_curr_vfid /fabos/link_bin/portdporttest --show all |  grep -i "slot" |  wc -l`
    while read line
    do
        if [ $NEED_SLOT_NUM -eq 1 ]; then
            tempslot=`echo $line | grep "[0-9]" | cut -d " " -f1`
            tempport=`echo $line | grep "[0-9]" | cut -d " " -f2`
            PORT_NUM="$tempslot/$tempport"
        else
            PORT_NUM=`echo $line | grep "[0-9]" | cut -d " " -f1`
        fi

        isl_ports=`correcthost_to_curr_vfid /fabos/link_bin/portcfgshow $PORT_NUM | grep "ISL R_RDY Mode" | grep "ON" | wc -l | sed 's/ //g'`
        d_ports=`correcthost_to_curr_vfid /fabos/link_bin/portcfgshow $PORT_NUM | grep "D-Port mode" | grep "ON" | wc -l | sed 's/ //g'`


        if [ "$isl_ports" == "1" ] && [ "$d_ports" == "1" ]; then
            return $STS_ERR
        fi

    done < $D_PORT_CONF

    return $STS_OK

}

#check any r_rdy mode port is configured as d_port
check_d_port_r_rdy_support()
{

    if [ $VF_ENABLED -ne $STS_OK ]; then
        CHASSISCMD="cmd_chassis"
        if [ $ACTIVECP ] ; then
           for_all_contexts check_r_rdy_d_port_config
        else
           for_all_contexts_standby check_r_rdy_d_port_config
        fi
    else
        check_r_rdy_d_port_config
    fi

    if [ $? -eq $STS_OK ]; then
        rm -rf /tmp/tmp_dport_show*
        return $STS_OK
    else
        rm -rf /tmp/tmp_dport_show*
        return $STS_ERR
    fi

}

check_fcrdbg_icl_ex_port()
{
	#Get ICL slots
	if `correcthost_to_curr_vfid /fabos/cliexec/fcrdbgport_cfg_exports --icl |
		grep "enabled" 1>/dev/null 2>&1` ; then
		# return error 
		return $STS_ERR
	fi
	return $STS_OK
}

check_icl_ex_port()
{
    #Get ICL slots
    icl_slots=`/fabos/bin/slotshow -m | grep "CORE" | awk {'print $1'}`

    for slt in $icl_slots
    do
        #Get EX ports configured on ICL
        correcthost_to_curr_vfid /fabos/bin/switchshow -slot $slt | grep "FC" |
        while read index slot port restyy
        do
            $ECHO $slt $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
            if `correcthost_to_curr_vfid /fabos/bin/portcfgexport $slt/$port |
                grep -q "Admin.*enabled"` ; then

                # due to the pipe, return is just like break from current while
                # loop.
                return $STS_ERR
            fi
        done
        if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
    done
    return $STS_OK
}


#check if Ex ports are configured on ICL ports 
check_icl_ex_port_configuration()
{
	#if no ICL license present then allow firmware download
	icl_lic=`/fabos/bin/licenseshow |grep "Inter Chassis Link"`

	if [ "$icl_lic" == "" ]; then
		return $STS_OK
	fi

	ACTIVE_MAJOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Major://gp'`
	ACTIVE_MINOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Minor://gp'`
	fcrdbgport=`correcthost_to_curr_vfid ls -1 /fabos/cliexec | grep fcrdbgport_cfg_exports | wc -l`

	if [ $ACTIVE_MAJOR -ge 7 -a $ACTIVE_MINOR -ge 2 -a $fcrdbgport -ge 1 ] || 
		[ $ACTIVE_MAJOR -gt 7 ]; then
		check_fcrdbg_icl_ex_port
	else 
		if [ $VF_ENABLED -ne $STS_OK ]; then
			CHASSISCMD="cmd_chassis"
			if [ $ACTIVECP ]; then
				for_all_contexts check_icl_ex_port
			else
				# this is the standby cp, examine the configuration of the
				# active cp
				for_all_contexts_standby check_icl_ex_port
			fi
		else
			check_icl_ex_port
		fi
	fi

	if [ $? -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#check if ICL connections are within the allowed limit
check_icl_port_configuration()
{
	#if no ICL license present then allow firmware download
	icl_lic=`/fabos/bin/licenseshow |grep "Inter Chassis Link"`

	if [ "$icl_lic" == "" ]; then
		return $STS_OK
	fi


	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		for_all_contexts check_icl_limit
	else
		check_icl_limit
	fi

	if [ $? -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#check ICL connected chassis limit in fabric
check_icl_limit()
{
	sw_idx=0
	ch_idx=0
	wwn_cnt=0
	icl_cnt=0
	
	#Get ICL slots
	icl_slots=`/fabos/bin/slotshow -m | grep "CORE" | awk {'print $1'}`

	for slt in $icl_slots
	do
		#Get Switch WWN list of E-Ports
		wwn_list=`/fabos/bin/switchshow -slot $slt |grep "E-Port" | awk {'print $10'} | grep ":" | uniq | sort`

		for wwn in $wwn_list
		do
			wwn_arr[$sw_idx]=$wwn
			sw_idx=`expr $sw_idx + 1`
		done
	done

	wwn_arr_uniq="`for wwn in ${wwn_arr[@]}; do echo ${wwn}; done | sort -u`" 
	wwn_cnt=`echo $wwn_arr_uniq | wc -w`

	#Get Domain ID and Chassis WWN
	for sw_wwn in $wwn_arr_uniq
	do
		dom=`/fabos/bin/fabricshow |grep $sw_wwn | awk {'print $1'} |cut -d ':' -f 1`
		if [ "$dom" != "" ]; then
			ch_wwn[$ch_idx]=`/fabos/bin/ess show dcl $dom |grep "CS_WWN" | awk {'print $8'} |grep ":"`
			ch_idx=`expr $ch_idx + 1`
		fi
	done

	ch_wwn_uniq="`for wwn in ${ch_wwn[@]}; do echo ${wwn}; done | sort -u`" 

	#Get ICL count with each unique Chassis WWNs
	icl_cnt=`echo $ch_wwn_uniq | wc -w`

	#If no ICL license present then allow firmware download
	eicl_lic=`/fabos/bin/licenseshow |grep "Enterprise ICL license"`

	if [ "$eicl_lic" == "" ] && [ $icl_cnt -gt 3 ]; then
		return $STS_ERR
	elif [ "$eicl_lic" != "" ] && [ $icl_cnt -gt 9 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

#Checks AOQ ports have required licenses installed
check_aoq_sao_license()
{
	# For Odin platform, these checks are not applicable
	if [ ${SWBD##SWBD} == '133' ]; then
		return $STS_OK
	fi

	LICENSE_SHOW=/tmp/tmp_license_show.txt
	SLOT_SHOW=/tmp/tmp_slot_show.txt

	correcthost_to_curr_vfid /fabos/bin/licenseshow > $LICENSE_SHOW
	correcthost_to_curr_vfid /fabos/bin/slotshow -m > $SLOT_SHOW

	slot_based=`cat $SLOT_SHOW | grep "Not supported on this platform"`
	if [ "$slot_based" == "" ] ; then
		aoq_port_list=`correcthost_to_curr_vfid /fabos/bin/switchshow | grep "AoQ" | awk '{print $2"/"$3}'`
	else
		aoq_port_list=`correcthost_to_curr_vfid /fabos/bin/switchshow | grep "AoQ" | grep "[FNL]*-Port" | tr -s ' ' ' ' | cut -d ' ' -f 1-2`
	fi

	sao_license=`cat $LICENSE_SHOW | grep "Server Application Optimization"`
	aoq_license=`cat $LICENSE_SHOW | grep "Adaptive Networking"`

	#Check Adaptive Networking license if any device ports is configured as AoQ ports.
	if [ "$aoq_port_list" != "" ] ; then
		for port in $aoq_port_list
		do
			aoq_non_ag=`correcthost_to_curr_vfid /fabos/cliexec/dbgShowIsDeviceAG $port | grep "Non_AG"`

			#Check for SAO license if any AoQ enabled server or HBA's are connected
			if [ "$aoq_non_ag" != "" ]; then
				if [ "$sao_license" == "" ] && [ "$aoq_license" != "" ]  ; then
					add_err_status "$DOWNGDAOQ_SAO_REQ" "$BNA_DOWNGDAOQ_SAO_REQ"
					return $STS_ERR
				fi
				if [ "$sao_license" != "" ] && [ "$aoq_license" == "" ]  ; then
					add_err_status "$DOWNGDAOQ_AN_REQ" "$BNA_DOWNGDAOQ_AN_REQ"
					return $STS_ERR
				fi
				if [ "$aoq_license" == "" ] && [ "$sao_license" == "" ]; then
					add_err_status "$DOWNGDAOQ_AN_SAO_REQ" "$BNA_DOWNGDAOQ_AN_SAO_REQ"
					return $STS_ERR
				fi
			else
				if [ "$aoq_license" == "" ] ; then
					add_err_status "$DOWNGDAOQ_AN_REQ" "$BNA_DOWNGDAOQ_AN_REQ"
					return $STS_ERR
				fi
			fi
		done
	fi
	return $STS_OK
}

#check any AOQ enabled device ports exists
check_aoq_ports()
{

    if [ $VF_ENABLED -ne $STS_OK ]; then
        CHASSISCMD="cmd_chassis"
        if [ $ACTIVECP ] ; then
            for_all_contexts check_aoq_sao_license
        else
            for_all_contexts_standby check_aoq_sao_license
        fi
    else
        check_aoq_sao_license
    fi

    if [ $? -eq $STS_OK ]; then
        rm -rf /tmp/tmp_license_show.txt
        rm -rf /tmp/tmp_slot_show.txt
		return $STS_OK
    else
        rm -rf /tmp/tmp_license_show.txt
        rm -rf /tmp/tmp_slot_show.txt
		return $STS_ERR
    fi
}

#check any QOS enabled device ports exists
check_downgrade_qos_port_mode()
{
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ] ; then
			for_all_contexts check_downgrade_qos_mode
		else
			for_all_contexts_standby check_downgrade_qos_mode
		fi
	else
		check_downgrade_qos_mode
	fi

	retval=$?
	rm -rf /tmp/tmp_switch_show.txt
	rm -rf /tmp/tmp_slot_show.txt
	rm -rf /tmp/tmp_isl_show.txt
	rm -rf /tmp/tmp_portcfg_show.txt

	if [ $retval -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#
# This routine does the following checks.
#
# If AN and SAO license is installed then,
#   No need to block the firmware downgrade.
#
# If AN and/or SAO license is not installed,
#   Firmware downgrade will be blocked in the following cases:
#		I.      QOS mode is set to ON for any of the ports.
#		II.     CSCTL mode is set to ON for any of the ports.
#		III.    Rate Limit is set to ON for any of the ports.
#		IV.     If any E-port is using QOS feature (This can be figured out from "islshow" o/p)
#
#
# In all the disallowed cases, installing Licenses will allow the firmware downgrade
#
# The above checks are not applicable for :
#	1 . Odin platform
#	2 . ICL ports
#
check_downgrade_qos_mode()
{
	# For Odin platform, these checks are not applicable
	if [ ${SWBD##SWBD} == '133' ]; then
		return $STS_OK
	fi

	SWITCH_SHOW=/tmp/tmp_switch_show.txt
	SLOT_SHOW=/tmp/tmp_slot_show.txt
	ISL_SHOW=/tmp/tmp_isl_show.txt
	PORTCFG_SHOW=/tmp/tmp_portcfg_show.txt

	correcthost_to_curr_vfid /fabos/bin/switchshow > $SWITCH_SHOW
	correcthost_to_curr_vfid /fabos/bin/slotshow -m > $SLOT_SHOW
	correcthost_to_curr_vfid /fabos/cliexec/islshow > $ISL_SHOW
	correcthost_to_curr_vfid /fabos/cliexec/portcfgshow > $PORTCFG_SHOW

	slot_based=`cat $SLOT_SHOW | grep "Not supported on this platform"`
	qos_license=`correcthost_to_curr_vfid /fabos/bin/licenseshow | grep "Adaptive Networking"`
	e_port_index=`cat $SWITCH_SHOW | grep "E-Port" | awk '{print $1}'`

	index=0
	found=0
	
	#Check Adaptive Networking license is installed.
	if [ "$qos_license" == "" ] ; then
		#Check for slot based system
		if [ "$slot_based" == "" ] ; then
			e_port_slot=`cat $SWITCH_SHOW | grep "E-Port" | awk '{print $2}'`
			
			#Get ICL slots
			icl_slots=`cat $SLOT_SHOW | grep "CORE" | awk {'print $1'}`

			# check QOS mode is ON on any of the port(s).
			qos_mode=`cat $PORTCFG_SHOW | grep "QOS Port" | grep "ON"`
			if [ "$qos_mode" != "" ] ; then
				add_err_status "$DOWNGDQOS_AN_REQ_MSG1" "$BNA_DOWNGDQOS_AN_REQ_MSG1"
				return $STS_ERR
			fi

			# Check CSCTL mode  is ON on any the port(s).
			csctl_mode=`cat $PORTCFG_SHOW | grep "CSCTL" | grep "ON"`
			if [ "$csctl_mode" != "" ] ; then
				add_err_status "$DOWNGDCSCTL_AN_REQ" "$BNA_DOWNGDCSCTL_AN_REQ"
				return $STS_ERR
			fi
			# Check Rate Limit is set on any the port(s).
			rate_limit=`cat $PORTCFG_SHOW | grep "Rate Limit" | grep "ON"`
			if [ "$rate_limit" != "" ] ; then
				add_err_status "$DOWNGDRATELIMIT_AN_REQ" "$BNA_DOWNGDRATELIMIT_AN_REQ"
				return $STS_ERR
			fi
				
			index=0
			# extract each slot from slot list for e-ports
			for slot in $e_port_slot
			do
				e_slot_array[$index]=$slot
				index=`expr $index + 1`
			done

			index=0
			#Check whether E-port (except ICL ports) is actually running QOS feature, if so block downdgrade.
			for port in $e_port_index
			do
				# extract icl slots and compare
				for icl_slot in $icl_slots
				do
					if [ $icl_slot -eq ${e_slot_array[$index]} ] ; then
						found=1
						break
					fi
				done

				# skip icl ports from the following checks.
				if [ $found -eq 1 ] ; then
					index=`expr $index + 1`
					found=0
					continue
				fi

				qos_eport=`cat $ISL_SHOW | grep "$port->" | grep "QOS"`
				if [ "$qos_eport" != "" ] ; then
					add_err_status "$DOWNGDQOS_AN_REQ_MSG3" "$BNA_DOWNGDQOS_AN_REQ_MSG3"
					return $STS_ERR
				fi
			
				index=`expr $index + 1`
			done
		    # End of slot based system
		else
			# check QOS mode is ON on any of the port(s).
			qos_mode=`cat $PORTCFG_SHOW  | grep "QOS Port" | grep "ON"`
			if [ "$qos_mode" != "" ] ; then
				add_err_status "$DOWNGDQOS_AN_REQ_MSG1" "$BNA_DOWNGDQOS_AN_REQ_MSG1"
				return $STS_ERR
			fi
				
			# Check CSCTL mode  is ON on the port
			csctl_mode=`cat $PORTCFG_SHOW | grep "CSCTL" |  grep "ON"`
			if [ "$csctl_mode" != "" ] ; then
				add_err_status "$DOWNGDCSCTL_AN_REQ" "$BNA_DOWNGDCSCTL_AN_REQ"
				return $STS_ERR
			fi
				
			# Check Rate Limit is set on the port
			rate_limit=`cat $PORTCFG_SHOW | grep "Rate Limit" | grep "ON"`
			if [ "$rate_limit" != "" ] ; then
				add_err_status "$DOWNGDRATELIMIT_AN_REQ" "$BNA_DOWNGDRATELIMIT_AN_REQ"
				return $STS_ERR
			fi

			#Check whether E-port is actually running QOS feature, if so block downdgrade.
			for port in $e_port_index
			do
				qos_eport=`cat $ISL_SHOW | grep "$port->" | grep "QOS"`
				if [ "$qos_eport" != "" ] ; then
					add_err_status "$DOWNGDQOS_AN_REQ_MSG3" "$BNA_DOWNGDQOS_AN_REQ_MSG3"
					return $STS_ERR
				fi
			done
		fi
	fi
}
		

#This routine display warning message about the changes in default QoS mode configuration from AE to OFF.
#actual implementation is done in post-install script.
display_default_qosmode_warning_msg ()
{
	#For Odin platform, these checks are not applicable
	if [ ${SWBD##SWBD} == '133' ]; then
		return $STS_OK 
	fi
	qos_license=`/fabos/bin/licenseshow | grep "Adaptive Networking"`
	if [ "$qos_license" == "" ] ; then
		echo -e "\n$DEFAULT_QOS_WARN_MSG\n"
		echo -e "$BNA_DEFAULT_QOS_WARN_MSG" >> $BNA_STATUS_FILE
	fi
}




#check any port other than the first octet of a blade/switch is configured for 10G/N10 speed.
check_10g_port_other_than_first_octet()
{
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ] ; then
    		for_all_contexts check_10g_speed_port_other_than_first_octet
		else
            for_all_contexts_standby check_10g_speed_port_other_than_first_octet
        fi
    else
        check_10g_speed_port_other_than_first_octet
    fi

    if [ $? -eq $STS_OK ]; then
        return $STS_OK
    else
        return $STS_ERR
    fi
}

# This routine will check any port other the first 8 ports of a
# blade (or) pizzabox has N10/10G speed configured. If so,
# downgrade will be blocked. 
check_10g_speed_port_other_than_first_octet()
{
    slot_based=`correcthost_to_curr_vfid /fabos/bin/slotshow | grep "Not supported on this platform"`
    index=0 
                
        #Check for slot based system
        if [ "$slot_based" == "" ] ; then
            slot_list=`correcthost_to_curr_vfid /fabos/bin/switchshow | grep " FC " | awk '{print $2}'`
            port_list=`correcthost_to_curr_vfid /fabos/bin/switchshow | grep " FC " | awk '{print $3}'`
                    
            # Extract each slot from slot list
            for slot in $slot_list
            do
                slot_array[$index]=$slot
                index=`expr $index + 1`
            done

			# Loop from port 8 in every slot 
            index=0
            # check Octet Speed Combo on each ports
            for port in $port_list
            do
                oct_mode=`correcthost_to_curr_vfid /fabos/cliexec/portcfgshow ${slot_array[$index]}/$port | grep "Octet" | awk '{print $4}'`
				if [ "$port" -gt 7 ] ; then
                	if [ "$oct_mode" == "2(10G|8G|4G|2G)" ] ; then
                    	return $STS_ERR
                	fi
					if [ "$oct_mode" == "3(16G|10G)" ] ; then
						return $STS_ERR
					fi
				fi
                index=`expr $index + 1`
            done

        else
            port_list=`correcthost_to_curr_vfid /fabos/bin/switchshow | grep " FC " | awk '{print $1}'`
			# Loop from port 8 of the switch.
            for port in $port_list
            do
				if [ "$port" -lt 8 ] ; then
					continue
				fi
                oct_mode=`correcthost_to_curr_vfid /fabos/cliexec/portcfgshow $port | grep "Octet" | awk '{print $4}'`
                if [ "$oct_mode" == "2(10G|8G|4G|2G)" ] ; then
                    return $STS_ERR
                fi
				if [ "$oct_mode" == "3(16G|10G)" ] ; then
					return $STS_ERR
				fi
            done

        fi
}

# This routine checks whether any of the 7.1 software
# features are active
check_71_sw_features()
{
	$ECHO check_71_sw_features

	TEST check_passwdcfg_support "$CHECK_PASSWDCFG_SUPPORT"

	TEST check_aaa_tacacs_support "$CHECK_AAA_TAC_SUPPORT"

	TEST check_auth_switch_policy "$UNSUPPORTED_AUTH_SWITCH_POLICY"

	TEST check_fms_lossless_xisl "$FMS_LOSSLESS_XISL_CHECK_ERROR"

	TEST check_switch_enforced_login "$UNSUPPORTED_SWITCH_ENFORCED_LOGIN"

	TEST check_ag_dport_configuration "$REMOVE_DPORT_CONFIGURATION"

	TEST check_d_port_icl_support "$D_PORT_ICL_NOT_SUPPORTED"

	TEST check_for_CR_FPorts_enabled "$CR_ACTIVE" 2> ${NULL}

	TEST check_for_FEC_FPorts_enabled "$FEC_ACTIVE" 2> ${NULL}

	TEST check_CR_configuration "$REMOVE_CREDITRECOVERY_CONFIGURATION"
	
	TEST check_for_auto_csctl_enabled "$AUTO_CSCTL_ACTIVE"

	TEST check_FEC_configuration "$REMOVE_FEC_CONFIGURATION"

	TEST check_LOLA_in_contexts "$LOCATION_ID_CONFIGURED" "$BNA_LOCATION_ID_CONFIGURED"

	TEST check_for_spike_vf "$SPIKE_VF_ENABLED" "$BNA_SPIKE_VF_ENABLED"


	# Block downgrade if EX-port isconfigured for Encryption/Compression
	# Block downgrade to lower versions if more than 2 ports per chip are
	# configured with encryption and compression.
	check_enc_comp_fwdl 2> ${NULL}
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		RET_CODE=$OVERALL_STS
	fi
			
	return $RET_CODE
}

# Return value for the portcfg_eport_credit. It contains the port numbers
# in slot/port format. The E-Port Credit configuration is enabled on these
# ports
# This routine checks whether any of the 7.2 software
# features are active
check_72_sw_features()
{
    $ECHO check_72_sw_features

	# TEST check_buf_op_enabled "$BUFOPMODE_ENABLED" "$BNA_BUFOPMODE_ENABLED"
	TEST check_xfcip_features "$XFCIP_FEATURE_RESTRICTION" "$BNA_XFCIP_FEATURE_RESTRICTION"
	TEST check_Trunk_configuration "$ENABLE_TRUNK_CONFIGURATION"
  	TEST check_aoq_ports
 	TEST check_downgrade_qos_port_mode
	TEST check_flow_on_all_partitions "$FLOW_MANAGER_CONFIGURED"
	TEST check_10g_port_other_than_first_octet "$SPEED_10G_PRESENT_ERROR" "$BNA_10G_SPEED_PRESENT_ERROR"
	TEST check_tacacs_secret_length_lessthan8 "$TACACS_LEN_ERROR_MSG"	
        TEST check_authutil_allhash "$AUTHUTIL_CONFIGURATION_HASHSET"
	check_portcfg_eport_credit 2> ${NULL}
	OVERALL_STS=$?

	if [ $OVERALL_STS != $STS_OK ]; then
		$ECHO "failed"
		RET_CODE=$OVERALL_STS
		if [ $OVERALL_STS == $STS_ERR ]; then
			add_err_status "$EPORT_CREDIT_FWDL_RESTRICTION"
		fi
	fi
	TEST check_for_maps_enabled "$MAPS_ENABLED" "$BNA_MAPS_ENABLED"
	TEST check_sim_port_enabled "$SIM_PORT_ENABLED"

    return $RET_CODE
}

#
# Check for VF enabled Spike Platform
#
check_for_spike_vf() {

	if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF enabled
		case ${SWBD##SWBD} in '83')
			return $STS_ERR
		;;
		*)
			return $STS_OK
		;;
		esac
	else
		# VF disabled
		return $STS_OK
	fi
}
#
# maps_enabled_check
#
# Check whether the switch is currently in auto csctl mode
#
maps_enabled_check() {
    # on active cp we need diffrent command than the stand by. dont know the reason why?
    if [ $ACTIVECP ]; then
	ret=`/fabos/cliexec/configshow -chassis | grep maps.migrated:1 |wc -l`
	# need to truncate all the leading blank characters 
	last=`echo $ret | tr -d ' '`
    else
	cmd="CHASSIS_ROLEID=0 CURRENT_VF=255 /fabos/cliexec/configshow -chassis | grep maps.migrated:1 | wc -l"
	ret=`correcthost  $cmd`;
	# ret will have command plus the result so we just need result. result will be 
	# either zero or 1 so we just need last character from the end
	last=${ret: -1:1}
    fi
    # this is check for debugging 
    #if  [ $last -eq 1 ]; then
	#echo "1: maps is enabled $last"
    #else
	#echo "1: maps is disabled $last"
    #fi
    # return the status
    return $last
}

#check for csctl auto mode 
check_for_maps_enabled()
{
    maps_enabled_check
    if [ $? -gt 0 ]; then
	echo $MAPS_ACTIVE > /tmp/maps.err.log
	echo -e "\n$MAPS_ACTIVE\n"
    fi

    # delete this file. -f is to ignore the warning if it does not exist
    # the reason of this delete is to make sure if user tries to downgrade
    # and abort the downgrade process.
    # later on try to upgrade or downgrade then pre-install evaluate again
    # and create new file if needed.

    rm -f /tmp/maps.err.log
    return $STS_OK
}

#check for csctl auto mode 
check_for_auto_csctl_enabled()
{

	auto_csctl_enabled
	if [ $? -gt 0 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

#check for any D port is configured
check_ag_dport_configuration()
{
	ag_mode_enabled
	if [ $? -gt 0 ]; then
		 dport=`/fabos/bin/switchshow | grep -c "D-Port"`
			if [ $dport -gt 0 ]; then
				return $STS_ERR
			else
				return $STS_OK 	
			fi
	else
		return $STS_OK
	fi
}

#check any icl port is configured as d_port in the switch.
check_d_port_icl_support()
{

	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ] ; then
			for_all_contexts check_icl_d_port_config
		else
			for_all_contexts_standby check_icl_d_port_config
		fi
	else
		check_icl_d_port_config
	fi

	if [ $? -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi

}

#Checks if there is any icl port per VF/switch is configured as d_port.
check_icl_d_port_config()
{
	local icl_slots=`correcthost_to_curr_vfid /fabos/bin/slotshow -m | grep "CORE" | awk {'print $1'}`

	for slt in $icl_slots
	do
		i=`correcthost_to_curr_vfid /fabos/bin/switchshow -slot $slt | grep D-Port|wc -l`
		if [ $i -ge 1 ]; then
			return $STS_ERR
		fi
	done
	return $STS_OK
}

#Check for CR feature enabled in AG mode
check_CR_configuration()
{
	ag_mode_enabled
	if [ $? -gt 0 ]; then
		port_list=`/fabos/bin/switchshow | grep " FC " | awk '{print $4}'`
		index=0
		for port in $port_list
			do
			if [ $port == "cu" ] ; then
				index=`expr $index + 1`
				continue;
			fi
			CR=`/fabos/link_bin/portcfgshow $index | grep "Credit Recovery" | awk '{print $3}'`
			if [ "$CR" == "ON" ]; then
				return $STS_ERR
			fi
			index=`expr $index + 1`
		done	
		return $STS_OK
	else 
		return $STS_OK
	fi
}

#Check for FEC feature enabled in AG mode
check_FEC_configuration()
{
    ag_mode_enabled
    if [ $? -gt 0 ]; then
		port_list=`/fabos/bin/switchshow | grep " FC " | awk '{print $4}'`
		index=0
		for port in $port_list
			do
			if [ $port == "cu" ] ; then
				index=`expr $index + 1`
				continue;
			fi
        	fec=`/fabos/link_bin/portcfgshow $index | grep "FEC" | awk '{print $2}'`
	        if [ "$fec" == "ON" ]; then
    	        return $STS_ERR
				
			fi
			index=`expr $index + 1`
		done
		return $STS_OK
        else
            return $STS_OK
        fi
}
 
# This routine checks whether any of the 7.0.1 software
# features are active
check_70_1_sw_features()
{

	$ECHO check_70_1_sw_features

	TEST check_rte_policy_in_contexts "$UNSUPPORTED_DBR_ON_DOWNGRADE" "$BNA_UNSUPPORTED_DBR_ON_DOWNGRADE"
	TEST check_d_port_r_rdy_support "$D_PORT_R_RDY_NOT_SUPPORTED" "$BNA_D_PORT_R_RDY_NOT_SUPPORTED"
	TEST check_d_port_dwdm_support "$D_PORT_DWDM_NOT_SUPPORTED" "$BNA_D_PORT_DWDM_NOT_SUPPORTED"
	#
	# Block downgrade if Ex-Port configured in NOS mode.
	# Though the NOS IM5 mode feaure is supported only from 7.0.1 (toro), we
	# are using this function to handle all the downgrade versions.
	#
	TEST check_nos_ex_ports "$NOS_EX_PORT_RESTRICTION" "$BNA_NOS_EX_PORT_RESTRICTION"

	return $RET_CODE
}

# Check all logical switches to see if
#   1. both Lossless and XISL are enabled. 
#   2. both FMS and XISL use are enabled.
# In either of the two cases, downgrade from 7.1.x (and above) to 7.0.x 
# and below is not allowed. 
check_fms_lossless_xisl() {

	if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF enabled
	    CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ] ; then
	        for_all_contexts check_ctxt_fms_lossless_xisl
		else
			for_all_contexts_standby check_ctxt_fms_lossless_xisl
		fi
	fi
}

fspf_location_id=" "
fspf_location_conf=0
# This routine checks whether LOLA is configured
check_LOLA_configuration(){
	# first check location Id key exists or not
	correcthost_to_curr_vfid /fabos/cliexec/configshow | grep -q route.locationid

	if [ $? -eq $STS_OK ]; then
		local tmp_loc_id=`correcthost_to_curr_vfid /fabos/cliexec/configshow | grep route.locationid`
		local loc_id=${tmp_loc_id//[^0-9]}

		if [ "$loc_id" != "0" ]; then
			fspf_location_conf=1
			if [ "$fspf_location_id" == " " ]; then
				fspf_location_id="$fspf_location_id $CURRENT_VF"
			else
				fspf_location_id="$fspf_location_id, $CURRENT_VF"
			fi
		fi
	fi

	# pos argument $1 maintains the number of VFs available in a switch
	eval part='$'$1 ; part=`expr $part - 1`; eval $1=$part
	# after determining Loction ID for all VFs return Error
	if [ "$part" == "0" ] && [ "$fspf_location_conf" == "1" ]; then
		add_err_status " * WARNING!!! A Location ID is configured on the following FID(s):$fspf_location_id"
		return $STS_ERR
	fi

	return $STS_OK
}

# Wrapper routine which checks whether LOLA is configured or not
check_LOLA_in_contexts() {
	partitions=`ls -l /proc/fabos/switch | grep -v total | wc -l`
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ]; then
			for_all_contexts check_LOLA_configuration partitions
		else
			for_all_contexts_standby check_LOLA_configuration partitions
		fi
	else
		check_LOLA_configuration partitions
	fi

	if [ $? -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

check_ctxt_fms_lossless_xisl()
{
	XISL_use=`/fabos/cliexec/config get switch.xisluse 2`
	fms=`/fabos/cliexec/config get ficu.fmsmode 2`
	lossless=`/fabos/cliexec/config get route.lossless 2` ;
	if [ "${XISL_use}" -eq 1 ] && [ $lossless -eq 1 ] && [ $fms -eq 1 ]; then
		#FMS, Lossless and XISL use are all enabled. Downgrade from 7.1.x (and above) to 7.0 is not allowed.
		add_err_status "firmware downgrade from 7.1.x (and above) to 7.0.x (and below) is not allowed because FMS, Lossless and XISL use are enabled in FID $CURRENT_VF. Please disable XISL use before downgrading."
		return $STS_ERR
	elif [ "${XISL_use}" -eq 1 ] && [ $lossless -eq 1 ]; then
		#Lossless and XISL use are both enabled. Downgrade from 7.1.x (and above) to 7.0 is not allowed.
		add_err_status "firmware downgrade from 7.1.x (and above) to 7.0.x (and below) is not allowed because Lossless and XISL use are both enabled in FID $CURRENT_VF. Please disable either of them before downgrading."
		return $STS_ERR
	elif [ "${XISL_use}" -eq 1 ] && [ $fms -eq 1 ]; then
		#FMS and XISL use are both enabled. Downgrade from 7.1.x (and above) to 7.0 is not allowed.
		add_err_status "firmware downgrade from 7.1.x (and above) to 7.0.x (and below) is not allowed because FMS and XISL use are both enabled in FID $CURRENT_VF. Please disable either of them before downgrading."
		return $STS_ERR
	fi
	return $STS_OK;
}


# This routine checks whether any of the 7.0 software
# features are active
#

check_70_sw_features()
{
	$ECHO check_70_sw_features
	TEST check_portname_len "$PORTNAME_LEN_DISALLOWED_MSG" "$BNA_PORTNAME_LEN_DISALLOWED_MSG"

	TEST check_PAD_feature "$PAD_FEATURE_CHECK_MSG" "$BNA_PAD_FEATURE_CHECK_MSG"

	TEST check_ag_staticfports "$UNSUPPORTED_STATICFPORTS_CONFIG_ON_DOWNGRADE" "$BNA_UNSUPPORTED_STATICFPORTS_CONFIG_ON_DOWNGRADE"
    
 	TEST check_ag_eemon_installed "$UNSUPPORTED_EEMON_ON_DOWNGRADE" "$BNA_UNSUPPORTED_EEMON_ON_DOWNGRADE"

	TEST check_ag_fmon_installed "$UNSUPPORTED_FMON_ON_DOWNGRADE" "$BNA_UNSUPPORTED_FMON_ON_DOWNGRADE"

	TEST check_enhanced_licenses_installed "$UNSUPPORTED_LICENSES_ON_DOWNGRADE" "$BNA_UNSUPPORTED_LICENSES_ON_DOWNGRADE"

	TEST check_udrole_users_presence "$UDROLE_FWDL_DISALLOWED_MSG" "$BNA_UDROLE_FWDL_DISALLOWED_MSG"

	TEST check_multi_email_set_allinstances  "$UNSUPPORTED_MULTIPLE_EMAIL_FW_ALERT" "$BNA_UNSUPPORTED_MULTIPLE_EMAIL_FW_ALERT"

	TEST check_veport_threshconfig_allinstances "${UNSUPPORTED_VEPORT_THRESHOLD_CONFIG}" "${BNA_UNSUPPORTED_VEPORT_THRESHOLD_CONFIG}"

	TEST check_ldap_ipv6_configuration "$CHECK_LDAP_CONFIGURED_OVER_IPv6" "$BNA_CHECK_LDAP_CONFIGURED_OVER_IPv6"

	TEST check_ipfilter_forward_rule "$UNSUPPORTED_IPFILTER_POLICY" "$BNA_UNSUPPORTED_IPFILTER_POLICY"

	TEST check_tstimezone_with_three_sections_allinstances "$UNSUPPORTED_TSTIMEZONE" "$BNA_UNSUPPORTED_TSTIMEZONE"

	TEST check_for_vpwwns_configuration "$VPWWN_CONFIGURED" "$BNA_VPWWN_CONFIGURED"

	#TEST check_cfg_speed "$PORTSPEED_DISALLOWED_MSG" "$BNA_PORTSPEED_DISALLOWED_MSG"

	# Check for VE as XISL 
	TEST check_for_ve_xisl_configuration "$VE_AS_XISL_CONFIGURED" "$BNA_VE_AS_XISL_CONFIGURED"

	# Check for FCIP ports in a LS with XISL Use enabled
	TEST check_for_fcip_using_xisl_configuration "$FCIP_LS_WITH_XISL_ON" "$BNA_FCIP_LS_WITH_XISL_ON"

	#
	#Delete new config key of Marginal,Faulty, Missing SFPs component
	#of switchstatuspolicy
	#
	check_swstatus_cfg_key
	#
	# Block downgrade if Ex-Port configured in NOS mode.
	# Though the NOS IM5 mode feaure is supported only from 7.0.1 (toro), we
	# are using this function to handle all the downgrade versions.
	#
	TEST check_nos_ex_ports "$NOS_EX_PORT_RESTRICTION" "$BNA_NOS_EX_PORT_RESTRICTION"

	# Block downgrade if 7.0.1 feature is enabled
	TEST check_rte_policy_in_contexts "$UNSUPPORTED_DBR_ON_DOWNGRADE" "$BNA_UNSUPPORTED_DBR_ON_DOWNGRADE"

	# 7.0.1 sw features (needs to be checked while downgrading.)
	TEST check_d_port_r_rdy_support "$D_PORT_R_RDY_NOT_SUPPORTED" "$BNA_D_PORT_R_RDY_NOT_SUPPORTED"
	TEST check_d_port_dwdm_support "$D_PORT_DWDM_NOT_SUPPORTED" "$BNA_D_PORT_DWDM_NOT_SUPPORTED"	

	return $RET_CODE
}

# Block downgrade from 7.0.1 to pre-7.0.1 in Dcx+ and Pluto+ when
# FC8-16 or FC8-32 or FC8-48 is present
check_FC8_blades_dcx_pluto_plus() {

	ret=$STS_OK
	if [ ${SWBD##SWBD} == '62' ] || [ ${SWBD##SWBD} == '77' ]; then
		check_C3_blades
		if [ $? -ne $STS_OK ]; then
			if `/fabos/bin/slotshow | grep "SW BLADE" | grep -E "37|55|51" 1>/dev/null 2>&1`; then
				ret=$STS_ERR
			fi
		fi
	fi

	return $ret
}


# This routine checks whether any of the 7.0 hardware
# is present
#

check_70_hw_features()
{
	$ECHO check_70_hw_features

	TEST check_C3_blades "$CONDOR3_BLADE_IS_PRESENT" "$BNA_CONDOR3_BLADE_IS_PRESENT"

	TEST check_FC8_blades_dcx_pluto_plus "$FC8_BLADE_IS_PRESENT" "$BNA_FC8_BLADE_IS_PRESENT"

	TEST check_max_zone_size_in_contexts "$UNSUPPORTED_ZONE_SIZE" "$BNA_UNSUPPORTED_ZONE_SIZE"

	return $RET_CODE
}

check_enhanced_fc8_present()
{
	$ECHO check_enhanced_fc8_present

	if [ $TO_MAJOR -eq 7 -a $TO_MINOR -eq 0 -a $TO_PATCH -eq 0 ]; then
		TEST check_ENHANCED_FC8_blades "$ENHANCED_FC8_BLADE_IS_PRESENT" "$BNA_ENHANCED_FC8_BLADE_IS_PRESENT"
		return $RET_CODE
	fi
	
	return $STS_OK
}

# check the platforms supported by Edison
check_platforms_supported_by_edison()
{
	ret=0
	case ${SWBD##SWBD} in
		'62' | '77' | '83'| '76')
			ret=$STS_OK
		;;
		*)
			ret=$STS_ERR
		;;
	esac
	return $ret
}

# check switch authentication policy to upgrade to v7.1 with AG mode enabled
check_auth_switch_policy()
{
	ag_mode=$(correcthost /fabos/link_bin/switchshow | grep -c "Access Gateway Mode")

	if [ $ag_mode -eq 1 ]; then
		auth_sw_policy=`/fabos/cliexec/config get auth.policy 2`;
		if [ $auth_sw_policy -eq 0 -o $auth_sw_policy -eq 1 -o $auth_sw_policy -eq 2 ]; then
			return $STS_ERR
		fi

	fi

	return $STS_OK
}

#Check for Trunking feature enabled in AG mode
check_Trunk_configuration()
{
    ag_mode_enabled
    if [ $? -gt 0 ]; then
		port_list=`/fabos/bin/switchshow | grep " FC " | awk '{print $4}'`
		index=0
		for port in $port_list
			do
			if [ $port == "cu" ] ; then
			    index=`expr $index + 1`
			    continue;
			fi
			Trunk=`/fabos/link_bin/portcfgshow $index | grep "Trunk Port" | awk '{print $3}'`
			if [ "$Trunk" == "OFF" ] ; then
				return $STS_ERR
			fi
			index=`expr $index + 1`
		done
		return $STS_OK	
	else 
		return $STS_OK
	fi
	
}

# check if enforce login is configured to 2, if so return err.
check_switch_enforced_login()
{
	if correcthost_all_vfs /fabos/cliexec/config get switch.login.enforce_login 2 | grep 2 > /dev/null 2>&1; then
		return $STS_ERR
	fi
	return $STS_OK
}

#
# This routine checks whether there are any features or conditions
# to be handled when upgrading
#
check_pre71_sw_features()
{
	$ECHO check_pre71_sw_features
	
	# Added warning message when trapEnterpriseFlag is 0 and sysObjID is other than
	# default sysObjID
	check_snmp_trapEnterpriseFlag

	TEST check_icl_port_configuration "$UNSUPPORTED_ICL_PORT_CONFIGURATION" "$BNA_UNSUPPORTED_ICL_PORT_CONFIGURATION"

	if [ $CUR_MAJOR -lt 7 ]; then
			TEST check_interop_in_contexts "$UNSUPPORTED_INTEROP_MODE" "$BNA_UNSUPPORTED_INTEROP_MODE"
    
			TEST check_multi_fwconfigure_change "$UNSUPPORTED_FWCONFIGURE2" "$BNA_UNSUPPORTED_FWCONFIGURE2"
	
			TEST fcfw_configured "$FCFW_NOT_SUPPORTED" "$BNA_FCFW_NOT_SUPPORTED"

			TEST bstr_configured "$BSTR_NOT_SUPPORTED" "$BNA_BSTR_NOT_SUPPORTED"
			
			TEST check_rrdy_mode_in_contexts "$UNSUPPORTED_RRDY_BASE_SWITCH" "$BNA_UNSUPPORTED_RRDY_BASE_SWITCH"
			#
			# Block if any FW element timebase is configured to seconds
			#

			TEST check_fw_seconds_timebase_allinstances "$UNSUPPORTED_CHECK_SECOND_TIMEBASE2" "$BNA_UNSUPPORTED_CHECK_SECOND_TIMEBASE2"

			TEST check_ioddelay_set_in_contexts "$UNSUPPORTED_IODDELAY_ON_UPGRADE" "$BNA_UNSUPPORTED_IODDELAY_ON_UPGRADE"

			TEST check_dupe_wwpn_in_contexts "$UNSUPPORTED_DUP_PORT_WWN" "$BNA_UNSUPPORTED_DUP_PORT_WWN"
	fi	

	return $RET_CODE
}

#check the top talker config key and remove it
check_tt_config_key()
{
    /fabos/cliexec/configshow -all | grep -q "perf.ToptalkerEnabledonC2"

    if [ $? -eq 0 ]; then
    /fabos/cliexec/config remove "perf.ToptalkerEnabledonC2"
    /fabos/cliexec/configcommit
    fi
	return $STS_OK
}

#
# Display duplicate WWPN warning message
# when upgrading to 7.0
#
display_dupe_wwpn_warning_msg()
{
	NSSHOW=/tmp/ns_show.txt
	/fabos/link_bin/nsshow > $NSSHOW
	/fabos/link_bin/nscamshow >> $NSSHOW
	SORTED_FILE=/tmp/ns_sort.txt
	UNIQUE_FILE=/tmp/ns_uniq.txt
	PID_FILE=/tmp/ns_pid_wwn.txt
	DUP_WWN=/tmp/ns_dup_wwn.txt

	grep "[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F];" $NSSHOW | gawk -F';' '{ print $3 }' | sort > $SORTED_FILE
	uniq $SORTED_FILE > $UNIQUE_FILE
	if [ `cat $SORTED_FILE|wc -l` -ne `cat $UNIQUE_FILE|wc -l` ]; then
		echo "Duplicate PortWWN Present in the Fabric"
		grep "[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F];" $NSSHOW | gawk -F';' '{ print $3 "    "$1}' | gawk '{ print $1, $3 }' > $PID_FILE
		uniq -d $SORTED_FILE > $DUP_WWN
		BAKIFS=$IFS
		IFS=$(echo -en "\n\b")
			exec 3<&0
			exec 0<"$DUP_WWN"
			while read -r line
			do
				grep $line $PID_FILE
			done
			exec 0<&3
		IFS=$BAKIFS

		return $STS_ERR
	fi 
        
	return $STS_OK
}

#check if duplicate PWWN exists in all contexts
check_dupe_wwpn_in_contexts() {

	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		for_all_contexts display_dupe_wwpn_warning_msg
	else
		display_dupe_wwpn_warning_msg
	fi

	if [ $? -eq $STS_OK ]; then
		rm -f /tmp/ns*
		return $STS_OK
	else
		rm -f /tmp/ns*
		return $STS_ERR
	fi

}

check_duplicate_switch_name() {
	ret=$STS_OK
	/bin/rm -f $FWDL_PREINST_SWITCHNAME

	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		correcthost_all_vfs /fabos/bin/switchname >> $FWDL_PREINST_SWITCHNAME
	else
		# Since there is no VF, Return to caller.
		return $STS_OK
	fi

	dup=`/bin/cat $FWDL_PREINST_SWITCHNAME | /bin/sort | /usr/bin/uniq -d | /usr/bin/wc -l`
	if [ $dup -ne 0 ]; then
		ret=$STS_ERR
	fi

	/bin/rm -f $FWDL_PREINST_SWITCHNAME
	return $ret
}

check_fips_mode() {
	if /fabos/abin/fipscfg --show | grep "FIPS mode" | grep Enabled > /dev/null 2>&1 ;then
		return 1
	fi
}

check_authutil_allhash() {

	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		# VF is enabled
		if [ $ACTIVECP ] ; then
			for_all_contexts check_authutil_hashset $@
		else
			# this is the standby cp 
			for_all_contexts_standby check_authutil_hashset $@
		fi
	else
		check_authutil_hashset $@
	fi
	if [ $? -eq 0 ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}


check_authutil_hashset() {
	ret=$STS_OK

	if /fabos/sbin/authutil --show | grep "sha256" > /dev/null  2>&1 ;then
		ret=$STS_ERR	
	fi
	return $ret
}

#
# This is upgrade to 7.2 case
#

handle_to_72()
{
	$ECHO handle_to_72

	#
	# We don't allow 6.4 and previous to upgrade to this version
	#
	if [ $CUR_MAJOR -eq 6 -a $CUR_MINOR -le 4 -o $CUR_MAJOR -lt 6 ]; then
		add_err_status "$UNSUPPORTED_UP_VERMSG" "$BNA_UNSUPPORTED_UP_VERMSG"
		return $STS_ERR
	fi

	#
	# We don't allow upgrade from 7.1 and 7.0 to 7.2.1 when FIPS mode is enabled
	#
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 1 ] ||
		[ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 0 ]; then
		check_fips_mode
		if [ $? -eq 1 ]; then
			add_err_status "$FIPS_ENABLED" "$BNA_FIPS_ENABLED"
			return $STS_ERR
		fi
	fi

	#
	# Allow only disruptive Firmware download from 7.0
	#

	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 0 ]; then
		#check if it is not an embedded platfrom SH3 or Pharos or Dragon2T
		if [ ${SWBD##SWBD} != '130' ] && [ ${SWBD##SWBD} != '125' ] && [ ${SWBD##SWBD} != '117' ]; then
			allow_disruptive_single_mode_fwdl
			if [ $? -ne $STS_OK ]; then
				add_err_status "$UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL" "$BNA_UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL"
				return $STS_ERR
			fi
		fi	
		# check pre ElDorado features are present when upgrade from v7.0 to v7.2.
		check_pre_71_hw_features
		check_pre71_sw_features
		#
		# Block Upgrade if Ex-Port configured in McDATA mode.
		# The IM1, IM2 and IM3 modes are removed from Eldorado release.
		#
		TEST check_ex_ports_IM "$McDATA_EX_PORT_RESTRICTION" "$BNA_McDATA_EX_PORT_RESTRICTION"
		TEST check_vex_ports_IM "$McDATA_EX_PORT_RESTRICTION" "$BNA_McDATA_EX_PORT_RESTRICTION"
	fi

    if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -lt 1 ] || [ $CUR_MAJOR -le 6 ]; then
        TEST check_duplicate_switch_name "$DUPLICATE_SWITCHNAME"
    fi

	# From 7.2.0 3DES, AES192, AES256 are not supported. So if any user is configured with such protocols
	# then firmware upgrade to 7.2.0 has to be blocked.
	TEST check_snmp_priv_protocol "$UNSUPPORTED_SNMP_PRIVPROTOCOL" "$BNA_UNSUPPORTED_SNMP_PRIVPROTOCOL"

    #
    # to display warning msg about changes in default qos port configuration
    #
    if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -lt 2 ]; then
        display_default_qosmode_warning_msg
    fi


    if [ $CUR_MAJOR -ge 7 -a $CUR_MINOR -ge 2 -a $CUR_PATCH -ge 1 -a $TO_PATCH -lt 1 ]; then
	TEST check_authutil_allhash "$AUTHUTIL_CONFIGURATION_HASHSET"
	OVERALL_STS=$?
        if [ $OVERALL_STS != $STS_OK ]; then
            return $OVERALL_STS
	fi
    fi

	return $RET_CODE
}


#
# This is downgrade to 7.1 case
#
handle_to_71()
{
	$ECHO handle_to_71

	#
	# check pre ElDorado features present.
	#
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -lt 1 ] || [ $CUR_MAJOR -eq 6 ]; then
		check_pre_71_hw_features
		check_pre71_sw_features
	fi	
	# Block downgrade if Ex port configured on ICLs
	TEST check_icl_ex_port_configuration  "$EX_PORT_ICL_NOT_SUPPORTED"
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi

	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -lt 1 ] || [ $CUR_MAJOR -eq 6 ]; then
		#
		# Block Upgrade 7.0 -> 7.1 if Ex-Port configured in McDATA mode.
		# The IM1, IM2 and IM3 modes are removed from Eldorado release.
		#
		TEST check_ex_ports_IM "$McDATA_EX_PORT_RESTRICTION" "$BNA_McDATA_EX_PORT_RESTRICTION"
		TEST check_vex_ports_IM "$McDATA_EX_PORT_RESTRICTION" "$BNA_McDATA_EX_PORT_RESTRICTION"
	fi

	#
    # Block 7.2 -> 7.1 if 7.2 feature is enabled
    #
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 2 ]; then
		check_72_sw_features
	fi

    OVERALL_STS=$?
    if [ $OVERALL_STS != $STS_OK ]; then
        return $OVERALL_STS
    fi

	return $RET_CODE

	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi

	return $STS_OK
}

#
# This is upgrade to 7.0 case
#
handle_to_70()
{
	$ECHO handle_to_70
	#
	# Allow only disruptive download to 7.0
	#
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 2 ]; then
		allow_disruptive_single_mode_fwdl
		if [ $? -ne $STS_OK ]; then
			add_err_status "$UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL" "$BNA_UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL"
			return $STS_ERR
		fi
	fi

	#
	# Block for 7.0.1 -> 7.0.0 for Tom-2
	#
	if [ ${SWBD##SWBD} == '118' ]; then 
		if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 0 -a $CUR_PATCH -gt 0 ] ||
			[ $CUR_MAJOR -eq 7 -a $CUR_MINOR -gt 0 ]; then
			if [ $TO_MAJOR -eq 7 -a $TO_MINOR -eq 0 -a $TO_PATCH -eq 0 ]; then
				add_err_status "$UNSUPPORTEDPLATFORMMSG" "$BNA_UNSUPPORTEDPLATFORMMSG"
				return $STS_ERR
			fi
		fi
	fi

	# Block downgrade to 7.0.0 in Dcx+ and Pluto+ when
	# FC8-16 or FC8-32 or FC8-48 is present.
	if [ $TO_MAJOR -eq 7 -a $TO_MINOR -eq 0 -a $TO_PATCH -eq 0 ]; then
		TEST check_FC8_blades_dcx_pluto_plus "$FC8_BLADE_IS_PRESENT" "$BNA_FC8_BLADE_IS_PRESENT"
		if [ $? -ne $STS_OK ]; then
			return $STS_ERR
		fi
	fi

	#
	# Block if any FCIP feature checks fail
	#
	TEST check_xfcip_features "$XFCIP_FEATURE_RESTRICTION" "$BNA_XFCIP_FEATURE_RESTRICTION"
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi

    check_71_0_enc_sw_features
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi
	#
	# Block if any condor ex-port present
	#
	TEST check_condor_ex_ports_configured "$CONDOR_EX_PORT_RESTRICTION" "$BNA_CONDOR_EX_PORT_RESTRICTION"
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi
	#
	# Check for the co-existence of Marathon and Striker blades
	#
	TEST check_blades_marathon_striker_enabled "$MARATHON_STRIKER_ERR_MSG" "$BNA_MARATHON_STRIKER_ERR_MSG"
	if [ $? -ne $STS_OK ]; then
		return $STS_ERR
	fi

	#
	# Block downgrade if any Enhanced FC8 blade is present.
	#
	check_enhanced_fc8_present
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi

	# Block downgrade if Ex port configured on ICLs
	TEST check_icl_ex_port_configuration  "$EX_PORT_ICL_NOT_SUPPORTED"
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi

	check_sec_auth_certificate_database_for_brcd
	if [ $? -ne $STS_OK ]; then
		add_err_status "$UNSUPPORTED_BRCD_CERTIFICATE_DATABASE_VALUE" "$BNA_UNSUPPORTED_BRCD_CERTIFICATE_DATABASE_VALUE"
		return $STS_ERR
	fi

	#
	# Block downgrade to lower versions if ports are configured with longdistance
	# -buffer option.
	#
	check_longdist_buffer_option_ports 
	if [ $? -ne $STS_OK ]; then
		add_err_status "$LONGDIST_BUFFER_OPTION_RESTRICTION"
		return $STS_ERR
	fi


	if [ $TO_MAJOR -eq 7 -a $TO_MINOR -eq 0 -a $TO_PATCH -eq 0 ]; then
		check_70_1_sw_features
		OVERALL_STS=$?
		if [ $OVERALL_STS != $STS_OK ]; then
			return $OVERALL_STS
		fi
	fi
	
	#
	# Block 7.1 -> 7.0 if 7.1 feature is enabled
	#
	check_71_sw_features
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi

	#
    # Block 7.2 -> 7.0 if 7.2 feature is enabled
    #
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 2 ]; then
	    check_72_sw_features
	fi
    OVERALL_STS=$?
    if [ $OVERALL_STS != $STS_OK ]; then
        return $OVERALL_STS
    fi
}

asic_db_blade_type_() {

	# initialize to unknown blade id & type
	blade_type=""
	num_c2s=0
	if test -f /proc/fabos/blade/$1/info; then

		# ref. blade id is defined in linux/include/brocade/swbd.h		
		bladeid=`cat /proc/fabos/blade/$1/info | /bin/grep --binary-files=text bladeId | sed 's/[^0-9]//g'`

      case "$bladeid" in
		"58" ) blade_type="littlebear";num_c2s=1;;
		"60" ) blade_type="bulova";num_c2s=1;;
		"61" ) blade_type="blazer3";num_c2s=1;;
		"63" ) blade_type="superhawk2";num_c2s=1;;
		"64" ) blade_type="utah";num_c2s=1;;
		"70" ) blade_type="falcon2";num_c2s=1;;
		"73" ) blade_type="kestrel2";num_c2s=1;;
		"37" ) blade_type="despina";num_c2s=1;;
		"55" ) blade_type="larissa";num_c2s=2;;
		"51" ) blade_type="triton";num_c2s=2;;
		"46" ) blade_type="hydra";num_c2s=2;;
		"56" ) blade_type="spirit";num_c2s=1;;
		"79" ) blade_type="gladius";num_c2s=1;;
		"59" ) blade_type="tomahawk";num_c2s=1;;
		"53" ) blade_type="thor";num_c2s=9;;
		"52" ) blade_type="proteus";num_c2s=4;;
		"77" ) blade_type="quattro";num_c2s=4;;
		"45" ) blade_type="elara";num_c2s=1;;
		"74" ) blade_type="europa";num_c2s=1;;
		"69" ) blade_type="spike";num_c2s=1;num_blaster=1;;
		"75" ) blade_type="striker";num_c2s=1;num_blaster=2;;
		"42" ) blade_type="mace";num_c2s=2;;
		"43" ) blade_type="lance";num_c2s=2;;
		* ) blade_type="others";num_c2s=0;
      esac

	fi
}

# This is to block firmwaredownload from X-Swing
# to 6.4 or previous versions of 6.4
handle_to_64_lower()
{
	$ECHO handle_to_64_lower
	
	add_err_status "$UNSUPPORTED_DL_VERMSG" "$BNA_UNSUPPORTED_DL_VERMSG"
	return ${STS_ERR}
}

# get the current firmware version
get_current_version()
{
	CUR_MAJOR=$(/sbin/getfabosver | sed -n -e 's/Major://gp')
	CUR_MINOR=$(/sbin/getfabosver | sed -n -e 's/Minor://gp')
	CUR_PATCH=$(/sbin/getfabosver | sed -n -e 's/Patch://gp')
}

# Function to check whether marathon and striker blades are present.
# If both the blades are present, then the firmwaredownload needs
# to be blocked
check_blades_marathon_striker_enabled()
{
	STRIKER_PRESENT=0
	MARATHON_PRESENT=0
	blade_count=0

	slotshow_out=`/fabos/cliexec/slotshow -d576 | /bin/grep "AP BLADE" | /bin/sed 's/[ \t][ \t]*/;/g'`
	blade_count=`echo $slotshow_out | /bin/grep "BLADE" | /usr/bin/wc -w`

	if [ $blade_count -le 1 ]; then
		return $STS_OK
	fi

	count=1

	while [ $count -le $blade_count ]
	do
		temp_str=`echo $slotshow_out | /usr/bin/cut -d ' ' -f $count`
		blade_id=`echo $temp_str | /usr/bin/cut -d ';' -f 5`

		if [ $blade_id -eq 75 ]; then
			STRIKER_PRESENT=1
		elif [ $blade_id -eq 24 ]; then
			MARATHON_PRESENT=1
		fi

		count=`/usr/bin/expr $count + 1`
	done

	if [ $STRIKER_PRESENT -eq 1 -a $MARATHON_PRESENT -eq 1 ]; then
		ret=$STS_ERR
	else
		ret=$STS_OK
	fi

	if [ $ret -eq $STS_OK ]; then
		if [ $MARATHON_PRESENT -eq 1 -a $STRIKER_PRESENT -eq 0 ]; then
			DISPLAY_MARATHON_STRIKER_WARN_MSG=1	
		fi
	fi

	return $ret
}

#
# main()
#
$ECHO Requested version is ${TO_MAJOR}.${TO_MINOR}.${TO_PATCH} Type is $TYPE


if [ -z $TYPE ]; then
	TEST check_hcl_switchstate "$SWITCH_FAULTY_MSG" "$BNA_SWITCH_FAULTY_MSG"
	RET=$?
	if [ $RET != $STS_OK ]; then
		exit $RET_CODE
	fi

	#
	# clean up to free up disk space on /mnt before firmwaredownload
	#
	$ECHO removing tracedump.dmp
	rm -f /mnt/var/tracedump.dmp
	# Overwrite raslog.int and raslog.ext file with FWDL version
	# This ensures that we do not overwrite the raslog files of new standby with
	# new active CP files.
	RASLOG_INT_FILE=/mnt/etc/raslog.int
	RASLOG_EXT_FILE=/mnt/etc/raslog.ext

	echo "RASLOG" > $RASLOG_INT_FILE
	echo "RASLOG" > $RASLOG_EXT_FILE
fi

get_current_version
#
# Handle a downgrade to less than 7.2.1
#
if [ $TO_MAJOR -eq 7 -a $TO_MINOR -eq 2 -a $TO_PATCH -lt 1 ]; then
	SSHD_CONFIG_FILE=/etc/sshd_config
	SSH_CONFIG_FILE=/etc/ssh_config
	SSHD_CONFIG_FILE_MNT=/mnt/etc/sshd_config
	SSH_CONFIG_FILE_MNT=/mnt/etc/ssh_config
	GREP=/bin/grep
	ret=STS_OK

    FABOS_SWITCHNO_TEMP=$FABOS_SWITCHNO
    FABOS_SWITCHNO=0
    retVal=`/fabos/cliexec/config get fips.mode 2`
    FABOS_SWITCHNO=$FABOS_SWITCHNO_TEMP
    if [ $retVal -eq 1 ]; then
		#check in /etc
		if $GREP "^ShaValue" $SSH_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi		
		if $GREP "^MinPrime" $SSH_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^ServerHostKeySize" $SSH_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^KexAlgorithms diffie-hellman-group-exchange-sha256" $SSH_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi

		if $GREP "^ShaValue" $SSHD_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^MinPrime" $SSHD_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^KexAlgorithms diffie-hellman-group-exchange-sha256" $SSHD_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi
		
		#check in /mnt/etc
		if $GREP "^ShaValue" $SSH_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^MinPrime" $SSH_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^ServerHostKeySize" $SSH_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^KexAlgorithms diffie-hellman-group-exchange-sha256" $SSH_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi

		if $GREP "^ShaValue" $SSHD_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^MinPrime" $SSHD_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^KexAlgorithms diffie-hellman-group-exchange-sha256" $SSHD_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi
		if [ $ret == STS_ERR ]; then
			add_err_status "$UNSUPPORTED_DOWNGRADE_721"		
			exit $STS_ERR
		fi
	fi
fi

#
# Handle a specific firmware version
#
case "${TO_MAJOR}.${TO_MINOR}" in
	'7.2')
		handle_to_72
		RET=$?
	;;
	'7.1')
		handle_to_71
		RET=$?
	;;
	'7.0')
		handle_to_70
		RET=$?
	;;
		*)
		handle_to_64_lower
		RET=$?
	;;
esac

#
# Preinstall check fails
#
if [ $RET != $STS_OK ]; then
	exit $RET;
fi

# Pre-installation has completed successfully. Need to print the
# Marathon-striker warning message before firmwaredownload starts
if [ -z $TYPE ]; then
	if [ $DISPLAY_MARATHON_STRIKER_WARN_MSG -eq 1 ]; then
		echo -e "\n$MARATHON_STRIKER_WARN_MSG\n"
		echo -e "$BNA_MARATHON_STRIKER_WARN_MSG" >> $BNA_STATUS_FILE
	fi
fi

#
# Firmwaredownload check passes, return
#
if [ -z $TYPE ]; then
	$ECHO return code is $RET
	exit $RET
fi

#
# For firmwarerestore, we will perform the firmwarerestore here.
# it will not return to the caller. That is to workaround a
# 2.4.19 kernel and 2.3.6 glibc mismatch issue. (79299). Read
# more comments in fwdl_undo() in the fwdl.c file.
#
baddev=`bootenv BadRootDev 2>/dev/null`
upgrade=`bootenv Upgrade 2>/dev/null`
softupgrade=`bootenv SoftUpgrade 2>/dev/null`

dev_p=`bootenv OSRootPartition 2>/dev/null | cut -d ';' -f 1`
dev_s=`bootenv OSRootPartition 2>/dev/null | cut -d ';' -f 2`
kern_p=`bootenv OSLoader 2>/dev/null | cut -d ';' -f 1`
kern_s=`bootenv OSLoader 2>/dev/null | cut -d ';' -f 2`

mount_p=`cat /proc/mounts | grep " / " | grep -v rootfs |sed 's? .*??g;s?^.*dev/??g'`
mount_s=`cat /proc/mounts |grep "/mnt" | sed 's? .*??g;s?^.*dev/??g'`

if [ -n "$baddev" ]; then
	add_err_status "$FWDL_RUNNING_MSG" "$BNA_FWDL_RUNNING_MSG"
    	exit 1;
fi

if [ -n "$softupgrade" ]; then
	add_err_status "$FWDL_RUNNING_MSG" "$BNA_FWDL_RUNNING_MSG"
	exit 1;
fi

if [ "$upgrade" != /dev/$mount_p ]; then
	add_err_status "$FWRESTORE_DISALLOWED_MSG" "$BNA_FWRESTORE_DISALLOWED_MSG"
    	exit 1;
fi

#
# prevent firmwarerestore from 6.3 to 6.1.2_cee because
# the we can not restore the PROM image in this case
#
case ${SWBD##SWBD} in
	'76')
		if [ ! -s /mnt/boot/bootrom.bin ]; then
			add_err_status "$FWRESTORE_VER_DISALLOWED_MSG" "$BNA_FWRESTORE_VER_DISALLOWED_MSG"
			exit 1;
		fi
	esac

# The following steps restores the old RBAC dynamic db
if [ $CUR_MAJOR -eq 7 -a $TO_MAJOR -eq 7 ]; then
	/usr/sbin/chroot /mnt /fabos/libexec/userdb_convert $CUR_MAJOR.$CUR_MINOR $TO_MAJOR.$TO_MINOR > /dev/null 2>&1
	cp /mnt/etc/fabos/rbac/dynamic /etc/fabos/rbac/dynamic
fi

#Push Manufacturing key to SP
if [ -f '/fabos/libexec/spmPublicKeyUpdate' ] ; then
	/fabos/libexec/spmPublicKeyUpdate
fi

# Resotoring only the 8548 and 440epx prom images
echo "Restoring the PROM image ..."
if [ -s /mnt/boot/bootrom.bin ]; then
    /usr/sbin/chroot /mnt /sbin/prominst
fi

bootenv OSRootPartition "$dev_s;$dev_p"
bootenv OSLoader "$kern_s;$kern_p"
bootenv Upgrade "/dev/$dev_s"
bootenv SoftUpgrade "commit"

# Pre-installation has completed successfully. Need to print the
# Marathon-striker warning message before firmwarerestore reboots
# the switch
if [ $DISPLAY_MARATHON_STRIKER_WARN_MSG -eq 1 ]; then
	echo -e "\n$MARATHON_STRIKER_WARN_MSG\n"
	echo -e "$BNA_MARATHON_STRIKER_WARN_MSG" >> $BNA_STATUS_FILE
fi

if [ $CUR_MAJOR -eq 6 -a $CUR_MINOR -le 2 ]; then
echo "The system is rebooting now!! After reboot, firmwarecommit" \
    "will be started and the partitions will be restored to the" \
    "original firmware."
/fabos/cliexec/reboot -s -r FirmwareDownload -f
fi

exit 0

#!/bin/sh
#
#    Copyright (c) 2004-2015 Brocade Communications Systems, Inc.
#    All rights reserved.
#
#    Description:
#
#        This pre-install script will be run before firmware
#        download or firmwarerestore starts. 
#
MSG="
There  is  a  problem  with  the  firmware  image  installed  on  the  server.
The preinst file is in DOS format. Please reload the firmware image on server,
using the right tool/options  (to prevent  DOS style  ASCII file conversions),
and then retry firmwaredownload.  "; # comment so ^M will not impact MSG.

check4dos() { if [ $# -gt 1 ] ; then echo "$MSG" ; exit 5 ; fi ; } ; check4dos 1 
#
# Note the extra space (above) at the end of the call "check4dos 1 " right here ^
# This space is very important for it to work correctly.
# In case of dos conversion it will add a ^M at the end of this space.
# That will make it look like calling check4dos with 2 parameters,
# and result in $MSG being printed out instead of the current failure
# ": not a signal specification" which does not convey what exactly went wrong.
#
# This will not address all types of conversion errors though.
# We have seen cases wher ^M was added at the end of PATH below.
# To address that a space has been added at the end of that line
#

#################################################################################
# Attention!                                            						# 
#																				#
# Please do not remove these lines in all future merges. This define indicates	#
# 8548 Rev 3.1 CPU is supported by this firmware. This define is not used in	#
# the preinstall script, but it will be  used by the check_cpu script later!	#
#																				#
CP31_ZENTRON4_SUPPORTED="Version Supports 8548 Rev 3.1 CP"
NON_DFE_SUPPORTED="Version Supports NON DFE"
QSFPP_ICL_SUPPORTED="Version Supports QSFPP ICL"
BUF_OP_MODE_SUPPORTED="Version Supports BufOpMode"
Q20_SWBD134_SUPPORTED="Version Supports Q20 for Huawei"
RFM_SUPPORTED="Version Supports RFM"
RFM_ECB_SUPPORTED="Version Supports RFM+ECB"
#################################################################################

# Trap / Ignore SIGINT so user cannot interrupt this script with ^C
trap "" 2
trap "" SIGPIPE
PATH=/bin:/usr/bin:/sbin:/usr/sbin # adding comment to protect from DOS conversion


#
# Passed in version numbers
#
TO_MAJOR=$1
TO_MINOR=$2
TO_PATCH=$3

CUR_MAJOR=0
CUR_MINOR=0
CUR_PATCH=0
PREINST="preinstall"
ENC_VERSION_STR="6.1.1_enc"
ENC_VERSION_STR_DEV="6.1.1orion"
CEE_VERSION_STR="6.1.2_cee"
RELEASE_FILE="/tmp/release.plist"
RESTORE_FILE="/mnt/fabos/share/release"
DISPLAY_MARATHON_STRIKER_WARN_MSG=0
NEW_PREINST="/tmp/new_preinst"

#
# When firmwaredownload is invoking this script,
# TYPE should be NULL; when firmwarerestore is
# invoking it, TYPE is "restore"
#
TYPE=$4

#
# Common variables
#
CHASSISCONFIG=/bin/getchassisconfig
NULL=/dev/null
if [ "$DEBUG" = 1 ]; then
	ECHO='echo -e'
else
	ECHO=:
fi

# This should match the file name in src/lib/upgrade/upgrade.c
STATUS_FILE=/tmp/fwdl_err.txt
BNA_STATUS_FILE=/tmp/bna_fwdl_err.txt
FCIP_STATUS_FILE=/tmp/fcip_fwdl_err.txt
# clear status file
echo > $STATUS_FILE
echo " " > $STATUS_FILE
echo > $BNA_STATUS_FILE
echo " " > $BNA_STATUS_FILE
if [ -z $TYPE ]; then
	echo "The following item(s) need to be addressed before downloading the specified firmware:" >> $STATUS_FILE
else
	echo "The following items need to be addressed before restoring the specified firmware:" >> $STATUS_FILE
fi

#
# Error codes - these have to match the error codes
# in fwdl.h.
#
STS_OK=0
ERR_CONF_LSANMATRIX=75		# FWDL_ERR_SECMODE 0x51
STS_ERR=255

RET_CODE=${STS_OK}
RET=${STS_OK}
OVERALL_STS=$STS_OK

FWDL_PREINST_SWITCHNAME="/tmp/fwdl_preinst_switchname"
export CHASSIS_ROLEID=0
if /fabos/bin/fosconfig --show | grep "Virtual Fabric" | grep enabled > /dev/null 2>&1 ; then VF_ENABLED=$STS_ERR; else VF_ENABLED=$STS_OK; fi

#
# Key vault Defeinitions
#
KEY_VAULT_TYPE_LKM=0x1
KEY_VAULT_TYPE_RSA=0x2
KEY_VAULT_TYPE_EFCM=0x3
KEY_VAULT_TYPE_SKM=0x5
KEY_VAULT_TYPE_NCKA=0x6
KEY_VAULT_TYPE_TKLM=0x7
KEY_VAULT_TYPE_KMIP=0x8

#
# cpid
#
# Retrieve the current Control Processor ID
#
cpid() {
    sed -n -e 's/^Control.\+No: \([[:digit:]]\{1,\}\)$/\1/gp'
}

#
# swbd
#
# Retrieve the current system platform name, of the form "SWBDn", where n
# is cardinal number, assuming a sin/hinv input stream.
#
swbd() {
    sed -n -e 's/^.\+\(SWBD[[:digit:]]\{1,\}\).\+$/\1/gp'
}

# Determine the system platform identifier.
SWBD=`sin | swbd 2> ${NULL}`
CPID=`sin | cpid 2> ${NULL}`


otherhost(){
#        printf 10.0.0.$((5+$(othercp)))
	case ${SWBD##SWBD} in
	'62')
	    printf 127.1.1.$((8 - CPID % 2))
	    ;;
	'77')
	    printf 127.1.1.$((6 - CPID % 2))
	    ;;
	'141')
		printf 127.1.$((17 - CPID % 2)).$((17 - CPID % 2))
	    ;;
	'142')
		printf 127.1.$((15 - CPID % 2)).$((15 - CPID % 2))
	    ;;
	*)
	    printf 10.0.0.$((6 - CPID % 2))
	    ;;
	esac
}

HASHOW="$(/fabos/bin/hashow)"
hashow_cmd=$(ls /fabos/cliexec/hashow)
if [ "$hashow_cmd" != "/fabos/cliexec/hashow" ]; then
       	hashow_cmd="/fabos/bin/hashow"
fi

othercp(){
        that=${HASHOW#*Remote CP \(Slot}
        that="${that%%,*}"
        printf $(($that - 5))
}

add_err_status(){
	echo -e "$1" >> $STATUS_FILE
	if [ "$#" -eq "1" ]; then
		echo -e "$1" >> $BNA_STATUS_FILE
	elif [ "$#" -eq "2" ]; then
		echo -e "$2" >> $BNA_STATUS_FILE
	
	fi	
}

add_err_status_fid(){
	if [ "$#" -eq 2 ]; then
		echo -e "$1" "$2" >> $STATUS_FILE
		echo -e "$1" "$2" >> $BNA_STATUS_FILE
	elif [ "$#" -eq 3 ]; then
		echo -e "$1" "$3" >> $STATUS_FILE
		echo -e "$2" "$3" >> $BNA_STATUS_FILE
	fi
	
}

ha_role() {
 	case "$($hashow_cmd | ( read a; echo $a ))" in
	    *Local*Active*)
	    printf "ACTIVE"
 	    ;;
	    *Local*Standby*)
	    printf "STANDBY"
 	    ;;
	    *"Not supported"*)
	    printf "ACTIVE"
 	    ;;
	    *)
	    printf "STANDBY"
	    ;;
	esac
}

HA_ROLE=$(ha_role)
if [ $HA_ROLE == "ACTIVE" ]; then
    ACTIVECP=1
fi

ha_state() {
    sync=`/fabos/cliexec/hashow | sed -n -e 's/^.\+\(State sync\).\+$/\1/gp'`

    if [ "$sync" != "State sync" ]; then
	    printf "NOSYNC"
    else
	    printf "SYNC"
    fi
}

HA_STATE=$(ha_state)

is_fwdl_arg() {

	#
	# Reads command line args passed to firmwaredownload
	# and checks if the required argument is specified
	#
	for arg in $(/usr/bin/tr '\0' ' ' < /proc/$PPID/cmdline)
	do
            case $arg in
            (-*$1*)
		return $STS_OK
		;;
            esac
        done
        return $STS_ERR
}

allow_nondisruptive_fwdl() {
	# Skip for restore
	if [ -n "$TYPE" ]; then
		$ECHO " running firmwarerestore"
		return $STS_OK
	fi

    # Allow 6.1.2_cee <-> 6.3 HCL on Elara
    # For others, allow only disruptive fwdl
    case ${SWBD##SWBD} in
    '76')
        ;;
    *)
		is_fwdl_arg "s"
		local singlemode=$?
		is_fwdl_arg "f"
		local forcemode=$?
		if [ $singlemode -ne 0 -o $forcemode -ne 0 ]; then
			return $STS_ERR
		fi
		;;
	esac

	return $STS_OK
}

allow_disruptive_single_mode_fwdl() {
	# Skip for restore
	if [ -n "$TYPE" ]; then
		$ECHO " running firmwarerestore"
		return $STS_OK
	fi

	is_fwdl_arg "s"
	local singlemode=$?
	if [ $singlemode -ne 0 ]; then
		return $STS_ERR
	fi
	
	slotbased=`/sbin/bootenv slotbased 2>/dev/null| grep yes`
        if [ "$slotbased" != "yes" ] ; then
                auto_reboot=`/sbin/bootenv autoboot 2>/dev/null | grep yes`
                if [ "$auto_reboot" = "yes" ] ; then
                        return $STS_ERR
                fi
        fi
	return $STS_OK
}

check_for_non_disruptive_fwdl() {
	# Skip for restore
	if [ -n "$TYPE" ]; then
		$ECHO " running firmwarerestore"
		return $STS_ERR
	fi

	is_fwdl_arg "s"
	local singlemode=$?
	if [ $singlemode -ne 0 ]; then
		return $STS_OK
	fi

	return $STS_ERR
} 

check_autoreboot_opt() {
	# Skip for restore
	if [ -n "$TYPE" ]; then
		$ECHO " running firmwarerestore"
		return $STS_OK
	fi

	is_fwdl_arg "b"
	local auto_reboot=$?
	if [ $auto_reboot -eq 0 ]; then
		return $STS_ERR
	fi

	return $STS_OK
}

TEST() {

	$ECHO  -n "TEST $1 "
	if [ $HA_ROLE == "STANDBY" ] && [ $HA_STATE == "NOSYNC" ]; then
	    return $STS_OK
	fi

	$1
 	if [ "$?" -ne "$STS_OK" ]; then
		$ECHO "failed"
		if [ "$#" -eq "2" ]; then
			add_err_status "$2"
		elif [ "$#" -eq "3" ]; then
			add_err_status "$2"	"$3"
		fi		
		RET_CODE=$STS_ERR
		return $STS_ERR
	fi

	$ECHO "passed"
	return $STS_OK
}

TEST_FIDS()
{
	check_failed=0
	FID_CONTEXT="FID(s)"
	SPACE_STRING=" "
	PERIOD="."
	COMMA=","
	num_err=0
	rval=$STS_OK
	local_flag=$?
	non_vf_switch="switch"

	$ECHO  -n "TEST $1 "
	if [ $(ha_role) == "STANDBY" ] && [ $(ha_state) == "NOSYNC" ]; then
	    return $STS_OK
	fi
	if [ $VF_ENABLED -ne $STS_OK ]; then 
		if [ $(ha_role) == "ACTIVE" ]; then
			FID_LIST=${CONTEXTS}
		else
			/bin/ln -s /fabos/cliexec/lscfg_util /fabos/link_sbin/lscfg_test 2> /dev/null
			export PATH=/fabos/link_bin:/bin:/usr/bin:/sbin:/usr/sbin:/fabos/link_abin:/fabos/link_sbin:/fabos/factory:/fabos/xtool
			STANDBY_FIDS=`lscfg_test --all | grep -e "[0-9]" | grep -v "Total" | \
							awk '{ print $2 }'`
			FID_LIST=$STANDBY_FIDS
		fi

		for FID in $FID_LIST
		do
			context_switch $FID
			$1
			if [ $? -ne $STS_OK ]; then
				check_failed=1
				num_err=`expr $num_err + 1`
				if [ $num_err -eq 1 ]; then
					FID_CONTEXT=$FID_CONTEXT$SPACE_STRING$FID
				else
					FID_CONTEXT=$FID_CONTEXT$COMMA$FID
				fi
			else
				continue
			fi
		done
	else
		$1
		if [ $? -ne $STS_OK ]; then
			check_failed=1
			FID_CONTEXT=$non_vf_switch
		fi
	fi
	if [ $check_failed -eq 0 ]; then
		return $STS_OK
	else
		$ECHO "failed"
		FID_CONTEXT=$FID_CONTEXT$PERIOD
		if [ "$#" -eq 2 ]; then
			add_err_status_fid "$2" "$FID_CONTEXT"
		elif [ "$#" -eq 3 ]; then
			add_err_status_fid "$2" "$3" "$FID_CONTEXT"
		fi
		RET_CODE=$STS_ERR
		return $STS_ERR
	fi

}

TEST_FIDS_ADV()
{
	check_failed=0
	FID_CONTEXT="FID(s)"
	SPACE_STRING=" "
	PERIOD="."
	COMMA=","
	num_err=0
	rval=$STS_OK
	local_flag=$?
	non_vf_switch="switch"

	$ECHO  -n "TEST $1 "
	if [ $HA_ROLE == "STANDBY" ] && [ $HA_STATE == "NOSYNC" ]; then
	    return $STS_OK
	fi

	 numOfArgs="$#"; # get the last argument
	 lastArg=${!#}; # get the last argument
	 fArgs="${lastArg/funcArgs=}";
	 # it means user has not passed any function arguments
	 if [ $fArgs == "$lastArg" ]
	 then
	     fArgs=""
	 fi

	 arg2=$(eval echo $`echo $2`);
	 let numOfArgs=numOfArgs-1
	 if [ $numOfArgs -eq 3 ]; then
	     arg3=$(eval echo $`echo $3`);
	 fi

	if [ $VF_ENABLED -ne $STS_OK ]; then 
		if [ $HA_ROLE == "ACTIVE" ]; then
			FID_LIST=${CONTEXTS}
		else
			/bin/ln -s /fabos/cliexec/lscfg_util /fabos/link_sbin/lscfg_test 2> /dev/null
			export PATH=/fabos/link_bin:/bin:/usr/bin:/sbin:/usr/sbin:/fabos/link_abin:/fabos/link_sbin:/fabos/factory:/fabos/xtool
			STANDBY_FIDS=`lscfg_test --all | grep -e "[0-9]" | grep -v "Total" | \
							awk '{ print $2 }'`
			FID_LIST=$STANDBY_FIDS
		fi

		for FID in $FID_LIST
		do
			context_switch $FID
			$1 $fArgs
			if [ $? -ne $STS_OK ]; then
				check_failed=1
				num_err=`expr $num_err + 1`
				if [ $num_err -eq 1 ]; then
					FID_CONTEXT=$FID_CONTEXT$SPACE_STRING$FID
				else
					FID_CONTEXT=$FID_CONTEXT$COMMA$FID
				fi
			else
				continue
			fi
		done
	else
	    $1 $fArgs
		if [ $? -ne $STS_OK ]; then
			check_failed=1
			FID_CONTEXT=$non_vf_switch
		fi
	fi
	if [ $check_failed -eq 0 ]; then
		return $STS_OK
	else
		$ECHO "failed"
		FID_CONTEXT=$FID_CONTEXT$PERIOD
		if [ $numOfArgs -eq 2 ]; then
			add_err_status_fid "$arg2" "$FID_CONTEXT"
		elif [ $numOfArgs -eq 3 ]; then
			add_err_status_fid "$arg2" "$arg3" "$FID_CONTEXT"
		fi
		RET_CODE=$STS_ERR
		# echo "....$numOfArgs  ... $arg2"
		# cat $STATUS_FILE
		return $STS_ERR
	fi

}

CHASSISCMD=""
cliidx=0
export PATH=/fabos/link_bin:/bin:/usr/bin:/sbin:/usr/sbin:/fabos/link_abin:/fabos/link_sbin:/fabos/factory:/fabos/xtool
export VFROLEMAP=-1:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0

context_switch()
{
    if [ $VF_ENABLED -ne $STS_OK ]; then
        if [ "$1" != "chassis" ]
        then
            eval $(/fabos/cliexec/lscfg_util --switch $1)
        else
            eval $(/fabos/cliexec/lscfg_util --chassis)
            #export CHASSIS_ROLEID=0
        fi
    fi
	glb_vf_id="$CURRENT_VF"
	glb_ls_id="$FABOS_SWITCHNO"
    export ROLE_ID=root
}

cmd_chassis() {

  context_switch chassis

  if [ "$CONFIG" = "TRUE" ]; then
    echo -n . > $TTY
    cliidx=`/usr/bin/expr $cliidx + 1`
    echo "$cliidx $1 $2 $3 $4 $5 $6 $7 $8 $9" >> $cshow
    echo -e "$1 $2 $3 $4 $5 $6 $7 $8 $9:"
      echo "** $1 $2 $3 $4 $5 $6 $7 $8 $9: Command:$rc **" >> $cshow
  else
    echo -e "$1 $2 $3 $4 $5 $6 $7 $8 $9:"
    $1 $2 $3 $4 $5 $6 $7 $8 $9
  fi
}


# Helper function. It sets the global variable CONTEXTS to be a list of fabric IDs.
# Typical usage is seen in the function for_all_contexts, where we use CONTEXTS if it
# is defined, and otherwise call this function. This means we only need to do
# the configshow once for each run of preinst, rather than once for each test
# that wants to run in all contexts
#get_all_contexts(){
#	CONTEXTS=$($CHASSISCMD /fabos/cliexec/configshow -all | sed -n 's/Fabric ID =//p')
#	echo $CONTEXTS
#}
	CONTEXTS=$($CHASSISCMD /fabos/cliexec/configshow -all | sed -n 's/Fabric ID =//p')



glb_ls_id=0
glb_vf_id=128
def_vf_id=128

# store the configiration for all FIDs in the tmp files to avoid calling configshow multiple times.
if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF is enabled
	for FID in ${CONTEXTS} ; do
		context_switch $FID
		/fabos/cliexec/configshow -fid $FID > /tmp/config_$FID
	done
else
	/fabos/cliexec/configshow > /tmp/config_128
fi

/fabos/cliexec/configshow -chassis  > /tmp/config_chassis
/fabos/cliexec/configshow -all  > /tmp/config_all

CONFIGSHOW() {

	if [ $ACTIVECP ] ; then
		if [ "$1" = "-chassis"  ]; then 
			cat /tmp/config_chassis
		elif [ "$1" = "-a" ] || [ "$1" = "-all" ] ; then
			cat /tmp/config_all
		else
			if [ $VF_ENABLED -ne $STS_OK ]; then
				cat /tmp/config_$CURRENT_VF
			else 
				cat /tmp/config_128
			fi
		fi
	else
		if [ "$1" = "-chassis"  ]; then 
			cmd="/fabos/cliexec/configshow -chassis"
			glb_ls_id=-1;
			glb_vf_id=255;
		elif [ "$1" = "-a" ] || [ "$1" = "-all" ] ; then
			cmd="/fabos/cliexec/configshow -all"
		else
			cmd="/fabos/cliexec/configshow"
		fi
	
		if [ $VF_ENABLED -eq $STS_OK ]; then
			# VF disabled
			/usr/bin/rsh -n $(otherhost) ROLE_ID=root LOGIN_ID=root CURRENT_AD=0 "$cmd"
		else
			# VF enabled, for_all_context changed glb_ls_id and glb_vf_id to each logical switch's
			/usr/bin/rsh -n $(otherhost) ROLE_ID=root LOGIN_ID=root CHASSIS_ROLEID=0 FABOS_SWITCHNO=$glb_ls_id CURRENT_VF=$glb_vf_id CURRENT_AD=0 "$cmd"
		fi
	fi

}

# Helper function. Loop over the valid fabric IDs running the test that is passed as
# a parameter. As soon as one test fails then return $STS_ERR. If all pass then
# return $STS_OK.
# WARNING. This command will change to a random context (The first one that fails
# the test or the last context if all pass). Random terms in case someone is searching
# this file, VF Virtual Fabric AD setcontext FID context and wants to find this warning
for_all_contexts(){
	for FID in ${CONTEXTS} ; do
		context_switch $FID
		glb_vf_id="$CURRENT_VF"
		glb_ls_id="$FABOS_SWITCHNO"
		if "$@"
		then	$ECHO -n "$FID-passed "
		else	$ECHO -n "$FID-failed "
				return $STS_ERR
		fi
	done
	return $STS_OK
}

for_all_contexts_standby(){
	rval=$STS_OK
	/bin/ln -s /fabos/cliexec/lscfg_util /fabos/link_sbin/lscfg_test 2> /dev/null
	local_flag=$?
	export PATH=/fabos/link_bin:/bin:/usr/bin:/sbin:/usr/sbin:/fabos/link_abin:/fabos/link_sbin:/fabos/factory:/fabos/xtool
	lscfg_test --all | grep -e "[0-9]" | grep -v "Total" |
	while read glb_ls_id glb_vf_id role
	do
		context_switch $glb_vf_id
		if "$@"
		then	$ECHO -n "$glb_vf_id-passed "
		else	$ECHO -n "$glb_vf_id-failed "
			# note the following return just return from the "|" subshell
			return $STS_ERR
		fi
	done
	if [ $? -ne $STS_OK ]; then rval=$STS_ERR; fi
	if [ $local_flag -eq 0 ];then /bin/rm /fabos/link_sbin/lscfg_test 2> /dev/null; fi
	return $rval
}


###################################################
### The messages are for firmwarerestore.	###
###################################################
FWDL_RUNNING_MSG="Firmwaredownload or firmwarecommit is already running. Please wait for it to complete first."
FWRESTORE_DISALLOWED_MSG="No need to run firmwarerestore because firmware has already been committed, or there is no firmwaredownload performed."
FWRESTORE_VER_DISALLOWED_MSG="Firmwarerestore from v6.3.x to v6.1.2_cee is not supported. Please run firmwarecommit first and then download the new firmware."

###################################################
###################################################
####                                           ####
####                                           ####
####     PRESINSTALL MESSAGES SECTION          ####
####    ------------------------------         ####
####                                           ####
###################################################
###################################################
SCIMITARMSG="The FA4-18 (type 33) blade is not supported by the target firmware. Please use slotshow to find out which slot it is in and remove it first."
XENONMSG="The FC10-6 (type 39) blade is not supported by the target firmware. Please use slotshow to find out which slot it is in and remove it first."
QUATTROMSG="The FC8-64 (type 77) blade is not supported by the target firmware. Please use slotshow to find out which slot it is in and remove it first. For VF enabled switch, use \"lscfg --restore_to_default FID\" to move all vacant ports in this slot to the default after removing the blade."
MARATHONMSG="The FR4-18i(type 24) blade is not supported by the target firmware. Please use slotshow to find out which slot it is in and remove it first."
UNSUPPORTED_DL_VERMSG="Cannot downgrade to 7.1 or lower. Please downgrade to 7.2 first and then download the desired firmware version."
UNSUPPORTED_UP_VERMSG="Cannot upgrade directly to 7.4. Please upgrade to 7.2 first and then upgrade to 7.4."
UNSUPPORTED_EMBD_DL_VERMSG="Cannot downgrade to 7.0 or lower. Please downgrade to 7.2 first and then download the desired firmware version."
UNSUPPORTED_EMBD_UP_VERMSG="Cannot upgrade directly to 7.3. Please upgrade to 7.2 first and then upgrade to 7.3."
UNSUPPORTED_72_TO_74_FWDL="Upgrade from v7.2 to v7.4.1d and higher is not supported. Please upgrade to 7.3 first and then upgrade to 7.4."
UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL="Non disruptive firmwaredownload is not supported when firmwaredownload with two versions apart. Please try to use \"firmwaredownload\" with single mode option enabled."
UNSUPPORTED_AUTOREBOOT_OPT_WARN_MSG="auto reboot option is not allowed with single mode when upgrade from 6.3 to 7.0. Please make sure that auto-reboot is not enabled before proceeding."
UNSUPPORTEDPLATFORMMSG="Cannot download the requested firmware because the firmware doesn't support this platform. Please enter another firmware path."
SWITCH_FAULTY_MSG="Firmwaredownload is not allowed since the switchState is Faulty. Use \"switchShow\" to see the switch state. Please recover the switch before proceeding."

UNSUPPORTED_EEMON_ON_DOWNGRADE="Downgrade is not allowed when end to end monitors are installed in AG. Please use \"perfDelEEMonitor \" to clear the end to end monitors installed before downgrading."
UNSUPPORTED_FMON_ON_DOWNGRADE="Downgrade is not allowed when frame monitors are installed in AG. Please use \"fmMonitor --delete \" to clear the frame monitors installed before downgrading."
UNSUPPORTED_LICENSES_ON_DOWNGRADE="Downgrade is not allowed because enhanced licenses are installed. Please remove them before downgrading."
UNSUPPORTED_STATICFPORTS_CONFIG_ON_DOWNGRADE="Downgrade is not allowed because static F-ports are configured. Please use \"ag --show \" to check for static F-ports and \"ag --staticdel <N-port> <F-ports>\" to delete the static mapping before downgrading."
UDROLE_FWDL_DISALLOWED_MSG="Downgrade is not allowed because user-defined roles are present. Please use \"roleconfig --show -all\" to check all the UD Roles and \"userconfig --show -all\" to check any users assigned these roles.If there are such users, use \"userconfig --change\" to assign default roles to the users or \"userconfig --delete\" to delete the users. Then remove the UD Roles with \"roleconfig --delete\""
UNSUPPORTED_ZONE_SIZE="Downgrade is not allowed because the existing zone configuration is more than 1MB. To downgrade to lower firmware version modify the existing zone configuration to 1MB or lesser."
PORTNAME_LEN_DISALLOWED_MSG="Downgrade is not allowed because one or more ports name length is greater than 32 bytes. Please use \"portname\" CLI to check and fix the port name/length before downgrading."
PORTSPEED_DISALLOWED_MSG="Downgrade is not allowed because one or more ports have speed configured as 10G/16G speed. Please remove unsupported blades CR8510(4)-16/CR8510-16 if present and use \"portcfgspeed\" CLI to change the speed before downgrading."
PAD_FEATURE_CHECK_MSG="Downgrade is not allowed because for one or more ports Port Auto Disable (PAD) is enabled with no options configured. Need to disable PAD for those ports first. Use \"portcfgautodisable\" CLI for command usage."
CONDOR3_BLADE_IS_PRESENT="FC16-32, FC16-48, CR8510(4)-16, and CR8510(8)-16 are not supported by the targeted firmware. Please use slotshow to determine which of these are installed and remove them before continuing."
UNSUPPORTED_ENCRYPTION_VERSIONING_DEC="Downgrade is not allowed for this key vault type as device decommission feature is in use. Please use \"cryptocfg --delete -decommissionedkeyids\" to disable device decommission. Make sure that there is no lun undergoing decommission, or is in failed state."
UNSUPPORTED_ENCRYPTION_VERSIONING_KMIP="Downgrade is not allowed when key vault type is KMIP. Please use \"cryptocfg --set -keyvault type\" to set a different keyvault type other than KMIP to disable the feature."
FCOE_PROVISION_CONFIG_MSG="With the current upgrade/downgrade, the CEE start up configuration dcf.conf file will be incompatible with FCoE provisioning changes as part of this build. CEE start up configuration file, dcf.conf can be backed up for future use. The user can save the configuration as backup and apply it once upgrade/downgrade is complete, to restore the switch configuration in its respective build version. If you wish to save the configuration file please abort firmware download and save the configuration file before proceeding."
UNSUPPORTED_INTEROP_MODE="Upgrade to 7.0 or above is not allowed when interopmode is enabled. To upgrade, please disable interopmode."
XFCIP_FEATURE_RESTRICTION="Downgrade is not allowed because some FCIP features are enabled and are not supported on the selected version. Please address these unsupported features before downgrading."
CONDOR_EX_PORT_RESTRICTION="Downgrade to selected version is not allowed because EX-Ports are configured on FR4-18i blade(s). Please remove EX-port configuration using \"portcfgexport\" CLI on the ports."
McDATA_EX_PORT_RESTRICTION="Upgrade to selected version is not allowed because Ex or VEx Ports are configured in McData/Open interop-mode. Please disable McData interopmode configuration using \"portcfgexport\" or \"portcfgvexport\" CLI on the ports."
NOS_EX_PORT_RESTRICTION="Downgrade to selected version is not allowed because EX-Ports are configured in Brocade NOS Interop-mode. Please remove EX-port configuration using \"portcfgexport\" CLI on the ports."
ENC_COMP_EX_PORT_RESTRICTION="Downgrade to selected version is not allowed because EX-Ports are configured  with encryption/compression feature. Please remove EX-port configuration using \"portcfgexport\" CLI or disable encryption/compression on the ports."
LONGDIST_BUFFER_OPTION_RESTRICTION="Downgrade to selected version is not allowed because few ports are configured  with Longdistance -buffers option. Please remove the configuration using \"portcfglongdistance L0\" CLI or change the configuration with -distance option."
UNSUPPORTED_VEPORT_THRESHOLD_CONFIG="Downgrade is not allowed because high/low threshold for VE-Port on the switch(s) is configured to decimal value. Kindly configure the threshold to a integer value and downgrade."
UNSUPPORTED_MULTIPLE_EMAIL_FW_ALERT="Downgrade is not allowed because Multiple recipient addresses might have been configured on any of the logical switches for any of the class to receive Fabric Watch email alerts. Please use "fwMailCfg" CLI command to configure single recipient address before downgrading."
UNSUPPORTED_BRCD_CERTIFICATE_DATABASE_VALUE="Downgrade to 7.0 is not allowed because either 1) FCAP authentication to one of the neighboring switches is configured to use Brocade issued certificates, or 2) Brocade Certificate files exist. Please remove or set the configuration to thirdparty and delete certificate files using \"pkiremove\" before upgrading."
CHECK_LDAP_CONFIGURED_OVER_IPv6="Downgrade is not allowed because IPv6 configuration for LDAP is in use. Please remove all the IPv6 configuration for LDAP using \"aaaconfig --remove\" before downgrading."
UNSUPPORTED_IPFILTER_POLICY="Downgrade is not allowed because IPFILTER forwarding rule(s) is enabled. To Downgrade to lower version please delete the FORWARD rule(s) from IPFILTER policy"
MARATHON_STRIKER_ERR_MSG="Firmware migration is not allowed since the FX8-24 and FR4-18i blades are both present.\nPlease remove the FR4-18i blades before proceeding with the firmwaredownload command."
MARATHON_STRIKER_WARN_MSG="After the firmware migration has completed, the FR4-18i blade(s) needs to be removed if the FX8-24 blade(s) is to be plugged into the chassis."
UNSUPPORTED_FWCONFIGURE1="Upgrade to 7.0 or above is not allowed because the threshold configuration changed alarm is set"
UNSUPPORTED_FWCONFIGURE2="Similar configuration may exist for other classes and areas and on other FIDs. Please use \"fwconfigure\" to unset the same."
UNSUPPORTED_CHECK_SECOND_TIMEBASE1="Upgrade is not allowed because timebase is configured as seconds"
UNSUPPORTED_CHECK_SECOND_TIMEBASE2="Similar configurations may exist for other classes and areas and on other FIDs. Please Configure the timebase to other unit using \"fwconfigure/thconfig/portthconfig\" and upgrade."
UNSUPPORTED_TSTIMEZONE="Downgrade is not allowed because tstimezone is configured with three sections input. please change the configuration with two sections and proceed."
VPWWN_CONFIGURED="Downgrade is not allowed because Fabric Assigned PWWN is configured in one or more partitions. Please delete all the Fabric Assigned PWWN configurations before downgrading."
FLOW_MANAGER_CONFIGURED="Downgrade is not allowed because Flow Vision is configured. Please delete all the flows using \"flow\" CLI."
VE_AS_XISL_CONFIGURED="Downgrade is not allowed, as there is a VE Port in the Base switch that could be used as an XISL and there is at least one logical switch with \"ALLOW XISL Use\" enabled. Either remove all VE Ports from the Base switch or disable XISL use in all logical switches and repeat the downgrade attempt."
BASE_SW_CONFIGURED="Downgrade from 7.4 is not allowed with Base Switch enabled. Please disable Base Switch and try."
FCIP_LS_WITH_XISL_ON="Downgrade is not allowed, as there is a VE Port in a logical switch that has \"ALLOW XISL Use\" enabled.  Please disable \"ALLOW XISL Use\" in all logical switches that include VE ports, and retry the downgrade attempt."
UNSUPPORTED_RRDY_BASE_SWITCH="Upgrade to 7.0 or above is not allowed since base switch has R_RDY enabled ports. Please disable the R_RDY enabled ports in base switch using portcfgislmode command."
UNSUPPORTED_IODDELAY_ON_UPGRADE="Upgrade to 7.0 or above is not allowed due to the presence of ioddelay configuration. Please reset the feature with \"ioddelayreset\" before upgrading to v7.0."
FCFW_NOT_SUPPORTED="Upgrade to 7.0 or above is not allowed because FC Fastwrite is not supported on this version. Please use \"fastwritecfg\" to deconfigure FC Fastwrite for all slots and try again."
BSTR_NOT_SUPPORTED="Upgrade to 7.0 or above is not allowed because TCP Byte Streaming is not supported on this version. Please use \"portcfg\" to deconfigure TCP Byte Streaming for all tunnels and try again."
UNSUPPORTED_DUP_PORT_WWN="Upgrade to 7.0 or above is not allowed because duplicate PWWN devices are detected in one or more partitions. Please configure the devices with unique PWWNs or disable the ports and remove the devices with duplicate PWWNs before upgrading the firmware."
SERDES_TUNE_ENABLED="Downgrade is not allowed because FC8-16 serdestunemode is enabled. Please use \"serdestunemode --show\" to view the mode and \"serdestunemode --reset\" to disable the feature before downgrading."
ENHANCED_FC8_BLADE_IS_PRESENT="FC8-32E and FC8-48E are not supported by the targeted firmware. Please use slotshow to determine which of these are installed and remove them before continuing."
UNSUPPORTED_DBR_ON_DOWNGRADE="Downgrade is not allowed because Device Based Routing is configured. Please use \"aptpolicy\" to change the routing policy."
FC8_BLADE_IS_PRESENT="FC8-16, FC8-32 and FC8-48 are not supported by the targeted firmware. Please use slotshow to determine which of these are installed and remove them before continuing."
WINDU_BLADE_IS_PRESENT="Brocade FC16-64 blades are not supported by the targeted firmware. Please use slotshow to find out which slot it is in and remove it first."
D_PORT_R_RDY_NOT_SUPPORTED="Downgrade is not allowed because R-RDY flow control ports are configured as D-Ports. Please use \"portdporttest --show all\" to view the port list and \"portcfgdport --disable\" to disable before downgrading."
D_PORT_DWDM_NOT_SUPPORTED="Downgrade is not allowed because D-Port is configured with DWDM mode. Please use \"portcfgshow\" to view the port list and \"portdisable [slot/]port; portcfgdport --disable -dwdm [slot/]port\" to reset DWDM mode before downgrading."
DOWNGDAOQ_SAO_REQ="Downgrade is not allowed as AoQ is active on server or HBA ports without Server Application Optimization license. To proceed further with downgrade either install Server Application Optimization license, or set QoS mode on AoQ enabled ports to OFF if it is ON/AE and then toggle these AoQ enabled ports to disable AoQ. Please use \"switchshow\" to view list of F_Port with AoQ feature enabled and use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF. To toggle the ports use \"portdisable [slot/]port and portenable [slot/]port\"."
DOWNGDAOQ_AN_REQ="Downgrade is not allowed as AoQ is active on device ports without Adaptive Networking license. To proceed further with downgrade either install Adaptive Networking license, or set QoS mode on AoQ enabled ports to OFF if it is ON/AE and then toggle these AoQ enabled ports to disable AoQ. Please use \"switchshow\" to view list of F_Port with AoQ feature enabled and use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF. To toggle the ports use \"portdisable [slot/]port and portenable [slot/]port\"."
DOWNGDAOQ_AN_SAO_REQ="Downgrade is not allowed as AoQ is active on server or HBA ports without Server Application Optimization license and Adaptive Networking license. To proceed further with downgrade either install Server Application Optimization license and Adaptive Networking license, or set QoS mode on AoQ enabled ports to OFF if it is ON/AE and then toggle these AoQ enabled ports to disable AoQ. Please use \"switchshow\" to view list of F_Port with AoQ feature enabled and use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF. To toggle the ports use \"portdisable [slot/]port and portenable [slot/]port\"."
DOWNGDQOS_AN_REQ_MSG1="Downgrade is not allowed as QoS mode is enabled (ON) on some of the ports and there is no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license, or set QoS mode to OFF/AE. Please use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF or use \"portcfgqos --default [slot/]port\" to set QoS mode on these ports to AE."
DOWNGDCSCTL_AN_REQ="Downgrade is not allowed as CSCTL mode is enabled (ON) on some of the ports and there is no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license, or set CSCTL mode to OFF. Please use \"portcfgqos --disable [slot/]port csctl_mode\" to set CSCTL mode on these ports to OFF."
DOWNGDRATELIMIT_AN_REQ="Downgrade is not allowed as Rate Limit is enabled (ON) on some of the ports and there is no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license, or reset Rate Limit to OFF. Please use \"portcfgqos --resetratelimit [slot/]port\" to reset Rate Limit on these ports to OFF."
DOWNGDQOS_AN_REQ_MSG3="Downgrade is not allowed as QoS is active on E_Port(s) with no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license on the switch, or turn OFF QoS on these ports. Please use \"islshow\" to view the list of E_Port(s) with QoS. In case these E_Port(s) are trunked, use \"trunkShow\" to list all the ports in the trunk group. Finally, use \"portcfgqos --disable [slot/]port\" to disable QoS on the ports."
DEFAULT_QOS_WARN_MSG="This action will set default QoS port configuration from AE to OFF because Adaptive Networking License is not installed on the switch."
FMS_LOSSLESS_XISL_CHECK_ERROR="FMS, Lossless and XISL feature combination error in downgrading from 7.1.x (and above) to 7.0.x (and below)"
ENC_COMP_FWDL_RESTRICTION="Downgrade to selected version is not allowed because more than 2 ports per Chip are configured with Encryption/Eompression feature. Please restrict encryption/compression configuration to 2 ports per Chip. Please use portenccompshow command to determine  which ports in the chip are configured for encryption/compression feature."
CHECK_AAA_TAC_SUPPORT="Firmware download is not allowed because TACACS+ protocol is enabled/configured in AAA configuration. Please use \"aaaconfig --authspec\" to change authspec mode other than TACACS+ or use \"aaaconfig --remove\" to remove TACACS+ server configuration."
UNSUPPORTED_AUTH_SWITCH_POLICY="Firmwaredownload is not allowed because switch authentication policy is either \"ON, ACTIVE or PASSIVE\". Please use \"authutil --policy -sw off\" to change switch authentication mode."
UNSUPPORTED_SWITCH_ENFORCED_LOGIN="Firmwaredownload is not allowed because switch enforce_login policy is set to value 2, please set the value to 0 or 1 using \" configure \" to proceed with firmwaredownload."
REMOVE_DPORT_CONFIGURATION="Downgrade is not allowed because switch is in AG mode and D-Ports are configured.\nPlease use \"switchshow\" to view the D-port list and use\n\"portcfgdport --disable <port_no>\" to disable it before downgrading."
CHECK_PASSWDCFG_SUPPORT="Firmwaredownload is not allowed because passwdcfg expiration policies are configured for per user basis. Please use \"passwdcfg --deleteuser -all\" to delete the per user expiration policy in passwdcfg and try firmwaredownload."
D_PORT_ICL_NOT_SUPPORTED="Downgrade is not allowed because ICL ports are configured as D-Ports.\nPlease use \"switchshow\" to view the D-port list and use\n\"portcfgdport --disable <port_no>\" to disable it before downgrading."
EX_PORT_ICL_NOT_SUPPORTED="Firmware downgrade is not allowed because ICL ports are configured as EX-Ports. Please use \"portcfgshow\" to view the ICL EX ports and use \"portcfgexport\" to disable the EX feature on those ports before downgrading."
SCAL_DOWN_TO_2K_PROXY_ON_EXPORT="Firmware downgrade is not allowed when more than 2000 proxies are downloaded on any EX-Port. \nPlease use \"fcrresourceshow\" CLI to view the total number of proxies that are downloaded through each EX-Port and scale down the total number of proxies to 2000 or lower on such EX-Ports before downgrading."
REMOVE_CREDITRECOVERY_CONFIGURATION="Downgrade is not allowed because one or more ports have credit recovery enabled.Please use \"portcfgcreditrecovery --disable\" command to disabled credit recovery." 
DUPLICATE_SWITCHNAME="Firmwaredownload is not allowed since duplicate switch names are detected for the Logical Switches. Please use \"switchname\" command to configure unique switch names before performing firmware download."
FEC_ACTIVE="Please use \"portcfgfec --disable\" command to disable the FEC feature of the F-Ports before performing firmwaredownload."
CR_ACTIVE="Please use \"portcfgcreditrecovery --disable\" command to disable the CR feature of the F-Ports before performing firmwaredownload."
AUTO_CSCTL_ACTIVE="Auto CSCTL feature is enabled. If you are downgrading the firmware, please disable the auto csctl mode using\"configurechassis\" command and following that either perform powercycle on each non-CP blades or reboot the system before performing firmwaredownload."
REMOVE_FEC_CONFIGURATION="Downgrade is not allowed because one or more ports have FEC enabled.Please use \"portcfgfec --disable\" command to disabled FEC."
MAPS_ACTIVE="WARNING: The Monitoring and Alerting Policy Suite (MAPS) is enabled. Downgrading will revert back to Fabric Watch monitoring using last known active thresholds."
SPIKE_VF_ENABLED="7800 Virtual Fabric mode is enabled in the switch and it requires version v7.1.0 or higher. Please delete all non-default logical switches and then, use the \"fosconfig --disable vf\" command to disable VF Mode and retry."
LOCATION_ID_CONFIGURED="Please use the \"configure\" command to clear the Location ID"
UNSUPPORTED_SNMP_TRAPOID="Customized SNMP trap OID configuration (snmp.trapEnterpriseFlag) is not supported from version v7.1.0."
UNSUPPORTED_SNMP_PRIVPROTOCOL="Some snmpv3 users have unsupported private protocols configured. Please use snmpconfig --default snmpv3 to make default configurations or use snmpconfig --set snmpv3 and change private protocols as DES or AES128."
BNA_UNSUPPORTED_SNMP_PRIVPROTOCOL="Some snmpv3 users have unsupported private protocols configured. 3DES, AES192, AES256 are unsupported in 7.2.0. Please default the snmp configurations or change it to DES or AES128."
UNSUPPORTED_SNMP_73_PRIV_PROTO="Some snmpv3 users have unsupported private protocols configured. Please use snmpconfig --default snmpv3 to make default configurations or use snmpconfig --set snmpv3 and change private protocols as DES or AES128 or AES256."
BNA_UNSUPPORTED_SNMP_73_PRIV_PROTO="Some snmpv3 users have unsupported private protocols configured. Please default the snmp configuration or change private protocol as DES or AES128 or AES256."
UNSUPPORTED_ICL_PORT_CONFIGURATION="Firmware upgrade to Fabric OS 7.1.0 or higher is not allowed when there are more than 4 chassis interconnected through Inter-Chassis Links (ICLs) and the Enterprise ICL (EICL) license is not installed in the system. Note that even with an EICL license installed, only 10 chassis are allowed to interconnect through ICLs. You can either install an EICL license, or you must disable the additional ICL links before performing a firmware upgrade."
ENABLE_TRUNK_CONFIGURATION="Downgrade is not allowed because switch is in AG mode and Trunking is disabled on some of the ports.\nPlease use \"portcfgshow\" to get port list and use \"portcfgtrunkport <port_no> 1\" to enable it before downgrading."
EPORT_CREDIT_FWDL_RESTRICTION="Downgrade to selected version is not allowed. Please remove E-Port Credit configuration using \"portcfgdefault\" or \"portcfgeportcredits --disable\" CLI on these ports."
SPEED_10G_PRESENT_ERROR="Downgrade is not allowed because there are few ports other than the first octet of the blade/switch configured for octet speed combo 2 or 3.\nPlease use the CLI command \"portcfgshow\" to determine the ports in question and change the octet speed combo of those ports to 1 using \"portcfgoctetspeedcombo\" CLI and change their speeds using \"portcfgspeed\" CLI."
TACACS_LEN_ERROR_MSG="Downgrade to pre-7.2 Fabric OS versions is not allowed. Please configure TACACS+ keys of length in the range (8-40) characters using aaaconfig CLI {Usage: aaaconfig --change <server> -conf tacacs+ [-s <secret>], before performing a firmware downgrade."
MAPS_ENABLED="Downgrade is not allowed because Monitoring and Alerting Policy Suite (MAPS) is enabled. Please disable MAPS using \"mapsConfig --disable\" before proceeding"
FIPS_ENABLED="Upgrade to 7.2.1 and above is not allowed because FIPS is enabled. Please upgrade to 7.2.0 first before upgrading to this version."
AUTHUTIL_CONFIGURATION_HASHSET="Downgrade is not allowed because sha256 is set as hash type for DH-CHAP/FCAP in atleast one of the logical switches,\nPlease change the configuration to sha1 in all the logical switches using authutil CLI {Usage : authutil --set -h}."
AUTHUTIL_CONFIGURATION_HASHSET_ALL="Downgrade is not allowed because sha256 is one of the configured hash types for DH-CHAP/FCAP in atleast one of the logical switches, \nPlease change the configuration to sha1 or md5 or sha1,md5 using authutil CLI {Usage : authutil --set -h} on"
HIF_MODE_CONFIGURED="Downgrade is not allowed because switch is configured with High Integrity Fabric Mode. Please use the \"configure\" command to clear the HIF mode"
HIFMODE_RESET_FAILED="Hard reseting of HIF mode Config key in the switch during firmware download failed. Please check your switch configuration"
DISC_FRM_TYPE_CONFIGURED="Downgrade is not allowed because discard frame logging is enabled for frame type other than timeout. Please disable those discard frame types first. {Usage: framelog --disable -type [du | unroute]}"
MAPS_DECOM_CONFIG_ERR="Downgrade is not allowed, because port decommmission(decom) action is enabled. Please delete decom action from the"  
MAPS_DECOM_RULES_CONFIG_ERR="Downgrade is not allowed, because port decommission(decom) action is configured in user defined rules. Please delete decom action from all user defined rules in the"
MAPS_NETMON_ENABLED="Downgrade is not allowed because FPI Monitoring is enabled in MAPS. Please disable the feature using \"mapsConfig --disableFPImon\""
INFLIGHT_ENCRYPTION_CONFIGURED="Downgrade is not allowed because in-flight encryption with FCAP protocol is not supported in target firmware. Please set DHCHAP protocol using \"authutil --set\" CLI."
MAPS_73_WARN="In MAPS, user-defined rules are present for BB_FCR_CNT, ZONE_CFGSZ_PER, LSAN_DEVCNT_PER, L2_DEVCNT_PER, ETH_MGMT_PORT_STATE, ALL_D_PORTS, ALL_2K_QSFP. These rules will not be monitored in pre-7.3 FOS version."
RFM_ECB_ENABLED="RFM+ECB configuration is present. Please deactivate ECB option and proceed with downgrade"
LFM_ENABLED="Active local flow mirror (LFM) flow with mirrorport option is present. Please deactivate this flow (flow --deact 'flowname') and proceed with downgrade"
RFM_ENABLED="Active remote flow mirror (RFM) flow with mirrorport option is present. Please deactivate this flow (flow --deact 'flowname') and proceed with downgrade"
NTP_LENGTH="Downgrade is not allowed because NTP address length is greater than 31 characters."
FECTTS_OPTION_RESTRICTION="Downgrade to selected version is not allowed because few ports are configured with FEC via TTS. Please disable FEC via TTS configuration using \"portCfgFec --disable -TTS <portno> \" CLI on the ports."
CORE_BLADE_OFF_CHECK="Downgrade to 7.2.x (or lower) is not allowed because at least one of core blades is NOT POWERED ON. Please use \"slotpoweron [slot]\" to poweron that core blade."
FCOE_BLADE_CHECK_IN_DCX_PLUTO_PLUS="FCOE blades are not supported by the target firmware. Please use slotshow to find out which slot it is in and remove it before continuing."
POD="Downgrade is not allowed because switch is in AG mode and Full POD License set(Ports on Demand license) are not installed. To proceed further with the firmwaredownload either install the POD license in the switch or disable the AG mode."
ICL_QSFP_FWDL_CHECK="Downgrade is not allowed as some of the ICL ports have connected with new QSFP which support upto 2km or Eport credit configuration is enabled. Please remove the QSFP(s) flagged and connect the old QSFP or remove the Eport credit configuration to proceed further with downgrade."
SECURITY_ATTRIB_FOR_FMS="Upgrade to 7.3 or later is prohibited with current Security Attributes in FMS Mode. Please make sure the switch is having IDID Mode, valid non-empty SCC_POLICY, fabric wide data distribution to be strict for SCC."
ERROR_FICON_MAN_CASCADING="Upgrade to 7.3 or later is not allowed as the Ficon Manual Cascading is enabled on the switch. Disable Ficon Manual Cascading feature and retry firmware download"
REMOTE_FOSEXEC_CONFIGURED="Downgrade is not allowed because the Remote Fosexec feature is configured on the switch. Please use the \"configure\" command to disable Remote Fosexec mode on"
BNA_REMOTE_FOSEXEC_CONFIGURED="Downgrade is not allowed because the Remote Fosexec feature is configured on the switch. Please use the \"configure\" command to disable Remote Fosexec mode on"
MAPS_BASE_POLICY_FIDS_ERR="MAPS is enabled with default base policy. Since pre-7.4 does not have the base policy, the downgrade has been blocked. Please use 'mapspolicy --enable' and enable a different default policy or a custom policy in"
MIGRATE_TO_MAPS_WARN_MSG="WARNING: Fabric Watch is discontinued in FOS 7.4 and will not run after firmware upgrade. To continue with monitoring capability, it is recommended to migrate to MAPS prior to firmware upgrade. Users can convert existing Fabric Watch thresholds into MAPS policies by using \"mapsConfig --fwconvert\" CLI command and continue monitoring with the same settings. Fabric Watch thresholds cannot be converted to MAPS policies after firmware upgrade. Please refer to MAPS Administrator's Guide for further information."
MAPS_PT_CONFIG_ERR="Downgrade is not allowed, because port toggle action is enabled. Please use 'mapsconfig --actions' command to delete this action in"  
MAPS_FMS_CONFIG_ERR="Downgrade is not allowed, because FMS action is enabled. Please use 'mapsconfig --actions' command to delete this action in"  
MAPS_SDDQ_CONFIG_ERR="Downgrade is not allowed, because SDDQ action is enabled. Please use 'mapsconfig --actions' command to delete this action in"
MAPS_PT_RULES_CONFIG_ERR="Downgrade is not allowed, because port toggle action is configured in user defined rules. Please delete this action from all user defined rules present in the"
MAPS_SDDQ_RULES_CONFIG_ERR="Downgrade is not allowed, because SDDQ action is configured in user defined rules. Please delete this action from all user defined rules present in the"
MAPS_FMS_RULES_CONFIG_ERR="Downgrade is not allowed, because FMS action is configured in user defined rules. Please delete this action from all user defined rules present in the"
MAPS_74_WARN="In MAPS, user-defined rules are present for IO_LATENCY_CLEAR ALL_CIRCUIT_HIGH_QOS, ALL_CIRCUIT_MED_QOS, ALL_CIRCUIT_LOW_QOS and ALL_CIRCUIT_F_QOS DEV_NPIV_LOGINS monitoring. These rules will not be monitored in pre-7.4 FOS version."
PEER_ZONE_CONFIGURED="WARNING: You are downgrading to a version of Fabric OS that does not support Peer Zoning.  The zone configuration contains Peer Zones that will be treated as regular zones after downgrade."
HIF_FICON_WARNING_1="WARNING: IDID and SCC strict policy are active, however FMS Mode is not enabled.\nEnable High Integrity Fabric (HIF) Mode for FICON functionality on the following FID(s):"
HIF_FICON_WARNING_2=".\nHigh Integrity Fabric is required for FICON channels to initialize at FOS v7.3 and above."
AVQ_DEVICE_EXIST="Downgrade is not allowed since the fabric contains VC Quarantined Slow Drain Devices."
APM_CONFIG_EXIST="Advanced Performance Monitoring (APM) is obsoleted in FOS v7.4. Please remove all APM monitors if installed on all the logical switches prior to upgrade. Please use commands perfDelEEMonitor, fmMonitor --delmonitor, perfTTmon --delete to remove all End-to-End monitors, Frame monitors and Top talker monitors respectively. Flow Vision provides the same functionality in FOS v7.4. Please refer Flow Vision Administrator's guide for further information."
UNSUPPORTED_SECURE_SYSLOG="You are downgrading to a version of Fabric OS that does not support secure syslog. Please disable the secure server configuration using \"syslogadmin --remove -ip\" CLI to proceed further."
UNSUPPORTED_DOWNGRADE_TIMEZONE="Downgrade is not allowed because configured timezone is not supported in the firmware being downloaded. Please change the configuration using \"tstimezone --interactive\" or \"tstimezone <timezonename>\" and try again."
AE_PORTS_EXISTS="Downgrade is not allowed because one or more ports are connected to \"Brocade Analytics Monitoring Platform\". Please use \"switchshow\" to view the list of AE_Port(s) and disable them using \"portdisable [slot\]port\" to proceed with the downgrade."
INVALID_MAPSRULES="There's no timebase for the above MAPS rule(s).  Please use \"mapsrule --config <rulename> -timebase  <timebase>\" command to correct the same."
MAPS_PS_RULE_DELETION="WARNING: MAPS rules defCHASSISBAD_PWR_MARG, defCHASSISBAD_PWR_CRIT, defCHASSISBAD_FAN_MARG & defCHASSISBAD_FAN_CRIT will be deleted and the same will be removed from all associated MAPS policies.\n"
#######################################################
### The messages are for firmwarerestore from BNA.	###
#######################################################
BNA_FWDL_RUNNING_MSG="Firmware download or firmware commit is already running. Please wait for it to complete first."
BNA_FWRESTORE_DISALLOWED_MSG="No need to run firmware restore because firmware has already been committed, or there is no firmware download performed."
BNA_FWRESTORE_VER_DISALLOWED_MSG="Firmware restore from v6.3.x to v6.1.2_cee is not supported. Please run firmware commit first and then download the new firmware."
###################################################
###################################################
####                                           ####
####                                           ####
####     PRESINSTALL MESSAGES SECTION FOR BNA  ####
####    -------------------------------------  ####
####                                           ####
###################################################
###################################################
BNA_SCIMITARMSG="The FA4-18 (type 33) blade is not supported by the target firmware. Please use Element Manager to find out which slot it is in and remove it first."
BNA_XENONMSG="The FC10-6 (type 39) blade is not supported by the target firmware. Please use Element Manager to find out which slot it is in and remove it first."
BNA_QUATTROMSG="The FC8-64 (type 77) blade is not supported by the target firmware. Please use Element Manager to find out which slot it is in and remove it first. For a VF enabled switch, use Logical Switches to move all vacant ports in this slot to the default after removing the blade."
BNA_UNSUPPORTED_DL_VERMSG="Cannot downgrade to 7.1 or lower. Please downgrade to 7.2 first and then download the desired firmware version."
BNA_UNSUPPORTED_UP_VERMSG="Cannot upgrade directly to 7.4. Please upgrade to 7.2 first and then upgrade to 7.4."
BNA_UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL="Non disruptive firmware download is not supported when firmware download with two versions apart. Please try to use Element Manager with single mode option enabled."
BNA_UNSUPPORTED_AUTOREBOOT_OPT_WARN_MSG="auto reboot option is not allowed with single mode when upgrade from 6.3 to 7.0. Please make sure that auto-reboot is not enabled before proceeding."
BNA_UNSUPPORTEDPLATFORMMSG="Cannot download the requested firmware because the firmware doesn't support this platform. Please select another firmware."
BNA_SWITCH_FAULTY_MSG="Firmwaredownload is not allowed since the switchState is Faulty. Please recover the switch before proceeding."
BNA_UNSUPPORTED_EEMON_ON_DOWNGRADE="Downgrade is not allowed when end to end monitors are installed in AG. Please clear the end to end monitors installed before downgrading."
BNA_UNSUPPORTED_FMON_ON_DOWNGRADE="Downgrade is not allowed when frame monitors are installed in AG. Please clear the frame monitors installed before downgrading."
BNA_UNSUPPORTED_LICENSES_ON_DOWNGRADE="Downgrade is not allowed because enhanced licenses are installed. Please use the Element Manager to remove them before downgrading."
BNA_UNSUPPORTED_STATICFPORTS_CONFIG_ON_DOWNGRADE="Downgrade is not allowed because static F-ports are configured. Please use the Element manager to check for static F-ports and delete the static mapping before downgrading."
BNA_UDROLE_FWDL_DISALLOWED_MSG="Downgrade is not allowed because user-defined roles are present. Please use the Element Manager to check all the UD Roles and to check if any users assigned these roles. If there are such users, assign them default roles or delete them. Then remove the UD Roles." 
BNA_UNSUPPORTED_ZONE_SIZE="Downgrade is not allowed because the existing zone configuration is more than 1 MB. To downgrade to lower firmware version modify the existing zone configuration to 1 MB or less."
BNA_PORTNAME_LEN_DISALLOWED_MSG="Downgrade is not allowed because one or more port names are greater than 32 characters. Please check and fix the port name/length before downgrading." 
BNA_PORTSPEED_DISALLOWED_MSG="Downgrade is not allowed because one or more ports have speed configured as 10G/16G speed. Please remove unsupported blades CR8510(4)-16/CR8510-16 if present and use the Element Manager to change the speed before downgrading." 
BNA_PAD_FEATURE_CHECK_MSG="Downgrade is not allowed because for one or more ports Port Auto Disable (PAD) is enabled with no options configured. Use Port Auto Disable to disable PAD for those ports first." 
BNA_CONDOR3_BLADE_IS_PRESENT="FC16-32, FC16-48, CR8510(4)-16, and CR8510(8)-16 are not supported by the targeted firmware. Please use Element Manager to determine which of these are installed and remove them before continuing."
BNA_UNSUPPORTED_ENCRYPTION_VERSIONING_DEC="Downgrade is not allowed because Device decommission feature is in use. Please disable Device decommission. Make sure that there is no lun undergoing decommission, or is in failed state." 
BNA_FCOE_PROVISION_CONFIG_MSG="With the current upgrade/downgrade, the CEE start up configuration dcf.conf file will be incompatible with FCoE provisioning changes as part of this build. CEE start up configuration file, dcf.conf can be backed up for future use. The user can save the configuration as backup and apply it once upgrade/downgrade is complete, to restore the switch configuration in its respective build version. If you wish to save the configuration file please abort firmware download and save the configuration file before proceeding."
BNA_UNSUPPORTED_INTEROP_MODE="Upgrade to 7.0 or above is not allowed when interop mode is enabled. To upgrade, please disable interop mode." 
BNA_XFCIP_FEATURE_RESTRICTION="Downgrade is not allowed because some FCIP features are enabled and are not supported on the selected version. Please address these unsupported features before downgrading."
BNA_CONDOR_EX_PORT_RESTRICTION="Downgrade to selected version is not allowed because EX-Ports are configured on FR4-18i blade(s). Please use the Element Manager to remove EX-port configuration on the ports." 
BNA_McDATA_EX_PORT_RESTRICTION="Upgrade to selected version is not allowed because Ex or VEx Ports are configured in McData/Open interop mode. Please disable McData interop mode configuration using the Element Manager." 
BNA_NOS_EX_PORT_RESTRICTION="Downgrade to selected version is not allowed because EX-Ports are configured in Brocade NOS Interop mode. Please use the Element Manager to remove EX-port configuration on the ports." 
BNA_UNSUPPORTED_VEPORT_THRESHOLD_CONFIG="Downgrade is not allowed because high/low threshold for VE-Port on the switch(s) is configured to decimal value. Use the Element Manager to configure the threshold to an integer value and downgrade."
BNA_UNSUPPORTED_MULTIPLE_EMAIL_FW_ALERT="Downgrade is not allowed because Multiple recipient addresses might have been configured on any of the logical switches for any of the class to receive Fabric Watch email alerts. Please use the "fwMailCfg" CLI command to configure single recipient address before downgrading."
BNA_UNSUPPORTED_BRCD_CERTIFICATE_DATABASE_VALUE="Downgrade to 7.0 is not allowed because either 1) FCAP authentication to one of the neighboring switches is configured to use Brocade issued certificates, or 2) Brocade Certificate files exist. Please remove or set the configuration to thirdparty and delete certificate files using \"pkiremove\" before upgrading."
BNA_CHECK_LDAP_CONFIGURED_OVER_IPv6="Downgrade is not allowed because IPv6 configuration for LDAP is in use. Please use the Element Manager to remove all the IPv6 configuration for LDAP before downgrading."
BNA_UNSUPPORTED_IPFILTER_POLICY="Downgrade is not allowed because IPFILTER forwarding rule(s) is enabled. Please use the Element Manager to delete the FORWARD rule(s) from IPFILTER policy before downgrading." 
BNA_MARATHON_STRIKER_ERR_MSG="Firmware migration is not allowed since the FX8-24 and FR4-18i blades are both present.\nPlease remove the FR4-18i blades before proceeding with the firmware load."
BNA_MARATHON_STRIKER_WARN_MSG="After the firmware migration has completed, the FR4-18i blade(s) needs to be removed if the FX8-24 blade(s) is to be plugged into the chassis."
BNA_UNSUPPORTED_FWCONFIGURE1="Upgrade to 7.0 or above is not allowed because the threshold configuration changed alarm is set."
BNA_UNSUPPORTED_FWCONFIGURE2="Similar configuration may exist for other classes and areas and on other FIDs. Please unset the same." 
BNA_UNSUPPORTED_CHECK_SECOND_TIMEBASE1="Upgrade is not allowed because timebase is configured as seconds."
BNA_UNSUPPORTED_CHECK_SECOND_TIMEBASE2="Similar configurations may exist for other classes and areas and on other FIDs. Please use the Element Manager to configure the timebase to other unit and upgrade." 
BNA_UNSUPPORTED_TSTIMEZONE="Downgrade is not allowed because tstimezone is configured with three sections input. Please change the configuration with two sections and proceed." 
BNA_VPWWN_CONFIGURED="Downgrade is not allowed because Fabric Assigned PWWN is configured in one or more partitions. Please delete all the Fabric Assigned PWWN configurations before downgrading."  
BNA_VE_AS_XISL_CONFIGURED="Downgrade is not allowed, as there is a VE Port in the Base switch that could be used as an XISL and there is at least one logical switch with \"ALLOW XISL Use\" enabled. Either remove all VE Ports from the Base switch or disable XISL use in all logical switches and repeat the downgrade attempt."
BNA_BASE_SW_CONFIGURED="Downgrade from 7.4 is not allowed with Base Switch enabled. Please disable Base Switch and try."
BNA_FCIP_LS_WITH_XISL_ON="Downgrade is not allowed, as there is a VE Port in a logical switch that has \"ALLOW XISL Use\" enabled.  Please disable \"ALLOW XISL Use\" in all logical switches that include VE ports, and retry the downgrade attempt."
BNA_UNSUPPORTED_RRDY_BASE_SWITCH="Upgrade to 7.0 or above is not allowed since base switch has R_RDY enabled ports. Please disable the R_RDY enabled ports in base switch." 
BNA_UNSUPPORTED_IODDELAY_ON_UPGRADE="Upgrade to 7.0 or above is not allowed due to the presence of iod delay configuration. Please reset the feature with the CLI command \"ioddelayreset\" before upgrading to v7.0."
BNA_FCFW_NOT_SUPPORTED="Upgrade to 7.0 or above is not allowed because FC Fastwrite is not supported on this version. Please use the Element Manager to deconfigure FC Fastwrite for all slots and try again. "
BNA_BSTR_NOT_SUPPORTED="Upgrade to 7.0 or above is not allowed because TCP Byte Streaming is not supported on this version. Please use FCIP Tunnels to deconfigure TCP Byte Streaming for all tunnels and try again." 
BNA_UNSUPPORTED_DUP_PORT_WWN="Upgrade to 7.0 or above is not allowed because duplicate PWWN devices are detected in one or more partitions. Please configure the devices with unique PWWNs or disable the ports and remove the devices with duplicate PWWNs before upgrading the firmware." 
BNA_SERDES_TUNE_ENABLED="Downgrade is not allowed because FC8-16 serdestune mode is enabled. Please use the CLI command \"serdestunemode --show\" to view the mode and \"serdestunemode --reset\" to disable the feature before downgrading." 
BNA_ENHANCED_FC8_BLADE_IS_PRESENT="FC8-32E and FC8-48E are not supported by the targeted firmware. Please use Element Manager to determine which of these are installed and remove them before continuing." 
BNA_UNSUPPORTED_DBR_ON_DOWNGRADE="Downgrade is not allowed because Device Based Routing is configured. Please use the Element Manager to change the routing policy." 
BNA_FC8_BLADE_IS_PRESENT="FC8-16, FC8-32 and FC8-48 are not supported by the targeted firmware. Please use Element Manager to determine which of these are installed and remove them before continuing."
BNA_D_PORT_R_RDY_NOT_SUPPORTED="Downgrade is not allowed because R-RDY flow control ports are configured as D-Ports. Please use the Element Manager to disable these D-Ports before downgrading." 
BNA_D_PORT_DWDM_NOT_SUPPORTED="Downgrade is not allowed because D-Port is configured with DWDM mode. Please use \"portcfgshow\" to view the port list and \"portdisable [slot/]port; portcfgdport --disable -dwdm [slot/]port\" to reset DWDM mode before downgrading."
BNA_DIAGPOST_SKIP_MSG="Firmware download is not allowed because diagpost is enabled. Please use the CLI command \"diagpost --disable\" command to disable diagpost."
BNA_MAPS_ACTIVE="WARNING: The Monitoring and Alerting Policy Suite (MAPS) is enabled. Downgrading will revert back to Fabric Watch monitoring using last known active thresholds."
BNA_LOCATION_ID_CONFIGURED="Please use the \"configure\" command to clear the Location ID"
BNA_DOWNGDAOQ_SAO_REQ="Downgrade is not allowed as AoQ is active on server or HBA ports without Server Application Optimization license. To proceed further with downgrade either install Server Application Optimization license, or set QoS mode on AoQ enabled ports to OFF if it is ON/AE and then toggle these AoQ enabled ports to disable AoQ. Please use \"switchshow\" to view list of F_Port with AoQ feature enabled and use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF. To toggle the ports use \"portdisable [slot/]port and portenable [slot/]port\"."
BNA_DOWNGDAOQ_AN_REQ="Downgrade is not allowed as AoQ is active on device ports without Adaptive Networking license. To proceed further with downgrade either install Adaptive Networking license, or set QoS mode on AoQ enabled ports to OFF if it is ON/AE and then toggle these AoQ enabled ports to disable AoQ. Please use \"switchshow\" to view list of F_Port with AoQ feature enabled and use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF. To toggle the ports use \"portdisable [slot/]port and portenable [slot/]port\"."
BNA_DOWNGDAOQ_AN_SAO_REQ="Downgrade is not allowed as AoQ is active on server or HBA ports without Server Application Optimization license and Adaptive Networking license. To proceed further with downgrade either install Server Application Optimization license and Adaptive Networking license, or set QoS mode on AoQ enabled ports to OFF if it is ON/AE and then toggle these AoQ enabled ports to disable AoQ. Please use \"switchshow\" to view list of F_Port with AoQ feature enabled and use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF. To toggle the ports use \"portdisable [slot/]port and portenable [slot/]port\"."
BNA_DOWNGDQOS_AN_REQ_MSG1="Downgrade is not allowed as QoS mode is enabled (ON) on some of the ports and there is no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license, or set QoS mode to OFF/AE. Please use \"portcfgqos --disable [slot/]port\" to set QoS mode on these ports to OFF or use \"portcfgqos --default [slot/]port\" to set QoS mode on these ports to AE"
BNA_DOWNGDCSCTL_AN_REQ="Downgrade is not allowed as CSCTL mode is enabled (ON) on some of the ports and there is no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license, or set CSCTL mode to OFF. Please use \"portcfgqos --disable [slot/]port csctl_mode\" to set CSCTL mode on these ports to OFF."
BNA_DOWNGDRATELIMIT_AN_REQ="Downgrade is not allowed as Rate Limit is enabled (ON) on some of the ports and there is no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license, or reset Rate Limit to OFF. Please use \"portcfgqos --resetratelimit [slot/]port\" to reset Rate Limit on these ports to OFF."
BNA_DOWNGDQOS_AN_REQ_MSG3="Downgrade is not allowed as QoS is active on E_Port(s) with no Adaptive Networking license installed on the switch. To proceed further with downgrade either install Adaptive Networking license on the switch, or turn OFF QoS on these ports. Please use \"islshow\" to view the list of E_Port(s) with QoS. In case these E_Port(s) are trunked, use \"trunkShow\" to list all the ports in the trunk group. Finally, use \"portcfgqos --disable [slot/]port\" to disable QoS on the ports."
BNA_DEFAULT_QOS_WARN_MSG="This action will set default QoS port configuration from AE to OFF."
BNA_SPIKE_VF_ENABLED="7800 Virtual Fabric mode is enabled in the switch and it requires version v7.1.0 or higher. Please delete all non-default logical switches and then disable VF Mode on the switch and retry the firmware downgrade."
BNA_UNSUPPORTED_ICL_PORT_CONFIGURATION="Firmware upgrade to Fabric OS 7.1.0 or higher is not allowed when there are more than 4 chassis interconnected through Inter-Chassis Links (ICLs) and the Enterprise ICL (EICL) license is not installed in the system. Note that even with an EICL license installed, only 10 chassis are allowed to interconnect through ICLs. You can either install an EICL license, or you must disable the additional ICL links before performing a firmware upgrade."
BNA_10G_SPEED_PRESENT_ERROR="Downgrade is not allowed because there are few ports other than the first octet of the blade/switch configured for octet speed combo 2 or 3.\nPlease change the octet speed combo of those ports to 1 using Web Tools->Port Admin->Speed Combination and change their speeds using Web Tools-> Port Admin->Edit->Specify FC Parameters"
BNA_MAPS_ENABLED="Downgrade is not allowed because Monitoring and Alerting Policy Suite (MAPS) is enabled.  Please disable MAPS before proceeding"
SIM_PORT_ENABLED="Firmware download is not allowed because SIM ports are configured on one or more switches.Please use  \"flow --control -simport [SlotNumber/]PortNumber -disable\" command to disable SIM port configuration."
BNA_FIPS_ENABLED="Upgrade to 7.2.1 and above is not allowed because FIPS is enabled. Please upgrade to 7.2.0 first before upgrading to this version."
UNSUPPORTED_DOWNGRADE_721="v7.2.1 FIPS compliant parameters are configured.Please use \"fipscfg --disable dh \" and \"fipscfg --disable sha256 \" before downgrading."
BNA_HIF_MODE_CONFIGURED="Downgrade is not allowed because switch is configured with High Integrity Fabric Mode. Please use the \"configure\" command to clear the HIF mode"
NPIV_BASE_LOGO_CONFIGURED="Downgrade is not allowed because 'NPIV FLOGI device logout' is enabled on port(s) in one or more partitions. Please remove the configurations with 'portcfgflogilogout' before downgrading."
AUTO_MAX_SPEED_CONFIGURED="Downgrade is not allowed because 'Auto negotiation maximum speed' is configured in one or more ports. Please remove the configurations using CLI \"portcfgspeed <slot>/<port> 0\" before downgrading."
BNA_DISC_FRM_TYPE_CONFIGURED="Downgrade is not allowed because discard frame logging is enabled for frame type other than timeout. Please disable those discard frame types first. {Usage: framelog --disable -type [du | unroute]}"
BNA_MAPS_73_WARN="In MAPS, user-defined rules are present for BB_FCR_CNT, ZONE_CFGSZ_PER, LSAN_DEVCNT_PER, L2_DEVCNT_PER, ETH_MGMT_PORT_STATE, ALL_D_PORTS, ALL_2K_QSFP. These rules will not be monitored in pre-7.3 FOS version."
BNA_MAPS_74_NEW_ACTIONS="Downgrade is not allowed, because port toggle, SDDQ, FMS actions are configured in user defined rules. Please delete these actions from all user defined rules"

BNA_SECURITY_ATTRIB_FOR_FMS="Upgrade to 7.3 or later is prohibited with current Security Attributes in FMS Mode. Please make sure the switch is having IDID Mode, valid non-empty SCC_POLICY, fabric wide data distribution to be strict for SCC."
BNA_MAPS_NETMON_ENABLED="Downgrade is not allowed because FPI Monitoring is enabled in MAPS. Please disable FPI Monitoring through CLI using the command mapsConfig --disableFPImon and try again."
BNA_ERROR_FICON_MAN_CASCADING="Upgrade to 7.3 or later is not allowed as the Ficon Manual Cascading is enabled on the switch. Disable Ficon Manual Cascading feature and retry firmware download"
UNSUPPORTED_DOWNGRADE="Downgrade not allowed as the configured ciphers are not the default one. Please confirm or configure the ciphers for HTTPS using \"cipherconfig --default -type https\" on"
UNSUPPORTED_UPGRADE="Upgrade not allowed as the configured ciphers are not the default one. Please confirm or configure the ciphers for HTTPS using \"cipherconfig --default -type https\" on"
BNA_UNSUPPORTED_EMBD_DL_VERMSG="Cannot downgrade to 7.0 or lower. Please downgrade to 7.2 first and then download the desired firmware version."
BNA_UNSUPPORTED_EMBD_UP_VERMSG="Cannot upgrade directly to 7.3. Please upgrade to 7.2 first and then upgrade to 7.3."
BNA_UNSUPPORTED_72_TO_74_FWDL="Upgrade from v7.2 to v7.4.1d and higher is not supported. Please upgrade to 7.3 first and then upgrade to 7.4."
BNA_MIGRATE_TO_MAPS_WARN_MSG="WARNING: Fabric Watch is deprecated in FOS 7.4.  In FOS7.4, use MAPS to monitor the switch. To use existing Fabric Watch configurations after upgrade, convert the FW configuration into MAPS policies. Please refer to MAPS administration documents for further information.\n"
BNA_MAPS_BASE_POLICY_FIDS_ERR="MAPS is enabled with default base policy. Since pre-7.4 does not have the base policy, the downgrade has been blocked. Please enable a different default policy or custom policy in"
BNA_MAPS_74_WARN="In MAPS, user-defined rules are present for IO_LATENCY_CLEAR ALL_CIRCUIT_HIGH_QOS, ALL_CIRCUIT_MED_QOS, ALL_CIRCUIT_LOW_QOS and ALL_CIRCUIT_F_QOS DEV_NPIV_LOGINS monitoring. These rules will not be monitored in pre-7.4 FOS version."
BNA_MAPS_PT_CONFIG_ERR="Downgrade is not allowed because port toggle action is enabled. Please use MAPS Policy Actions dialog to disable this action in"
BNA_MAPS_SDDQ_CONFIG_ERR="Downgrade is not allowed because SDDQ action is enabled.Please use MAPS Policy Actions dialog to disable this action in"
BNA_MAPS_FMS_CONFIG_ERR="Downgrade is not allowed because FMS action is enabled.Please use MAPS Policy Actions dialog to disable this action in"
BNA_MAPS_PT_RULES_CONFIG_ERR="Downgrade is not allowed, because port toggling action is configured in user defined rules. Please use MAPS Policy Actions dialog to delete this action from all user defined rules in"
BNA_MAPS_SDDQ_RULES_CONFIG_ERR="Downgrade is not allowed, because SDDQ action is configured in user defined rules. Please use MAPS Policy Actions dialog to delete this action from all user defined rules in"
BNA_MAPS_FMS_RULES_CONFIG_ERR="Downgrade is not allowed, because FMS action is configured in user defined rules. Please use MAPS Policy Actions dialog to delete this action from all user defined rules in"
BNA_AVQ_DEVICE_EXIST="Downgrade is not allowed since the fabric contains VC Quarantined Slow Drain Devices."
IOANALYZER_ENABLED="Downgrade is not allowed on this platform"
BNA_APM_CONFIG_EXIST="Advanced Performance Monitoring (APM) is obsoleted in FOS v7.4. Please remove all APM monitors if installed on all the logical switches prior to upgrade. Please use commands perfDelEEMonitor, fmMonitor --delmonitor, perfTTmon --delete to remove all End-to-End monitors, Frame monitors and Top talker monitors respectively. Flow Vision provides the same functionality in FOS v7.4. Please refer Flow Vision Administrator's guide for further information."
BNA_UNSUPPORTED_SECURE_SYSLOG="You are downgrading to a version of Fabric OS that does not support secure syslog. Please disable the secure server configuration using \"syslogadmin\" CLI to proceed further."
UNSUPPORTED_RADIUS_ENCRYPTION="Downgrade is not allowed since base switch has RADIUS configurations with encryption ON. Please remove RADIUS configurations or set the encryption level NONE to proceed."
BNA_AE_PORTS_EXISTS="Downgrade is not allowed because one or more ports are connected to \"Brocade Analytics Monitoring Platform\". Please use \"switchshow\" to view the list of AE_Port(s) and disable them using \"portdisable [slot\]port\" to proceed with the downgrade."
BNA_INVALID_MAPSRULES="There's no timebase for the above MAPS rule(s).  Please correct the same."
BNA_MAPS_PS_RULE_DELETION="WARNING: MAPS rules defCHASSISBAD_PWR_MARG, defCHASSISBAD_PWR_CRITdefCHASSISBAD_FAN_MARG & defCHASSISBAD_FAN_CRIT will be deleted and the same will be removed from all associated MAPS policies.\n"
ERROR_24_BIT_LICENSES="Upgrade of FOS is not possible due to an invalid license key.  Please contact your reseller."
BNA_ERROR_24_BIT_LICENSES="Upgrade of FOS is not possible due to an invalid license key.  Please contact your reseller."
#######################################################
###################################################
###################################################
####                                           ####
####                                           ####
####       PRESINSTALL CHECK SECTION           ####
####    ------------------------------         ####
####                                           ####
###################################################
###################################################


correcthost() {
    if [ $ACTIVECP ]; then
	"$@"
    else
	/usr/bin/rsh -n $(otherhost) ROLE_ID=root LOGIN_ID=root CURRENT_AD=0 "$@"
    fi
}

#
# both Active and Standby have the information of
# VF and logical switches configured.
#
# VF case: on Standby CP, in order to login to each logical switch, 
# we need to set CHASSIS_ROLEID FABOS_SWITCHNO CURRENT_VF in rsh.
#
correcthost_to_curr_vfid() {
	if [ $ACTIVECP ] ; then
		# for_all_context already did "context_switch --switch vfid"
		"$@"
	else
		if [ $VF_ENABLED -eq $STS_OK ]; then
			# VF disabled
			/usr/bin/rsh -n $(otherhost) ROLE_ID=root LOGIN_ID=root CURRENT_AD=0 "$@"
		else
			# VF enabled, for_all_context changed glb_ls_id and glb_vf_id to each logical switch's
			/usr/bin/rsh -n $(otherhost) ROLE_ID=root LOGIN_ID=root CHASSIS_ROLEID=0 FABOS_SWITCHNO=$glb_ls_id CURRENT_VF=$glb_vf_id CURRENT_AD=0 "$@"
		fi
	fi
}

# 7800/FX8-24
# executes the provided function in the context of all configured virtual
# fabrics, and logical switches on the active and standby CP's to determine
# if a critera is met
correcthost_all_vfs() {
	if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF is enabled
		if [ $ACTIVECP ] ; then
			for_all_contexts correcthost_to_curr_vfid $@
		else
			# this is the standby cp, examine the configuration of the
			# active cp
			for_all_contexts_standby correcthost_to_curr_vfid $@
		fi
	else
		correcthost_to_curr_vfid $@
	fi
	if [ $? -eq 0 ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#
# chassisopt
#
# Retrieve the current chassisconfig option.
#
chassisopt() {
	sed -n -e 's/^Cur.\+on: \([[:digit:]]\{1,\}\).*$/\1/gp'
}

#
# marathon_present
#
# Check whether there are any marathon blades enabled in the system.
#
marathon_present() {

	MARATHON=$(/fabos/cliexec/slotshow | grep " 24 " | wc -l)
	return $MARATHON
}

#
# scimitar_present
#
# Check whether there are any marathon blades enabled in the system.
#
scimitar_present() {

	SCIMITAR=$(/fabos/cliexec/slotshow | grep " 33 " | wc -l)
	return $SCIMITAR
}

#
# xenon_present
#
# Check whether there are any marathon blades enabled in the system.
#
xenon_present() {

	XENON=$(/fabos/cliexec/slotshow | grep " 39 " | wc -l)
	return $XENON
}

#
# lance_present
#
# Check whether there are any lance blades enabled in the system.
#
lance_present() {

	LANCE=$(/fabos/cliexec/slotshow | grep " 43 " | wc -l)
	return $LANCE
}

#
# mace_present
#
# Check whether there are any mace blades enabled in the system.
#
mace_present() {

	MACE=$(/fabos/cliexec/slotshow -d576 | grep " 42 " | wc -l)
	return $MACE
}

#
# europa_present
#
# Check whether there are any europa blades enabled in the system.
#
europa_present() {

	EUROPA=$(/fabos/cliexec/slotshow -d576 | grep " 74 " | wc -l)
	return $EUROPA
}

#
# striker_present
#
# Check whether there are any striker blades enabled in the system.
#
striker_present() {

    STRIKER=$(/fabos/cliexec/slotshow -d576 | grep " 75 " | wc -l)
    return $STRIKER
}

#
# quattro_present
#
# Check whether there are any quattro blades enabled in the system.
#
quattro_present() {

    QUATTRO=$(/fabos/cliexec/slotshow -d576 | grep " 77 " | wc -l)
    return $QUATTRO
}

#
# pluto_chassis
#
# Check whether there are any zontron blades enabled in the system.
#
pluto_chassis() {

    	case ${SWBD##SWBD} in
        '77')
		return $STS_ERR
		;;
	*)
	        return $STS_OK
		;;
	esac
}


#
# Routing policy
#
# Check what routing policy it is.
#
routing_policy() {
	/fabos/sbin/aptpolicy | sed -n -e 's/^ Cur.\+Policy: \([[:digit:]]\{1,\}\).*$/\1/gp'
}

#
# check_ag_staticfports
# Check whether static F-ports configured or not
#

check_ag_staticfports() {

ag_mode=`/fabos/bin/ag --modeshow | grep -c "NOT enabled"`
if [ $ag_mode -eq 0 ]; then
	num_nsfports=`CONFIGSHOW | grep "ag.port.nsfporttopo." | wc -l`
	CONFIGSHOW | grep "ag.port.nsfporttopo." > /tmp/tmp_sfport.log

	staticflag=0
	nsfpt_pno=0
	while [ "$nsfpt_pno" -lt "$num_nsfports" ]
	do
		keyisthere=0
		keyisthere=`grep -wc "ag.port.nsfporttopo.$nsfpt_pno" /tmp/tmp_sfport.log`
		if [ "$keyisthere" -eq "1" ]; then

			left=`grep -w "ag.port.nsfporttopo.$nsfpt_pno" /tmp/tmp_sfport.log | cut -d : -f 2 |
			cut -d , -f 1 | grep -c "0x00000000"`
			right=`grep -w "ag.port.nsfporttopo.$nsfpt_pno" /tmp/tmp_sfport.log | cut -d : -f 2 |
			cut -d , -f 2 | grep -c "0x00000000"`
			other=`grep -wc "ag.port.nsfporttopo.$nsfpt_pno:0x0" /tmp/tmp_sfport.log`

			if [ "$other" -eq "0" ]; then
				
				if [ "$left" -eq "0" -o "$right" -eq "0" ]; then
					staticflag=1;
					break;
				fi

			fi

		fi
		nsfpt_pno=`/usr/bin/expr $nsfpt_pno + 1`
	done

    /bin/rm -f /tmp/tmp_sfport.log

	if [ "$staticflag" -eq "1" ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
fi

}

#
# check_ag_eemon_installed
# Check whether end to end monitors are installed in AG mode
#

check_ag_eemon_installed() {
	
    ag_mode=`/fabos/bin/ag --modeshow | grep -c "NOT enabled"`
    if [ $ag_mode -eq 0 ]; then
        eemon_count=`/fabos/link_bin/perfResourceShow --eeRes | grep "EEMON" | grep -c "[1-9]  |"`
        if [ $eemon_count -eq 0 ]; then
            return $STS_OK
        else
            return $STS_ERR
        fi
    fi
}
 
#
# check_ag_fmon_installed
# Check whether frame monitors are installed in AG mode
#

check_ag_fmon_installed() {
	
    ag_mode=`/fabos/bin/ag --modeshow | grep -c "NOT enabled"`
    if [ $ag_mode -eq 0 ]; then
        count=`/fabos/link_bin/fmMonitor --show -all | awk '{print $1}' | grep -c "[0-9]|"`
        if [ $count -eq 0 ]; then
            return $STS_OK
        else
            return $STS_ERR
        fi
    fi
}

#
# check_enhanced_licenses_installed
# Check whether any enhanced licenses are installed
#

check_enhanced_licenses_installed() {
	
    enh_licenses_installed=`/fabos/bin/licenseshow | grep -c "Feature name:"`
    if [ $enh_licenses_installed -eq 0 ]; then
        return $STS_OK
    else
        return $STS_ERR
    fi
}

#
# auto_csctl_enabled
#
# Check whether the switch is currently in auto csctl mode
#

auto_csctl_enabled() {

	context_switch chassis
	csctl_mode=`/fabos/cliexec/config get fos.csctlMode 2`
	return $csctl_mode
}

#
# ag_mode_enabled
#
# Check whether the switch is currently in AG mode
#
# JOE
ag_mode_enabled() {

	ag_mode=$(correcthost /fabos/link_bin/switchshow | grep -c "Access Gateway Mode")
	return $ag_mode

}

#
# check_ipfilter_forward_rule
#
# Check whether IPFILTER FORWARD rule is configured
#
check_ipfilter_forward_rule() {
	ip_forward=`/fabos/abin/ipfilter --show -a | grep -c "FWD"`
	
	if [ $ip_forward -gt 1 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

pid_format_two() {
	#
	# Block upgrade if PID format is set to 2
	#
	pid_format=`CONFIGSHOW | grep pidFormat | cut -f 2 -d ':'`
	if [ $pid_format -eq 2 ]; then
	    return $STS_ERR
	fi
	return $STS_OK
}

perf_mon_check() {

	# Run this check only on C2 and GEYE2 family of platforms.
	case ${SWBD##SWBD} in
		'71'|'62'|'66'|'64'|'77'|'42'|'72'|'73'|'75'|'67')
		#
		# Block upgrade if TT monitor are installed
		#
		CONFIGSHOW | grep "ttmonc" > /dev/null 2>&1
		rc=$?
		if [ $rc -eq 0 ]; then
			check_fcr_enabled
			if [ $? -ne $STS_OK ]; then
				return $STS_ERR
			fi
		fi
		;;
	*)
		return $STS_OK
		;;
	esac

	return $STS_OK
}

# Check if certificate is installed.
# Presence of non-zero length files under /etc/fabos/certs/sw0 directory
# implies certificate is installed on the switch.

check_nz_cert() {
   shopt -s nullglob
   for i in /etc/fabos/certs/sw0/*
   do
      [ ! -z "$i" ] && return 0
   done
      return 1
}

check_http_enabled() {
    F=/etc/fabos/fabos.0.conf

    #
    # If http.enabled is set to 1, return OK.
    #
    grep -q '^http\.enabled:1' $F  && return $STS_OK

    #
    # if certs are  not installed (chck_nz_cert == 1)
    # return error.
    #
    check_nz_cert || return $STS_ERR

    #
    # if certs are  installed but http.ssl.enabled is set to 0
    # return error.
    #
    grep -q '^http\.ssl\.enabled:0' $F && return $STS_ERR
    return $STS_OK
}


check_trunkarea_configured() {

    case $(correcthost /fabos/sbin/porttrunkarea --show enabled 2>&1) in
	("No ports have Trunk Area enabled") return $STS_OK;;
	("Error: This command is not supported in AG mode") return $STS_OK;;
	(*"No such file or directory") return $STS_OK;;
	(*) return $STS_ERR;;
	esac
}

#
# check if any TI over FCR zones are configured.
# i.e. look for a -1 or WWN in zone --show output.
# define local variable dd == 2 hex digits for ease of readability
# of the case pattern
#
check_ti_over_fcr_zone_configured() {
	local dd='[0-9a-fA-F][0-9a-fA-F]'
	local v=$(correcthost /fabos/cliexec/zone --show 2>/${NULL})
    case "$v" in
	(*$dd:$dd:$dd:$dd:$dd:$dd:$dd:$dd*) return $STS_ERR;;
	(*-1*) return $STS_ERR;;
	(*) return $STS_OK;;
	esac
}

#
# if upgrading to 6.3 make sure that
# no zones or configs are named with the msfr prefix
#
check_for_msfr_zone_names() {



	# check for msfr zone and config names
	# return good if both the zone name and config name are found
	# this is to protect agenst a Downgrade upgrade action where msfr zones
	# could be valid.  This will only throw an error if the zone name or the
	# config name match the msfr header but not both.

	if correcthost /fabos/cliexec/cfgshow | grep -q msfr_zn_; then
		if correcthost /fabos/cliexec/cfgshow | grep -q msfr_cfg_; then
			return $STS_OK
		else
			return $STS_ERR
		fi
	fi
	if correcthost /fabos/cliexec/cfgshow | grep -q msfr_cfg_; then
			return $STS_ERR
	fi

        return $STS_OK
}

im2_mode=" "
im3_mode=" "
im2_enable=0
im3_enable=0
check_interop_support() {
	# first check interop
	local tmp_mode=`CONFIGSHOW | grep switch.interopMode`
	local im_mode=${tmp_mode//[^0-9]}

	tmp_mode=`CONFIGSHOW | grep switch.mcdtFabricMode`
	local mcdt_mode=${tmp_mode//[^0-9]}

	if [ "$im_mode" == "0" ] && [ "$mcdt_mode" == "1" ]; then
		im2_enable=1
		if [ "$im2_mode" == " " ]; then
			im2_mode="$im2_mode $CURRENT_VF"
		else
			im2_mode="$im2_mode, $CURRENT_VF"
		fi
	elif [ "$im_mode" == "1" ] && [ "$mcdt_mode" == "1" ]; then
		im3_enable=1
		if [ "$im3_mode" == " " ]; then
			im3_mode="$im3_mode $CURRENT_VF"
		else
			im3_mode="$im3_mode, $CURRENT_VF"
		fi
	fi
}

check_interop_in_contexts() {
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		for_all_contexts check_interop_support
	else
		check_interop_support
	fi

	if [ "$im2_enable" == "1" ]; then
		add_err_status " * WARNING!!! McDATA Fabric mode(IM2) is enabled on the following FID(s)$im2_mode."
	fi

	if [ "$im3_enable" == "1" ]; then
		add_err_status " * WARNING!!! McDATA Open Fabric mode(IM3) is enabled on the following FID(s)$im3_mode."
	fi

	if [ "$im2_enable" == "1" ] || [ "$im3_enable" == "1" ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

check_snmp_trapEnterpriseFlag() 
{
	TRAPFLAG=`CONFIGSHOW -chassis | grep snmp.trapEnterpriseFlag: | cut -f 2 -d ':'`
	SYSOID=`CONFIGSHOW -chassis | grep sysObjectID: | cut -f 2 -d ':'`
	if [ "$TRAPFLAG" == "0" ] && [ "$SYSOID" != "1588.2.1.1.1" ]; then
		echo -e "\n$UNSUPPORTED_SNMP_TRAPOID\n"
		echo -e "$UNSUPPORTED_SNMP_TRAPOID" >> $BNA_STATUS_FILE
	fi
	return "$STS_OK"
}

check_snmp_priv_protocol()
{
	declare -a PRIVPROTO;

	PRIVPROTO=(`CONFIGSHOW -chassis | grep usmPrivProtocol: | cut -f 2 -d ':'`);

	for i in ${PRIVPROTO[@]}; do
		if [ "$i" -gt "2" ] && [ "$i" -ne "4" ]; then
			return "$STS_ERR"
		fi
	done

	return "$STS_OK"
}

# In FOS 7.3.0 version, DES/AES128/AES256 priv protocols are supported and
# 3DES/AES192 are not supported. So upgrade from v7.1.0 to v7.3.0 should be blocked 
# if any unsupported privacy protocol is configured for snmpv3 user. 
check_snmp_73_priv_proto()
{
	declare -a PRIVPROTO;

	PRIVPROTO=(`CONFIGSHOW -chassis | grep usmPrivProtocol: | cut -f 2 -d ':'`);

	for i in ${PRIVPROTO[@]}; do
		if [ "$i" -eq "3" ] || [ "$i" -eq "5" ]; then
			return "$STS_ERR"
		fi
	done

	return "$STS_OK"
}

#
#
#   If any threshold for change is configured, do not allow
#	If any changed configurations are present, 
#	check whether the value is greater than 0
#   Defect: 388296 If Switch in ag mode and if there are E-port reated configuration 
#   allow upgrade to 7.x. 
#
check_fwconfigure_change()
{
	change_conf_count=$(CONFIGSHOW | 
		grep thresh.cust | grep changed | wc -l)
	ag_enabled=$(correcthost /fabos/link_bin/switchshow | grep -c "Access Gateway Mode")
	if [ $change_conf_count -gt 0 ]; then
		CONFIGSHOW | grep thresh.cust | 
		grep "changed" | 
		while read line 
		do 
			if [ $(echo $line | cut -d: -f2) -gt 0 ]; then
				class=`echo $line | cut -d "." -f3`
				area=`echo $line | cut -d "." -f4`
				if [ $ag_enabled -eq 0 ]; then
					add_err_status "$UNSUPPORTED_FWCONFIGURE1 for class $class,	area $area on FID $CURRENT_VF." "$BNA_UNSUPPORTED_FWCONFIGURE1 for class $class, area $area on FID $CURRENT_VF."
					return $STS_ERR
				else
					if [ "$class" != "eport" ]; then
						add_err_status "$UNSUPPORTED_FWCONFIGURE1 for class $class,	area $area on FID $CURRENT_VF." "$BNA_UNSUPPORTED_FWCONFIGURE1 for class $class, area $area on FID $CURRENT_VF."
						return $STS_ERR
					fi
				fi
			else
				continue
			fi
		done
	fi
}
#
#   Check for mulitiple switches including logical switches
#
check_multi_fwconfigure_change() {


    if [ $VF_ENABLED -ne $STS_OK ]; then
		if [ $ACTIVECP ] ; then
		        for_all_contexts check_fwconfigure_change
		else
			for_all_contexts_standby check_fwconfigure_change
		fi
    else
        check_fwconfigure_change
    fi
}

#
#  Allow downgrade if the encryption feature versioning  maj.min <  downgrade maj.min
#

check_feature_enabled()
{
    feature=$1
    if [ `CONFIGSHOW | grep "$feature" |wc -l` -gt 0 ]; then
        state=`CONFIGSHOW | grep "$feature" | cut -d ":" -f2`
        if [ $state == "Disabled" ]
        then
            return $STS_OK
        else
            return $STS_ERR
        fi
    else
        return $STS_OK
    fi
}

# This routine checks whether any of the 7.0.1 software
# features are active
check_71_0_enc_sw_features()
{       
        
    $ECHO check_71_0_enc_sw_features
        
    TEST check_feature_kmip  "${UNSUPPORTED_ENCRYPTION_VERSIONING_KMIP}"
    TEST check_feature_decommission_non_rkm_lkm "${UNSUPPORTED_ENCRYPTION_VERSIONING_DEC}" "${BNA_UNSUPPORTED_ENCRYPTION_VERSIONING_DEC}"
    return $RET_CODE
}

check_feature_kmip()
{
    KVTYPE=`CONFIGSHOW | grep spm.encrGrp.kvType | cut -f 2 -d ':'`
    if [ -z "$KVTYPE" ]; then
        return $STS_OK;
    fi
    if [ "$KVTYPE" == "$KEY_VAULT_TYPE_KMIP" ]; then
        return $STS_ERR
    fi
    return $STS_OK
}

check_feature_decommission_non_rkm_lkm()
{    
    KVTYPE=`CONFIGSHOW | grep spm.encrGrp.kvType | cut -f 2 -d ':'`
    if [ -z "$KVTYPE" ]; then
        return $STS_OK;
    fi
    if [ "$KVTYPE" == "$KEY_VAULT_TYPE_RSA" ] ||
       [ "$KVTYPE" == "$KEY_VAULT_TYPE_LKM" ] ; then
        return $STS_OK;
    fi

	ENC_LANCE=$(/fabos/cliexec/slotshow | grep " 43 " | wc -l)
	ENC_MACE=$(/fabos/cliexec/slotshow -d576 | grep " 42 " | wc -l)
	if [ "x$TYPE" != "xrestore" ]; then
		if [ 1 -eq $ENC_MACE -o 0 -ne $ENC_LANCE ]
		then
    		check_feature_enabled "cryptoDev.swEncFeatureMode.decom_non_rkm_lkm"
			if [ $? -ne 0 ]
			then
				return $STS_ERR
			fi
		fi
	fi

    return $STS_OK
}

check_feature_tklm()
{
	ENC_LANCE=$(/fabos/cliexec/slotshow | grep " 43 " | wc -l)
	ENC_MACE=$(/fabos/cliexec/slotshow -d576 | grep " 42 " | wc -l)
	if [ "x$TYPE" != "xrestore" ]; then
		if [ 1 -eq $ENC_MACE -o 0 -ne $ENC_LANCE ]
		then
			check_feature_enabled "cryptoDev.swEncFeatureMode.tklm"
			if [ $? -ne 0 ]
			then
				return $STS_ERR
			fi
		fi
	fi
	return $STS_OK
}

check_multiple_email_address_set_FW_alert() {

	MULTI_EMAIL=`CONFIGSHOW  | grep multi_rcpt | grep item_112 | grep -E  ','| wc -l`

	if [ $MULTI_EMAIL -gt 0 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

check_multi_email_set_allinstances() {


	if [ $VF_ENABLED -ne $STS_OK ]; then
		for_all_contexts check_multiple_email_address_set_FW_alert
	else
		check_multiple_email_address_set_FW_alert
	fi
}

check_tstimezone_with_three_sections() {

	key=`CONFIGSHOW -a | grep ts.tz`
	value=`echo $key | grep ts.tz | cut -f 2 -d ':'`
	no_fields=`echo $value |awk -F'/' '{print NF}'`
	no_fields=`expr $no_fields - 1`

	if [ $no_fields -eq 2 ]; then
                return $STS_ERR
        else
                return $STS_OK
        fi
}

check_tstimezone_with_three_sections_allinstances() {


	if [ $VF_ENABLED -ne $STS_OK ]; then
		for_all_contexts check_tstimezone_with_three_sections
	else
		check_tstimezone_with_three_sections
	fi
}

MAX_PARTITION=8
#print all the switches FID which have CR/FEC enabled F-ports.
check_for_switches_with_CR_FEC_FPorts_enabled() {
	partition=0
        switches="$1 is active on one or more F_Ports of these switches: "
        while [ $partition -le $MAX_PARTITION ]
        do
        	if [ -f /proc/fabos/switch/$partition/CR_FEC_F_Port ]
                then
                	if [ "$1" == "Credit Recovery" ]
                        then
                        	cr_ena=$(correcthost cat /proc/fabos/switch/$partition/CR_FEC_F_Port | grep "CR enabled" | cut -d ":" -f2)
                                if [ $cr_ena -ne 0 ]
                                then
                                	switches="$switches `cat /proc/fabos/switch/$partition/info  | grep "LS Attributes:" | cut -d "," -f1 | awk '{print $4}'`"
                                fi
			else
                                fec_ena=$(correcthost cat /proc/fabos/switch/$partition/CR_FEC_F_Port | grep "FEC enabled" | cut -d ":" -f2)
                                if [ $fec_ena -ne 0 ]
                                then
                                        switches="$switches `cat /proc/fabos/switch/$partition/info  | grep "LS Attributes:" | cut -d "," -f1 | awk '{print $4}'`"
                                fi
                        fi

                 fi

		partition=`expr $partition + 1`
	done
                add_err_status "$switches"


}

check_for_CR_FPorts_enabled() {
	ag_mode_enabled
	if [ $? -eq 0 ]; then
		partition=0
		while [ $partition -le $MAX_PARTITION ]
		do
			if [ -f /proc/fabos/switch/$partition/CR_FEC_F_Port ]
			then
				cr_ena=$(correcthost cat /proc/fabos/switch/$partition/CR_FEC_F_Port | grep "CR enabled" | cut -d ":" -f2)
				if [ $cr_ena -ne 0 ]
				then
					check_for_switches_with_CR_FEC_FPorts_enabled "Credit Recovery"
					return $STS_ERR
				fi
			fi
			partition=`expr $partition + 1`
		done
		return $STS_OK
	else
		return $STS_OK
	fi
}

check_for_FEC_FPorts_enabled() {
	ag_mode_enabled
	if [ $? -eq 0 ]; then 
		partition=0
		while [ $partition -le $MAX_PARTITION ]
		do
			if [ -f /proc/fabos/switch/$partition/CR_FEC_F_Port ]
			then
				fec_ena=$(correcthost cat /proc/fabos/switch/$partition/CR_FEC_F_Port | grep "FEC enabled" | cut -d ":" -f2)
				if [ $fec_ena -ne 0 ]
				then
					check_for_switches_with_CR_FEC_FPorts_enabled "FEC"
					return $STS_ERR
				fi
			fi
			partition=`expr $partition + 1`
		done
		return $STS_OK
	else
		return $STS_OK
	fi
}

check_for_vpwwns_configuration() {
	case ${SWBD##SWBD} in
        '62'|'77'|'109'|'71'|'66'|'64'|'92')
		context_switch chassis
		total_vpwwns=`/fabos/cliexec/fapwwn --show -totalcount | cut -d ' ' -f 6`
		if [ $total_vpwwns -gt 0 ]; then
			return $STS_ERR
		else
			return $STS_OK
		fi
        ;;
    	*)
        return $STS_OK
        ;;
    esac
}

MAX_PARTITION=8
check_flow_on_all_partitions() {
	partition=0
	counter=0
	fids=""
	while [ $partition -le $MAX_PARTITION ]; do
		if [ -f /etc/fabos/np.$partition.conf ]; then
			flows=`grep "np.meta.nflows:" /etc/fabos/np.$partition.conf | cut -d ":" -f2 | awk '{print $1}'`
			if [ "$flows" != "" ] && [ $flows -ne 0 ]; then
				fids="$fids `cat /proc/fabos/switch/$partition/info | grep "LS Attributes:" | cut -d "," -f1 | awk '{print $4}'`"
				counter=`expr $counter + 1`
			fi
		fi
		partition=`expr $partition + 1 `
	done

	if [ $counter -gt 0 ]; then
		if [ $VF_ENABLED -ne $STS_OK ]; then
			add_err_status "Flows are configured on FID(s): $fids"
		fi
		return $STS_ERR
	else
		return $STS_OK
	fi

}

lfm_fid=""
LFM_FID_FILE="/tmp/lfm_fid.txt"
check_lfm_mirror_flow() {
	# To distinguish between LFM and RFM flows, we have to first see if there are any
	# active mirror flows and if yes, then check whether the mirrorport is specified
	# in Domain,Index format. If yes, then it's a RFM flow and do nothing, else it is
	# a LFM flow and store appropriate error message. This method of first checking
	# whether there are any active mirror flow first is not required for a RFM flow because
	# if the check for "," in the mirrorport field returns false, it's not a RFM flow or there
	# are no active mirror flows. In both the cases, we do not have any to do anything.
	act_mir_flows=`correcthost_to_curr_vfid /fabos/link_sbin/flow --show | grep mir+`
	if [ "$act_mir_flows" != "" ]
	then
		x=`echo $act_mir_flows | tr -s " " | cut -d "|" -f12 | cut -s -d "," -f1 | awk '{print $1}'`
		if [ "$x" == "-" ] || [ "$x" == "" ]
		then
			#This is a LFM flow which is active. We should block the downgrade
			lfm_fid="`correcthost_to_curr_vfid /fabos/cliexec/configshow | sed -n 's/Fabric ID =//p'`"
			#
			# We have to export it to a file as this function and the check_flogi_logo_in_contexts() which is the caller
			# gets executed in different shells. So, setting the variables don't work.
			#
			echo $lfm_fid > LFM_FID_FILE 
		fi
	fi
}

check_lfm_mirror_flow_in_all_contexts() {

	#
	# Active is running < 7.3. so no check required
	#
    if [ $HA_ROLE == "STANDBY" -a $PEER_MINOR -lt 3 ]; then
    	return $STS_OK
    fi
	echo "" > LFM_FID_FILE
	if [ $VF_ENABLED -ne $STS_OK ]; then
		if [ $ACTIVECP ] ; then
			for_all_contexts check_lfm_mirror_flow 
		else
			for_all_contexts_standby check_lfm_mirror_flow 
		fi
	else
		check_lfm_mirror_flow	
	fi

	lfm_fid=`cat LFM_FID_FILE`

	/bin/rm LFM_FID_FILE 

    if [ "$lfm_fid" != "" ]; then
        if [ $VF_ENABLED -ne $STS_OK ]; then
            add_err_status "The 'flow mirror' feature is enabled on the switch FID:$lfm_fid"
        fi
        return $STS_ERR
    fi

    return $STS_OK
}

rfm_fid=""
RFM_FID_FILE="/tmp/rfm_fid.txt"
check_rfm_mirror_flow() {
	x=`correcthost_to_curr_vfid /fabos/link_sbin/flow --show | grep mir+ | tr -s " " | cut -d "|" -f12 | cut -s -d "," -f1 | awk '{print $1}'`
	if [ "$x" != "-" ] && [ "$x" != "" ]
	then
		rfm_fid="`correcthost_to_curr_vfid /fabos/cliexec/configshow | sed -n 's/Fabric ID =//p'`"
		#
		# We have to export it to a file as this function and the check_flogi_logo_in_contexts() which is the caller
		# gets executed in different shells. So, setting the variables don't work.
		#
		echo $rfm_fid > RFM_FID_FILE 
	fi
}

check_rfm_mirror_flow_in_all_contexts() {

	#
	# Active is running < 7.3. so no check required
	#
    if [ $HA_ROLE == "STANDBY" -a $PEER_MINOR -lt 3 ]; then
    	return $STS_OK
    fi
	echo "" > RFM_FID_FILE
	if [ $VF_ENABLED -ne $STS_OK ]; then
		if [ $ACTIVECP ] ; then
			for_all_contexts check_rfm_mirror_flow 
		else
			for_all_contexts_standby check_rfm_mirror_flow 
		fi
	else
		check_rfm_mirror_flow	
	fi

	rfm_fid=`cat RFM_FID_FILE`

	/bin/rm RFM_FID_FILE 

    if [ "$rfm_fid" != "" ]; then
        if [ $VF_ENABLED -ne $STS_OK ]; then
            add_err_status "The 'flow mirror' feature is enabled on the switch FID:$rfm_fid"
        fi
        return $STS_ERR
    fi

    return $STS_OK
}

ecb_fid=""
ECB_FID_FILE="/tmp/ecb_fid.txt"

check_ecb_existance() {

	PORTCFG=`/fabos/link_bin/portcfgshow | grep -E 'Encryption|Compression' | grep "ON" | wc -l`

        if [ $PORTCFG -gt 0 ]; then

	 	ecb_fid="`correcthost_to_curr_vfid /fabos/cliexec/configshow | sed -n 's/Fabric ID =//p'`"
                #
                # We have to export it to a file as this function and the check_flogi_logo_in_contexts() which is the caller
                # gets executed in different shells. So, setting the variables don't work.
                #
                echo $ecb_fid > $ECB_FID_FILE
		return $STS_ERR
	else
		return $STS_OK
	fi
}

check_rfm_ecb_co_existance_in_all_contexts() {

	check_rfm_mirror_flow_in_all_contexts
	if [ $? -eq  $STS_ERR ] ; then
		
		echo "" > ECB_FID_FILE

		if [ $VF_ENABLED -ne $STS_OK ]; then
                	CHASSISCMD="cmd_chassis"
			for_all_contexts check_ecb_existance
        	else
			check_ecb_existance
        	fi

		if [ -f $ECB_FID_FILE ] ; then
			ecb_fid=`cat $ECB_FID_FILE`

        		/bin/rm $ECB_FID_FILE
		fi

		if [ "$ecb_fid" != "" ]; then
            		add_err_status "The 'ECB' feature is enabled on the switch FID:$ecb_fid."
            		return $STS_ERR
		fi

	fi
	return $STS_OK

}

#Checks if the image being downloaded supports RFM
check_rfm_compatibility ()
{
	rfm_supported=`grep -E 'RFM_SUPPORTED|check_rfm_mirror_flow_in_all_contexts' $NEW_PREINST`

	if [ "$rfm_supported" = "" ] ; then
		TEST check_rfm_mirror_flow_in_all_contexts "$RFM_ENABLED"
	fi
}

#Checks if the image being downloaded supports RFM+ECB
check_rfm_ecb_compatibility ()
{
	rfm_ecb_supported=`grep -E 'RFM_ECB_SUPPORTED|check_rfm_ecb_co_existance_in_all_contexts' $NEW_PREINST`

	if [ "$rfm_ecb_supported" = "" ] ; then
		TEST check_rfm_ecb_co_existance_in_all_contexts "$RFM_ECB_ENABLED"
	fi
}

find_invalid_mapsrules () {
	invalid_rule_count=$(correcthost_to_curr_vfid /fabos/cliexec/configshow | grep "maps.rule." | grep -E "\/>|\/<|\/=" | wc -l)
	if [ $invalid_rule_count -gt 0 ]; then
		str=`/fabos/cliexec/configshow | grep -v "maps.rules.list" | grep -i "maps.rule" | grep -E "\/>|\/<|\/=" | cut -d'.' -f3|cut -d':' -f1`
		add_err_status "Invalid MAPS rule(s) in FID $CURRENT_VF:\n$str"
		return $STS_ERR
	fi
	return $STS_OK
}

check_invalid_mapsrules () {
	if [ $VF_ENABLED -ne $STS_OK ]; then
		if [ $ACTIVECP ] ; then
			for_all_contexts find_invalid_mapsrules
		else
			for_all_contexts_standby find_invalid_mapsrules
		fi
	else
		find_invalid_mapsrules
	fi
}

#check if any of coreblade is in good status.
check_core_blade_status() {
	status=`/fabos/cliexec/slotshow | grep "CORE BLADE" | grep "NOT POWERED ON"`

	if [ -z "$status" ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#check if zone size greater than 1MB
check_max_zone_size() {
	size=`/fabos/cliexec/cfgsize | grep committed | cut -d ' ' -f 10`
	if [ $size -gt 1045274 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

#check if zone size greater than 1MB in all contexts
check_max_zone_size_in_contexts() {
    if [ $VF_ENABLED -ne $STS_OK ]; then
        CHASSISCMD="cmd_chassis"
        for_all_contexts check_max_zone_size
    else
        check_max_zone_size
    fi
}

#check if rrdy is enabled in base switch
check_rrdy_base_switch () {
	BASE=`/fabos/bin/switchshow | grep "Base Switch:" | cut -d ' ' -f 6 | cut -d ',' -f 1`

	if [ "$BASE" == "Yes" ]; then
		PORTCFG=`/fabos/link_bin/portcfgshow | grep "ISL R_RDY Mode" | grep "ON" | wc -l`

		if [ $PORTCFG -gt 0 ]; then
			return $STS_ERR
		else
			return $STS_OK
		fi
	else
		return $STS_OK
	fi
}

#check if rrdy enabled in all contexts
check_rrdy_mode_in_contexts() {
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		for_all_contexts check_rrdy_base_switch
	else
		return $STS_OK
	fi
}

#
#
# credit_recovery_check_active
# This checks the active CP for any credit recovery active ports.
#
credit_recovery_check_active() {
	string=`/fabos/cliexec/islshow | grep -c "CR_RECOV"`
	return $string
}

#
# credit_recovery_check_standby
# This is run for stand by CP. Run rsh to check from active CP for credit recovery ports.
#
credit_recovery_check_standby() {
	string=`/usr/bin/rsh -n $(otherhost) ROLE_ID=root LOGIN_ID=root CURRENT_AD=0 /fabos/cliexec/islshow | grep -c "CR_RECOV"`
	return $string
}

#
# credit_recovery_enabled
#
# Check if credit recovery is enabled on any local ports. If it is
# configured we fail the firmware downgrade cases.
#
credit_recovery_enabled() {

    if [ $ACTIVECP ]; then
	credit_recovery_check_active
    else
	credit_recovery_check_standby
    fi
}

#
# check_ag_trunk_configured
#
# Check whether any of N_Port trunks are enabled or not
#
check_ag_trunk_configured() {
	if [ -f "/etc/fabos/ag_platform.0" ]; then
		/fabos/bin/switchshow | grep -c Trunk > /dev/null 2>&1
		rc=$?
		if [ $rc -eq 0 ]; then
			return $STS_ERR
		else
			return $STS_OK
		fi
	else
	    return $STS_OK
	fi
}

#
# FCFW
# Check if FC Fastwrite enabled
#
fcfw_configured()
{
	FCFWCHECK=`correcthost_all_vfs CONFIGSHOW | grep -c "portCfg.*FCFW"`

	if [ $FCFWCHECK -gt 0 ]; then
      echo -e "`correcthost_all_vfs CONFIGSHOW | grep FCFW | sed -e 's/portCfg.S/Slot /' -e 's/.P/ Port GE/' -e 's/.MODE:/ mode is /'`\n"
		return $STS_ERR
	fi
	return $STS_OK
}

#
# BSTR
# Check if TCP Byte Streaming enabled
#
bstr_configured()
{
	BSTRCHECK=`correcthost_all_vfs CONFIGSHOW | grep -c "TcpStr=1"`

	if [ $BSTRCHECK -gt 0 ]; then
		return $STS_ERR
	fi
	return $STS_OK
}

#
# FCoE Provision warning message.
#
fcoe_provision_warn_msg()
{
	if [ ${SWBD##SWBD} == '62' ] || [ ${SWBD##SWBD} == '77' ]; then
		# Check if any Europa blades are present or not.
		europa_present
		if [ $? -gt 0 ]; then
			echo -e $FCOE_PROVISION_CONFIG_MSG
			echo -e $BNA_FCOE_PROVISION_CONFIG_MSG >> $BNA_STATUS_FILE
		fi
	fi
	return $STS_OK
}

#
# 7840
# Check HCL readiness of FCIP tunnels
# Does not actually return a failure. Will just print any messages and treat
# them as warnings. Then will use the normal FWDL prompt to confirm from the
# user if they want to proceed.
#
check_fcip_hcl()
{
	if [ ${SWBD##SWBD} == '148' ]; then
		allow_disruptive_single_mode_fwdl
		if [ $? -ne $STS_OK ]; then
			# Only perform the HCL checks if doing a non-disruptive download
			HCL_TUNNEL_CHECK=`correcthost_to_curr_vfid /fabos/link_bin/portshow fciptunnel all --hcl-status --preinst`
			echo -e "$HCL_TUNNEL_CHECK"
			echo ""
		fi
	fi

	return $STS_OK
}

#
# 7800/FX8-24/7840
# Check is any FCIP restrictions are exceeded.
#
check_xfcip_features()
{
    ret=$STS_OK

    # Make special note of FCOE build as this has new FCIP features
    if [ -z $TYPE ]; then
        /bin/cat /tmp/release.plist  2> /dev/null | grep -i "6.4.1_fcoe"  > ${NULL} 2>&1
    else
        /bin/cat /mnt/fabos/share/release  2> /dev/null | grep -i "6.4.1_fcoe" > ${NULL} 2>&1
    fi
    if [ $? -eq 0 ]; then
		FCOE="_fcoe"
    else
		FCOE=""
    fi

	ACTIVE_MAJOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Major://gp'`
	ACTIVE_MINOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Minor://gp'`
	if [ $ACTIVE_MAJOR -ge 7 ]; then

		if [ $ACTIVE_MINOR -ge 3 ]; then

			# v7.3.0+ use new syntax where CLI actually returns meaningful exit code
			case ${SWBD##SWBD} in

			'62' | '77' | '83' | '148')

				correcthost_all_vfs /fabos/link_bin/portShow fciptunnel all --validate ${TO_MAJOR}.${TO_MINOR}.${TO_PATCH}${FCOE} > $FCIP_STATUS_FILE
				if [ $? -ne 0 ]; then
					ret=$STS_ERR
					cat $FCIP_STATUS_FILE >> $STATUS_FILE
					cat $FCIP_STATUS_FILE >> $BNA_STATUS_FILE
				fi

				correcthost_all_vfs /fabos/link_bin/portShow ipif all --validate ${TO_MAJOR}.${TO_MINOR}.${TO_PATCH}${FCOE} >> $FCIP_STATUS_FILE
				if [ $? -ne 0 ]; then
					ret=$STS_ERR
					cat $FCIP_STATUS_FILE >> $STATUS_FILE
					cat $FCIP_STATUS_FILE >> $BNA_STATUS_FILE
				fi
				;;

			*)
				ret=$STS_OK
				;;
			esac

		else

			case ${SWBD##SWBD} in
				'62' | '77' | '83')
					if correcthost_all_vfs /fabos/link_bin/portShow fciptunnel all --validate ${TO_MAJOR}.${TO_MINOR}.${TO_PATCH}${FCOE} | grep . > $FCIP_STATUS_FILE; then
						ret=$STS_ERR
						cat $FCIP_STATUS_FILE >> $STATUS_FILE
						cat $FCIP_STATUS_FILE >> $BNA_STATUS_FILE
					fi
					if correcthost_all_vfs /fabos/link_bin/portShow ipif all --validate ${TO_MAJOR}.${TO_MINOR}.${TO_PATCH}${FCOE} | grep . >> $FCIP_STATUS_FILE; then
						ret=$STS_ERR
						cat $FCIP_STATUS_FILE >> $STATUS_FILE
						cat $FCIP_STATUS_FILE >> $BNA_STATUS_FILE
					fi
				;;
				*)
					ret=$STS_OK
				;;
			esac
		fi
	else
		ret=$STS_OK
	fi

	rm $FCIP_STATUS_FILE >/dev/null 2>&1
    return $ret
}

#
# 7800/FX8-24
# Check if inband management is configured
#
check_xfcip_inband_configured()
{
	if correcthost_all_vfs CONFIGSHOW | grep -q "XMGMTIF"; then
		return $STS_ERR
	fi
	if correcthost_all_vfs CONFIGSHOW | grep -q "XMGMTRTE"; then
		return $STS_ERR
	fi
	return $STS_OK
}

#
# Check if base switch is enabled
#
check_base_sw_enabled() {
    # if Skybolt with VF enabled, check if base switch configured
    if [ ${SWBD##SWBD} == '148' -a $VF_ENABLED -ne $STS_OK ]; then
        export PATH=/fabos/link_bin:/bin:/usr/bin:/sbin:/usr/sbin:/fabos/link_abin:/fabos/link_sbin:/fabos/factory:/fabos/xtool

        lscfg --show | grep bs > /dev/null 2>&1

        if [ $? -eq 0 ]; then
            # base switch present, flag error
            return $STS_ERR
        else
            return $STS_OK
        fi
    fi

    return $STS_OK
}

#
# vf_enabled
#
# Check whether VF is enabled
# both Active and Standby have this information
#
check_vf_enabled() {
	/fabos/bin/fosconfig --show | grep "Virtual Fabric" | grep enabled > /dev/null 2>&1

	if [ $? -eq 0 ]; then
        return $STS_ERR
    else
        return $STS_OK
    fi

}

check_if_ioddelay_set_in_activecp ()
{
    delay_val=`CONFIGSHOW | grep -i "route.iodDelay" | cut -d ":" -f2`

    #
    # Check if any of the configured value is GT 0. This is because
    # -1 is default value.
    #
    for i in $delay_val; do
        if [ $i -gt 0 ]; then
            # Iod delay is configured. Fail the downgrade process.
            return $STS_ERR
        fi
    done
    return $STS_OK
}

check_if_ioddelay_set_in_standby ()
{
    delay_val=`/usr/bin/rsh -n $(otherhost) ROLE_ID=root LOGIN_ID=root CURRENT_AD=0 CONFIGSHOW | grep -i "route.iodDelay" | cut -d ":" -f2`

    for i in $delay_val; do
        if [ $i -gt 0 ]; then
            # Iod delay is configured on standby. Fail downgrade process
            return $STS_ERR
        fi
    done
    return $STS_OK
}

check_for_ioddelay_set()
{
	if [ $ACTIVECP ]; then
		check_if_ioddelay_set_in_activecp
	else
		check_if_ioddelay_set_in_standby
	fi
}

check_ioddelay_set_in_contexts()
{
	if [ $VF_ENABLED -ne $STS_OK ]; then
		for_all_contexts check_if_ioddelay_set_in_activecp
	else
		check_if_ioddelay_set_in_activecp
	fi
}

#
# This routine checks whether any of the 6.4 hardware
# is active, e.g. whether a 6.4 blade/switch is enabled
# or present.
#
check_64_hw_features()
{
	$ECHO check_64_hw_features

	TEST quattro_present "$QUATTROMSG" "$BNA_QUATTROMSG"

	return $RET_CODE
}

#
# This routine checks whether any of the pre ElDorado hardware
# is active or present.
#
check_pre_71_hw_features()
{
	$ECHO check_pre_71_hw_features

	if [ $CUR_MAJOR -eq 6 ]; then
		TEST scimitar_present "$SCIMITARMSG" "$BNA_SCIMITARMSG"
	fi		

	TEST marathon_present "$MARATHONMSG"

	TEST xenon_present "$XENONMSG" "$BNA_XENONMSG"
	
	return $RET_CODE
}

lsan_matrix_supported()
{
	fcrmatrix=`/fabos/bin/fcrlsanmatrix | grep -E "FCR Matrix is activated"| wc -l`
	return $fcrmatrix
}

#Check for EX_PORT Interop Modes.
#Before firmware download to v7.1.0
#check if any EXport is configured in IM2 or IM3.
#If so firmware download should not happen and 
#proper error messge should be displayed
check_ex_ports_IM() {
	if [ $TO_MAJOR -ge 7 -a $TO_MINOR -ge 1 -a $TO_PATCH -ge 0 ]; then
	$ECHO $TO_MAJOR $TO_MINOR $TO_PATCH
		ACTIVE_MAJOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Major://gp'`
		ACTIVE_MINOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Minor://gp'`
		fcrdbgport=`correcthost_to_curr_vfid ls -1 /fabos/cliexec | grep fcrdbgport_cfg_exports | wc -l`

		if [ $ACTIVE_MAJOR -ge 7 -a $ACTIVE_MINOR -ge 2 -a $fcrdbgport -ge 1 ] || 
			[ $ACTIVE_MAJOR -gt 7 ]; then
			check_fcrdbg_ex_ports_IM_configured
			if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
		else
			if [ $VF_ENABLED -ne $STS_OK ]; then
				# VF enabled
				CHASSISCMD="cmd_chassis"
				for_all_contexts check_ex_ports_IM_configured
			else
				# VF disabled
				check_ex_ports_IM_configured
			fi
			if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
		fi
	fi
	return $STS_OK
}

check_ex_ports_IM_configured() {
     if `correcthost_to_curr_vfid /fabos/bin/slotshow |grep "ENABLED" 1>/dev/null 2>&1` ;
        then
            correcthost_to_curr_vfid /fabos/bin/switchshow |
                  /bin/grep -E '\<(EX-Port|Disabled|No_Sync|In_Sync|No_Module|No_Light|Offline)\>'|
            while read index slot port restyy
            do
                $ECHO $slot $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
               if `correcthost_to_curr_vfid /fabos/link_bin/portcfgexport $slot/$port |
                grep -q "Operate mode.*McDATA*\|Operate mode.*Open"` ; then
                add_err_status " * One or more EX-port on slot $slot is configured in McData/Open interop-mode"

                # due to the pipe, return is just like break from current while
                # loop.
                return $STS_ERR
                fi
            done
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
            # The return above exits the subshell started by the pipe
            # return here if the subshell exited early.
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi

     else
            correcthost_to_curr_vfid /fabos/bin/switchshow |
                /bin/grep -E '\<(EX-Port|Disabled|No_Sync|In_Sync|No_Module|No_Light|Offline)\>'|
            while read index port restyy
            do
                $ECHO $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
                if `correcthost_to_curr_vfid /fabos/link_bin/portcfgexport $port |
                grep -q "Operate mode.*McDATA*\|Operate mode.*Open"` ; then
                add_err_status " * One or more EX-port on slot $slot is configured in McData/Open interop-mode"
                # due to the pipe, return is just like break from current while
                # loop.
                return $STS_ERR
                fi
            done
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
            #The return above exits the subshell started by the pipe
            #return here if the subshell exited early.
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
     fi
     return $STS_OK
}
check_fcrdbg_ex_ports_IM_configured() {

	# Verify EX-Port is configured with the Mcdata or Open mode
	if `correcthost_to_curr_vfid /fabos/cliexec/fcrdbgport_cfg_exports --allport |
	    grep "enabled" | grep "McDATA\|Open" 1>/dev/null 2>&1` ; then
		add_err_status " * One or more EX-port is configured in McData/Open interop-mode"
		return $STS_ERR
	fi
	#return here if the subshell exited early.
	if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	return $STS_OK
}
#Check for VEX_PORT Modes.
#Before firmware download to v7.1.0
#check if any EXport is configured in IM2 or IM3.
#If so firmware download should not happen and 
#proper error messge should be displayed
check_vex_ports_IM() {
	if [ $TO_MAJOR -ge 7 -a $TO_MINOR -ge 1 -a $TO_PATCH -ge 0 ]; then

		ACTIVE_MAJOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Major://gp'`
		ACTIVE_MINOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Minor://gp'`
		
		fcrdbgport=`correcthost_to_curr_vfid ls -1 /fabos/cliexec | grep fcrdbgport_cfg_exports | wc -l`

		if [ $ACTIVE_MAJOR -ge 7 -a $ACTIVE_MINOR -ge 2 -a $fcrdbgport -ge 1 ] || 
			[ $ACTIVE_MAJOR -gt 7 ]; then
			# call to verify the EX-port
			check_fcrdbg_vex_ports_IM_configured
			if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
		else
			if [ $VF_ENABLED -ne $STS_OK ]; then
				# VF enabled
				CHASSISCMD="cmd_chassis"
				for_all_contexts check_vex_ports_IM_configured
			else
				# VF disabled
				check_vex_ports_IM_configured
			fi
			if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
		fi
	fi
	return $STS_OK
}

check_fcrdbg_vex_ports_IM_configured() {
	if `correcthost_to_curr_vfid /fabos/cliexec/fcrdbgport_cfg_exports --vex |
	    grep "enabled" | grep "McDATA\|Open" 1>/dev/null 2>&1` ; then
		add_err_status " * One or more VEX-port is configured in McData interop-mode"
		return $STS_ERR
	fi
	#return here if the subshell exited early.
	if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	return $STS_OK
}

check_vex_ports_IM_configured() {
		if `correcthost_to_curr_vfid /fabos/bin/slotshow |grep "ENABLED" 1>/dev/null 2>&1` ;
		then
            correcthost_to_curr_vfid /fabos/bin/switchshow |
                  /bin/grep -E '\<(VEX-Port|Disabled|No_Sync|In_Sync|No_Module|No_Light|Offline)\>'|
            while read index slot port restyy
            do
                $ECHO $slot $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
               if `correcthost_to_curr_vfid /fabos/link_bin/portcfgvexport $slot/$port |
                grep -q "Operate mode.*McDATA*\|Operate mode.*Open"` ; then
                add_err_status " * One or more VEX-port on slot $slot is configured in McData interop-mode"

                # due to the pipe, return is just like break from current while
                # loop.
                return $STS_ERR
                fi
            done
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
            # The return above exits the subshell started by the pipe
            # return here if the subshell exited early.
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
        else
            correcthost_to_curr_vfid /fabos/bin/switchshow |
                /bin/grep -E '\<(VEX-Port|Disabled|No_Sync|In_Sync|No_Module|No_Light|Offline)\>'|
            while read index port restyy
            do
                $ECHO $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
                if `correcthost_to_curr_vfid /fabos/link_bin/portcfgvexport $port |
                grep -q "Operate mode.*McDATA*\|Operate mode.*Open"` ; then
                add_err_status " * One or more VEX-port on slot $slot is configured in McData interop-mode"
                # due to the pipe, return is just like break from current while
                # loop.
                return $STS_ERR
                fi
            done
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
            #The return above exits the subshell started by the pipe
            #return here if the subshell exited early.
            if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
        fi
    return $STS_OK
}
# Check for VE XISL s/w feature port configuration
# before going down to 6.3 or 6.4. Prevent download
# if a VE XISL is configuration is present. This needs to do
# this for Striker.
#
check_for_ve_xisl_configuration() {
	case ${SWBD##SWBD} in
		'62' | '77')

		striker="75"
		if `correcthost_to_curr_vfid /fabos/bin/slotshow | grep "${striker}" 1>/dev/null 2>&1`;
		then
			$ECHO "Striker Blade is present in SWBD" ${SWBD##SWBD}
			if [ $VF_ENABLED -ne $STS_OK ]; then
				# VF enabled
				# Get FID of Base switch, Default swich and List of LS switches
				/bin/ln -sf /fabos/cliexec/lscfg_util /fabos/link_sbin/lscfg_test
				X_BS=`lscfg_test --all | grep Base | awk {'print $2'}`

				if [ "x${X_BS}" == "x" ]
				then
					# If no base switch, no need to check anything else. 
					context_switch chassis
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"
					return $STS_OK
				fi

				X_DS=`lscfg_test --all | grep Default | awk {'print $2'}`

				X_max=`lscfg_test --all | grep Logical | awk {'print $2'} | wc -l`

				if [ $X_max -gt 0 ]
				then
					X_LS=( `lscfg_test --all |grep Logical | awk {' print $2 '} ` )
				else
					context_switch chassis
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"
					return $STS_OK
				fi
				
				X_Flag=0
				for i_index in ${X_LS[@]}
				do
					context_switch $i_index
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"

					XISL_use=`correcthost_to_curr_vfid /fabos/link_bin/switchshow | grep "Allow XISL" | awk '{ print $4 }'`
					if [ "${XISL_use}" == "ON" ]
					then
						X_Flag=1
					fi
				done

				if [ ${X_Flag} -eq 1 ]
				then
					context_switch $X_BS
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"

					if [ `correcthost_to_curr_vfid /fabos/link_bin/switchshow | grep "VE" | wc -l` -gt 0 ]
					then
						context_switch chassis
						glb_vf_id="$CURRENT_VF"
						glb_ls_id="$FABOS_SWITCHNO"
						return $STS_ERR
					fi
				fi	

				context_switch chassis
				glb_vf_id="$CURRENT_VF"
				glb_ls_id="$FABOS_SWITCHNO"
				return $STS_OK		

			else
				# VF disabled
				return $STS_OK		
			fi
		fi
	esac
	return $STS_OK
}

#
# Check for VE Resources in a LS with Allow XISL Use enabled. 
# before going down to 6.3 or 6.4. Prevent any download
# that has FCIP Resources that could use an XISL. 
#
check_for_fcip_using_xisl_configuration() {
	case ${SWBD##SWBD} in
		'62' | '77')

		striker="75"
		if `correcthost_to_curr_vfid /fabos/bin/slotshow | grep "${striker}" 1>/dev/null 2>&1`;
		then
			$ECHO "Striker Blade is present in SWBD" ${SWBD##SWBD}
			if [ $VF_ENABLED -ne $STS_OK ]; then
				# VF enabled

				# Get FID of Base switch, Default swich and List of LS switches

				/bin/ln -sf /fabos/cliexec/lscfg_util /fabos/link_sbin/lscfg_test
				X_BS=`lscfg_test --all | grep Base | awk {'print $2'}`
				if [ "x${X_BS}" == "x" ]
				then
					# If no base switch, no need to check anything else. 
					context_switch chassis
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"
					return $STS_OK
				fi

				X_DS=`lscfg_test --all | grep Default | awk {'print $2'}`

				X_max=`lscfg_test --all | grep Logical | awk {'print $2'} | wc -l`

				if [ $X_max -gt 0 ]
				then
					X_LS=( `lscfg_test --all |grep Logical | awk {' print $2 '} ` )
				else
					context_switch chassis
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"
					return $STS_OK
				fi
				
				for i_index in ${X_LS[@]}
				do
					context_switch $i_index
					glb_vf_id="$CURRENT_VF"
					glb_ls_id="$FABOS_SWITCHNO"

					XISL_use=`correcthost_to_curr_vfid /fabos/link_bin/switchshow | grep "Allow XISL" | awk '{ print $4 }'`
					if [ "${XISL_use}" == "ON" ]
					then
						if [ `correcthost_to_curr_vfid /fabos/link_bin/switchshow | grep "VE" | wc -l` -gt 0 ]
						then
							context_switch chassis
							glb_vf_id="$CURRENT_VF"
							glb_ls_id="$FABOS_SWITCHNO"
							return $STS_ERR
						fi
					fi
				done

				context_switch chassis
				glb_vf_id="$CURRENT_VF"
				glb_ls_id="$FABOS_SWITCHNO"
				return $STS_OK		

			else
				# VF disabled
				return $STS_OK		
			fi
		fi
	esac
	return $STS_OK
}

#
# Check for NOS mode (IM5) EX_PORT before downgrading to lower version of
# v7.0.1 (Toro release). This is wrapper function which will be executed per LS
# if VF is enabled. We need to call this function for all the allowable
# downgrade version of v7.0.1 (both disruptive/non-disruptive)
#

check_nos_ex_ports() {
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -gt 0 ]; then
		if [ $TO_MAJOR -eq 7 -a $TO_MINOR -eq 0 -a $TO_PATCH -eq 0 ] || [ $TO_MAJOR -eq 6 ]; then
			ACTIVE_MAJOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Major://gp'`
			ACTIVE_MINOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Minor://gp'`

			fcrdbgport=`correcthost_to_curr_vfid ls -1 /fabos/cliexec | grep fcrdbgport_cfg_exports | wc -l`

			if [ $ACTIVE_MAJOR -ge 7 -a $ACTIVE_MINOR -ge 2 -a $fcrdbgport -ge 1 ] || 
				[ $ACTIVE_MAJOR -gt 7 ]; then
				check_fcrdbg_nos_ex_ports_configured
				if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
			else
				if [ $VF_ENABLED -ne $STS_OK ]; then
					# VF enabled
						CHASSISCMD="cmd_chassis"
						for_all_contexts check_nos_ex_ports_configured
				else
					# VF disabled
						check_nos_ex_ports_configured
				fi
				if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
			fi
		fi
	fi
	return $STS_OK
}

check_nos_ex_ports_configured() {
	if `correcthost_to_curr_vfid /fabos/bin/slotshow |grep "ENABLED" 1>/dev/null 2>&1` ;
	then
		correcthost_to_curr_vfid /fabos/bin/switchshow |
			/bin/grep -E '\<(EX-Port|Disabled|No_Sync|In_Sync|No_Module|No_Light)\>'|
		while read index slot port restyy
		do
			$ECHO $slot $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
			if `correcthost_to_curr_vfid /fabos/link_bin/portcfgexport $slot/$port |
				grep -q "Operate mode.*NOS"` ; then
				add_err_status " * One or more EX-Port on slot $slot is configured in Brocade NOS Interop-mode"

				# due to the pipe, return is just like break from current while
				# loop.
				return $STS_ERR
				fi
		done
		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
			# The return above exits the subshell started by the pipe
			# return here if the subshell exited early.
		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	else 
		check_nos_ex_ports_configured_pizzabox
		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	fi
	return $STS_OK
}

check_fcrdbg_nos_ex_ports_configured() {
	if `correcthost_to_curr_vfid /fabos/cliexec/fcrdbgport_cfg_exports --allport |
	   grep "enabled" | grep "NOS" 1>/dev/null 2>&1` ; then
		add_err_status " * One or more EX-Port is configured in Brocade NOS Interop-mode"
		return $STS_ERR
	fi
	# return here if the subshell exited early.
	if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	return $STS_OK
}



check_nos_ex_ports_configured_pizzabox() {
        correcthost_to_curr_vfid /fabos/bin/switchshow |
			grep -E '\<(EX-Port|Disabled|No_Sync|In_Sync|No_Module|No_Light)\>'| 
		while read index port restyy
        do
            $ECHO $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
            if `correcthost_to_curr_vfid /fabos/link_bin/portcfgexport $port |
                grep -q "Operate mode.*NOS"` ; then
                add_err_status " * One or more EX-Port is configured in Brocade NOS Interop-mode"

                # due to the pipe, return is just like break from current while
                # loop.
				return $STS_ERR
            fi
        done
    	if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	    # The return above exits the subshell started by the pipe
	    # return here if the subshell exited early.
    		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi

	return $STS_OK
}

#
# Check for long distance ports with -buffers option before downgrading to lower version of
# v7.1.0 (Eldorado release). This is wrapper function which will be executed per LS
# if VF is enabled. We need to call this function for all the allowable
# downgrade version of v7.1.0 (both disruptive/non-disruptive)
#
check_longdist_buffer_option_ports() {
		if [ $VF_ENABLED -ne $STS_OK ]; then
			CHASSISCMD="cmd_chassis"
		# VF enabled
			if [ $ACTIVECP ]; then
				for_all_contexts check_longdistance_buffer_option_ports_configured
			else
				for_all_contexts_standby check_longdistance_buffer_option_ports_configured
			fi
		else
		# VF disabled
			check_longdistance_buffer_option_ports_configured
		fi
		if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
		return $STS_OK

}

check_longdistance_buffer_option_ports_configured() {
		if `correcthost_to_curr_vfid /fabos/bin/slotshow |grep "ENABLED" 1>/dev/null 2>&1` ;
		then
	        correcthost_to_curr_vfid /fabos/bin/switchshow |
    	          /bin/grep -E '\<(LS|LD)\>'|
        	while read index slot port restyy
	        do
            	$ECHO $slot $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
				if `correcthost_to_curr_vfid /fabos/link_bin/portcfgshow $slot/$port |
					grep -q "Desired Buffers.*"` ; then
						add_err_status " * $slot/$port is configured as longdistance with -buffers option"

						# due to the pipe, return is just like break from current while
						# loop.
						return $STS_ERR
				fi
	        done
    		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
		    # The return above exits the subshell started by the pipe
		    # return here if the subshell exited early.
    		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
		else 
			check_longdistance_buffer_option_ports_configured_pizzebox
    		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
		fi
	return $STS_OK
}

check_longdistance_buffer_option_ports_configured_pizzebox() {
        correcthost_to_curr_vfid /fabos/bin/switchshow |
    	          /bin/grep -E '\<(LS|LD)\>'|
		while read index port restyy
        do
            $ECHO $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
			if `correcthost_to_curr_vfid /fabos/link_bin/portcfgshow $port |
				grep -q "Desired Buffers"` ; then
					add_err_status " * $port is configured as Longdistance -buffers option "

					# due to the pipe, return is just like break from current while
					# loop.
					return $STS_ERR
			fi
        done
   		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	    # The return above exits the subshell started by the pipe
	    # return here if the subshell exited early.
   		if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi

	return $STS_OK
}


check_portcfg_eport_credit() {
	eport_credit_ret=`correcthost_to_curr_vfid  /fabos/bin/portcfg_eport_credit | grep "E-Port"`
	if [ $? -eq 0 ]; then  
		add_err_status "$eport_credit_ret"
		return $STS_ERR;
	fi      
	return $STS_OK 
}

#
# Check for SIM port Configuration on all partition and if found 
# firmware downgrade v7.2.0 --> v7.1.0 or  7.2.0--> v7.0.0 will fail. 
#
# The global varibale np_sim_fids won't get updated if it runs in the
# context of Active CP. So, writing those values to a temporary file.
#
NP_SIM_PORT_INFO="/tmp/_np_sim_port_info${$}.txt"
np_sim_fids=""
check_sim_port_config_in_current_context() {
	if ! correcthost_to_curr_vfid /fabos/cliexec/flow --show -ctrlcfg | grep -q "No Simports found on the switch"; then
        np_sim_fids="$np_sim_fids $CURRENT_VF"
        if [ ! $ACTIVECP ] ; then
            echo "$np_sim_fids" > $NP_SIM_PORT_INFO
        fi
    fi
    return $STS_OK
}

check_sim_port_enabled () {
    CHASSISCMD="cmd_chassis"
	if [ $ACTIVECP ] ; then
        for_all_contexts check_sim_port_config_in_current_context
    else
        for_all_contexts_standby check_sim_port_config_in_current_context
        if [ -f $NP_SIM_PORT_INFO ] ; then
            np_sim_fids=`cat $NP_SIM_PORT_INFO`
            rm -f $NP_SIM_PORT_INFO
        fi
    fi

    if [ "$np_sim_fids" != "" ]; then
        if [ $VF_ENABLED -ne $STS_OK ]; then
            add_err_status  "SIM ports configured switches:$np_sim_fids"
        fi
        return $STS_ERR
    else
        return $STS_OK
    fi
}

#
# Check for Encryption and Compression on EX_PORT before downgrading to lower version of
# v7.1.0 (Eldorado release).
#
# Check if more than 2 port per chip are configured for for Encryption and Compression
# before downgrading to lower version of v7.1.0 (Eldorado release).
#
check_enc_comp_fwdl() {
		if `correcthost_to_curr_vfid /fabos/bin/enccomp_fwdl_check | grep -q "chip"`; then
			add_err_status  "$ENC_COMP_FWDL_RESTRICTION"
			return $STS_ERR
		elif `correcthost_to_curr_vfid /fabos/bin/enccomp_fwdl_check | grep -q "EX-Ports"`; then
			add_err_status  "$ENC_COMP_EX_PORT_RESTRICTION"
			return $STS_ERR
		else
			return $STS_OK
		fi
}

#
# Check for Marathon EX_PORT port configuration
# before upgrading to 7.0. prevent any download
#
check_condor_ex_ports_configured() {
	case ${SWBD##SWBD} in
		'62' | '77')

		marathon="24"
		correcthost_to_curr_vfid /fabos/bin/slotshow | grep "${marathon}" 1>/dev/null 2>&1
		if [ $? -eq 0 ]
		then
			if [ $VF_ENABLED -ne $STS_OK ]; then
				# VF enabled
					CHASSISCMD="cmd_chassis"
					for_all_contexts check_marathon_ex_ports_configured
			else
				# VF disabled
				check_marathon_ex_ports_configured
			fi
			if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
		fi
	esac
	return $STS_OK
}

#
# check if EX port configured on any marathon blade in every logical switch
# If so fail the upgrade to 7.0
#
check_marathon_ex_ports_configured() {
    marathon="24"

    correcthost_to_curr_vfid /fabos/bin/slotshow | grep "${marathon}" |
    while read str_slot restyy
    do
        correcthost_to_curr_vfid /fabos/bin/switchshow -slot $str_slot | grep "FC" |
        while read index slot port restyy
        do
            $ECHO $slot $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
            if `correcthost_to_curr_vfid /fabos/link_bin/portcfgexport $slot/$port |
                grep -q "Admin.*enabled"` ; then
                add_err_status " * One or more port on slot $slot is configured as EX-Port."

                # due to the pipe, return is just like break from current while
                # loop.
				return $STS_ERR
            fi
        done
    	if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
    done

    # The return above exits the subshell started by the pipe
    # return here if the subshell exited early.
    if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi

	return $STS_OK
}
check_csctl() {
    if correcthost_to_curr_vfid /fabos/link_bin/portcfgshow | grep "CSCTL mode" | grep -q ON; then
        return $STS_ERR
    else
        return $STS_OK
    fi
}
locked_eport() {

	if correcthost_to_curr_vfid /fabos/link_bin/portcfgshow | grep "Locked E_Port" | grep -q ON; then
		return $STS_ERR
	fi
	return $STS_OK
}

# Check for portname length > 32bytes and prevent downgrade from 7.0
# to Pre v6.4.3 
# if any port having portname length > 32bytes.
#
check_portname_len() {
	#
	# Check portname length only if downgrading to Pre v6.4.3
	#
	if [ $TO_MAJOR -eq 6 -a $TO_MINOR -eq 4 -a $TO_PATCH -ge 3 ]; then
		return $STS_OK
	fi

	if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF enabled
		CHASSISCMD="cmd_chassis"
		for_all_contexts port_namelen
	else
		# VF disabled
		port_namelen
	fi
	if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
}

# check for Condor3 blade is present or not
check_C3_blades() {
	if `/fabos/bin/slotshow | grep -E "96|97|98|99" 1>/dev/null 2>&1`;
	then
		return $STS_ERR
	fi
	return $STS_OK
}

# check for Enhanced FC8 blade is present or not
check_ENHANCED_FC8_blades() {
	if `/fabos/bin/slotshow | grep -E "125|126" 1>/dev/null 2>&1`;
	then
		return $STS_ERR
	fi
	return $STS_OK
}

# check for FCOE blades presence in DCX+ and Pluto+
check_FCOE_blades_in_dcx_pluto_plus() {
	if [ ${SWBD##SWBD} == '62' ] || [ ${SWBD##SWBD} == '77' ]; then

		check_C3_blades
		if [ $? -ne $STS_OK ]; then
			if `/fabos/bin/slotshow -m | grep -E "FCOE" 1>/dev/null 2>&1`; then
				return $STS_ERR
			fi
		fi
	fi
	return $STS_OK
}

# Check for PAD feature without option/events configured
check_PAD_feature() {
	CHASSISCMD="cmd_chassis"
	for_all_contexts check_PAD_enabled
	if [ $? -eq 0 ]; then
        return $STS_OK
    else
        return $STS_ERR
    fi
}

check_PAD_enabled() {
	/fabos/sbin/portcfgautodisable fwdl_downgrade | grep "PAD" | grep enabled > /dev/null 2>&1;
	if [ $? -eq 0 ]; then
        return $STS_ERR
    else
        return $STS_OK
    fi
}

# Check for configured fillword and prevent downgrade from 6.4 if
# any port is configured as > 1 .
# 2- /-idle-arbff  - IDLE  in Link Init, ARBFF as fill word (SW)
# 3- /-aa-then-ia  - If ARBFF/ARBFF failed, then do IDLE/ARBFF
#
check_cfg_fill_word_all_instances() {

	if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF enabled
		CHASSISCMD="cmd_chassis"
		for_all_contexts check_cfg_fill_word
	else
		check_cfg_fill_word
	fi
	if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
}

port_namelen() {
	correcthost_to_curr_vfid /fabos/sbin/portname | grep "port" |
	while read -ers line
	do
		name=${line#*: }
		size=${#name}
		if [ $size -gt 32 ]; then
			return $STS_ERR
		fi
	done
	if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
	return $STS_OK
}

check_cfg_fill_word() {

	if correcthost_to_curr_vfid /fabos/link_bin/portcfgshow | grep "Fill Word" | grep -q " 2 "; then
		return $STS_ERR
	fi

	if correcthost_to_curr_vfid /fabos/link_bin/portcfgshow | grep "Fill Word" | grep -q " 3 "; then
		return $STS_ERR
	fi
	return $STS_OK
}

# Check for configured 16G/10G speed  and prevent downgrade from 7.0 if
# any port is configured.
#       
check_cfg_speed() {
	if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF enabled
		CHASSISCMD="cmd_chassis"
		for_all_contexts port_speedcheck
	else
		port_speedcheck
	fi
	if [ $? -ne $STS_OK ]; then return $STS_ERR ; fi
}

port_speedcheck() {
	if correcthost_to_curr_vfid /fabos/link_bin/switchshow | awk '{ if ($8 != "FCoE") print $6;}' | grep -qi -e "10G" -e "16G"; then
		return $STS_ERR
	fi
	return $STS_OK
}

#
# fcr_enabled
#
# Check whether FCR is enabled
#
check_fcr_enabled() {

	/fabos/bin/fosconfig --show | grep "FC Routing service" | grep enabled > /dev/null 2>&1
	if [ $? -eq 0 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

#
# check_hcl_switchstate
#
# Check the switchState if it is Faulty to block HCL
#
check_hcl_switchstate()
{
	hashow_cmd="/fabos/bin/hashow"

	case "$($hashow_cmd | ( read a; echo $a ))" in
		*"Not supported"*)
		;;
		*)
		return $STS_OK
		;;
	esac

	switch_state=`/fabos/bin/switchshow | sed -n -e 's/switchState://gp' | tr -d '\t'`
	switch_state=`echo $switch_state  | sed $'s/[ \t]//g'`

	if [ "$switch_state" == "Faulty" ]; then
		is_fwdl_arg "s"
		if [ $? -ne 0 ]; then
			return $STS_ERR
		fi
	fi

	return $STS_OK

}

CMSH_DEBUG="/fabos/factory/cmsh_debug"

#
# Check if usres with user-defined roles on 7.0 switch
#
check_udrole_users_presence()
{
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -ge 0 ]; then
	if [  $TO_MAJOR -le 6 ]; then
		/fabos/libexec/userdb_convert $CUR_MAJOR.$CUR_MINOR $TO_MAJOR.$TO_MINOR $PREINST > /dev/null 2>&1
		if [ $? -ne 0 ]; then
			return $STS_ERR;
		fi
	fi
	fi


	return $STS_OK
}

#
# Check if there is any entry in certificate configuratio database
# that is configured to use third party issued certificates with
# the peer switch.
#
check_sec_auth_certificate_database()
{
    FCAP_DIR="/etc/fabos/pki/tp"
    FCAP_SWCERT_FILE="switch.0.crt"
    FCAP_CACERT_FILE="switch.0.rootcrt"
    FCAP_SWCSR_FILE="switch.0.csr"

    if ! ( [ $CUR_MAJOR -eq 7 ] && [ $CUR_MINOR -eq 0 ] && [ $TO_MAJOR -eq 6 ] && [ $TO_MINOR -eq 3 ] ); then
        MAX_NUM_SW=8
        for (( i = 0 ; i <= $MAX_NUM_SW ; i++ ))
        do
            FCAP_CONF_FILE=`echo /etc/fabos/auth.$i.fcap.conf`

            if [ -f $FCAP_CONF_FILE ]; then
                IFS_=${IFS}; IFS=$'\n'
                for LINE in `cat $FCAP_CONF_FILE`
                do
                    CONF_VAL=`echo "$LINE" | awk ' {print $2} '`
                    if [ $CONF_VAL -eq 1 ]; then
                        return $STS_ERR
                    fi
                done
                IFS=${IFS_}
            fi
        done
    fi

    if [ -s $FCAP_DIR/$FCAP_SWCERT_FILE ]; then
	    return $STS_ERR
    fi

    if [ -s $FCAP_DIR/$FCAP_CACERT_FILE ]; then
 	    return $STS_ERR
    fi

    if [ -s $FCAP_DIR/$FCAP_SWCSR_FILE ] ; then
	    return $STS_ERR
    fi

    return $STS_OK
}

#           
# Check if there is any entry in certificate configuration database
# that is configured to use Brocade issued certificates with
# the peer switch or if the Brocade issued certificate is installed
# in the switch.
#
check_sec_auth_certificate_database_for_brcd()
{
    FCAP_DIR="/etc/fabos/pki"
    FCAP_SWCERT_FILE="switch.0.crt"
    MAX_NUM_SW=8
    for (( i = 0 ; i <= $MAX_NUM_SW ; i++ ))
    do  
    FCAP_CONF_FILE=`echo /etc/fabos/auth.$i.fcap.conf`

    if [ -f $FCAP_CONF_FILE ]; then
        IFS_=${IFS}; IFS=$'\n'
		for LINE in `cat $FCAP_CONF_FILE`
		do
				CONF_VAL=`echo "$LINE" | awk ' {print $2} '`
					if [ $CONF_VAL -eq 0 ]; then
				return $STS_ERR
			fi
		done
		IFS=${IFS_}
	fi
	done

    if [ -s $FCAP_DIR/$FCAP_SWCERT_FILE ]; then
        return $STS_ERR
    fi

    return $STS_OK
}
		
#
# Check if Secondary RKM keyvault is configured
# before upgrading to v6.3,0
#
check_sec_rkm_kv()
{
	KVTYPE=`CONFIGSHOW | grep spm.encrGrp.kvType | cut -f 2 -d ':'`

	if [ -z "$KVTYPE" ]; then
		return $STS_OK;
	fi

	if [ "$KVTYPE" = "0x2" ]; then
		SECKV=`CONFIGSHOW | grep spm.encrGrp.secKV.cert.ip | cut -f 2 -d ':'`

		if [ -z "$SECKV" ]; then
			return $STS_OK;
		else
			return $STS_ERR;
		fi
	fi
	return $STS_OK;
}

#Check for Europa blade count
check_europa_blade_count_support() {
	
	EUROPA_BLADE_COUNT=`/fabos/cliexec/slotshow | grep " 74 " | wc -l`

	if [ $EUROPA_BLADE_COUNT -gt 2 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}
check_feature_state()
{
    feature=$1
    if [ `CONFIGSHOW | grep "$feature" |wc -l` -gt 0 ]; then
        state=`CONFIGSHOW | grep "$feature" | cut -d ":" -f2`
        if [ $state == "0x0" ]
        then
            return $STS_OK
        else
            return $STS_ERR
        fi
    else
        return $STS_OK
    fi
}


#
# Check if  Europa blade is power on.
#
check_if_Europa_blade_is_power_on() {
	
	EUROPA_POWER_ON=`/fabos/cliexec/slotshow | grep " 74 " | grep -v "INSERTED, NOT POWERED ON" | wc -l`

	if [ $EUROPA_POWER_ON -gt 0 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

# From Matador (7.0), seconds timebase is not supported on Fabric watch

check_fw_seconds_timebase_allinstances()
{

	if [ $VF_ENABLED -ne $STS_OK ]; then
		for_all_contexts check_fw_seconds_timebase
	else
		check_fw_seconds_timebase
	fi

}

check_fw_seconds_timebase()
{
	LISTTIMEBASE=`CONFIGSHOW | grep "thresh" | grep -F ".tb"`

	for i in $LISTTIMEBASE
	do
		SECONDSTIMEBASE=`echo $i | cut -d ":" -f 2` 

		if [ $SECONDSTIMEBASE -eq 1 ]; then
			class=`echo $i | cut -d "." -f3`
			area=`echo $i | cut -d "." -f4`
			add_err_status "$UNSUPPORTED_CHECK_SECOND_TIMEBASE1 for class $class, area $area on FID $CURRENT_VF." "$BNA_UNSUPPORTED_CHECK_SECOND_TIMEBASE1 for class $class, area $area on FID $CURRENT_VF." 
			return $STS_ERR
		fi
	done 

	return $STS_OK

}

check_veport_threshconfig_allinstances()
{

	if [ $VF_ENABLED -ne $STS_OK ]; then
	   for_all_contexts check_veport_threshconfig
	else
	   check_veport_threshconfig
	fi
}

check_veport_threshconfig()
{
	POSTDECIMAL=`CONFIGSHOW | grep "Pktloss" | cut -d "." -f 6`
	if [ -z $POSTDECIMAL ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi

}

check_flt_mon_config_allinstances()
{

   if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF is enabled
		if [ $ACTIVECP ]; then
        	for_all_contexts check_flt_mon_config
		else
			return $STS_OK
		fi
    else
        check_flt_mon_config
    fi
}

check_flt_mon_config ()
{
	# Check if fmconfig is enabled.
	# If enabled then firmwaredownload is allowed.
    fm=`/fabos/cliexec/config get perf.framemon.enabled 1`
    if [ $fm -eq 1 ]; then
        return "$STS_OK"
	else
		#
		# If not enabled then check if filter monitor configurations are
		# present.
		#
		/bin/rm -f /tmp/flt.dbg
		/fabos/link_bin/ps_dump -f > /dev/null 2>&1
	
		# If file empty then no filter monitor configurations are present.
		if [ ! -s /tmp/flt.dbg ]; then
			return "$STS_OK"
		else
			#If filter monitor configurations are present then return error.
			flt=`sed -n '/PS_VFID/,/Port/p' /tmp/flt.dbg | sed -e 's/PS_V/;/g'`
			for i in `seq 2 9`; do
				echo $flt | cut -d ';' -f $i | grep "FID $glb_vf_id" | grep Port > /dev/null
				if [ $? -eq 0 ]; then 
					return $STS_ERR
				fi
			done
		fi
	fi
	return "$STS_OK"
}

#check if serdes tuning mode is enabled
check_serdes_tune_enabled()
{
	if [ -f "/fabos/sbin/serdestunemode" ]; then
		/fabos/sbin/serdestunemode --show| grep "enabled" > /dev/null 2>&1

		if [ $? -eq 0 ]; then
			return $STS_ERR
		else
			return $STS_OK
		fi
	else
		return $STS_OK
	fi
}

remove_swstatus_cfg_key() {

	for  key in `CONFIGSHOW | grep percentage.MarginalPorts | cut -f 1 -d ':'`
	do
		/fabos/cliexec/config remove $key
	done

	for  key1 in `CONFIGSHOW | grep percentage.FaultyPorts | cut -f 1 -d ':'`
	do
		/fabos/cliexec/config remove $key1
	done

	for key2 in `CONFIGSHOW | grep percentage.MissingSFPs | cut -f 1 -d ':'`
	do
		/fabos/cliexec/config remove $key2
	done

	/fabos/cliexec/configcommit ;
}

check_swstatus_cfg_key() {
	if [ $VF_ENABLED -ne $STS_OK ]; then
		for_all_contexts remove_swstatus_cfg_key
	else
		remove_swstatus_cfg_key
	fi
}

#check if LDAP is configured over IPv6
check_ldap_ipv6_configuration()
{
        rval=$STS_OK
	if [ -f "/etc/fabos/ldap.conf" ]; then
		more /etc/fabos/ldap.conf | cut -f1 |
		while read a
		do
			echo $a | cut -f2,3 -d":" | grep -q ":"
			if test $? -eq 0
			then
				return $STS_ERR
			fi
		done;
		if [ $? -ne $STS_OK ]; then rval=$STS_ERR; fi
	fi
        return $rval
}

flogo_fid=""
FLOGO_FID_FILE="/tmp/base_logo_fid.txt"

check_flogi_logo()
{
	x=`correcthost_to_curr_vfid /fabos/link_bin/portcfgshow | grep -i "NPIV FLOGI Logout" | grep ON | wc -l`
	if [ $x -ne 0 ]; then
		if [ $VF_ENABLED -ne $STS_OK ]; then
			flogo_fid="$flogo_fid `correcthost_to_curr_vfid /fabos/link_bin/switchshow | grep "LS Attributes:" | cut -d "," -f1 | awk '{print $4}'`"
		else
			# No need for any real value of FID in non VF mode. Just have a non Zero value
			flogo_fid=128
		fi	
	fi
	#
	# We have to export it to a file as this function and the check_flogi_logo_in_contexts() which is the caller
	# gets executed in different shells. So, setting the variables don't work.
	#
	echo $flogo_fid > FLOGO_FID_FILE
}

check_flogi_logo_in_contexts()
{
	ag_mode=`/fabos/bin/ag --modeshow | grep -c "NOT enabled"`
	if [ $ag_mode -eq 0 ]; then
		x=`correcthost /fabos/link_bin/portcfgshow | grep -i "NPIV FLOGI Logout" | grep ON | wc -l`
		if [ $x -ne 0 ]; then
			return $STS_ERR
		fi
		return $STS_OK
	fi

	if [ $VF_ENABLED -ne $STS_OK ]; then
		if [ $ACTIVECP ] ; then
			for_all_contexts check_flogi_logo
		else
			for_all_contexts_standby check_flogi_logo
		fi
	else
		check_flogi_logo
	fi

	flogo_fid=`cat FLOGO_FID_FILE`

	/bin/rm FLOGO_FID_FILE

	if [ "$flogo_fid" != "" ]; then
		if [ $VF_ENABLED -ne $STS_OK ]; then
			add_err_status "The 'NPIV FLOGI device logout' feature is enabled on one or more ports of the switch(es) $flogo_fid"
		fi
		return $STS_ERR
	fi
	return $STS_OK
}

check_rte_policy()
{		
	dbr=`aptpolicy | grep Current | grep 2 | wc -l`
	if [ $dbr -eq 1 ]; then
		if [ $VF_ENABLED -ne $STS_OK ]; then
			add_err_status "firmware downgrade is not allowed because Device Based Routing is used in FID $CURRENT_VF."
		else
			add_err_status "firmware downgrade is not allowed because Device Based Routing is used."
		fi
		return $STS_ERR
	else
		return $STS_OK
	fi

}

check_rte_policy_in_contexts()
{
	if [ $VF_ENABLED -ne $STS_OK ]; then
		if [ $ACTIVECP ] ; then
			for_all_contexts check_rte_policy
		else
			for_all_contexts_standby check_rte_policy
		fi
	else
		check_rte_policy
	fi
}

#Checks any d_port configured as DWDM mode
check_dwdm_d_port_config()
{
	D_PORT_DWDM=/tmp/tmp_dwdm.txt
	correcthost_to_curr_vfid /fabos/link_bin/portdporttest --show all | grep "[0-9]" > $D_PORT_DWDM

	SLOT_NUM=`correcthost_to_curr_vfid /fabos/link_bin/portdporttest --show all | grep -i "slot" | wc -l`
	while read line
	do
		if [ $SLOT_NUM -eq 1 ]; then
			slot=`echo $line | grep "[0-9]" | cut -d " " -f1`
			port=`echo $line | grep "[0-9]" | cut -d " " -f2`
			PORT_NUM="$slot/$port"
		else
			PORT_NUM=`echo $line | grep "[0-9]" | cut -d " " -f1`
		fi

		dwdm=`correcthost_to_curr_vfid /fabos/link_bin/portcfgshow $PORT_NUM | grep "D-Port over DWDM" | grep "ON" | wc -l | sed 's/ //g'`

		if [ "$dwdm" == "1" ]; then
			return $STS_ERR
		fi
	done < $D_PORT_DWDM
	return $STS_OK

}

#check any dwdm mode port is configured as d_port
check_d_port_dwdm_support()
{

    if [ $VF_ENABLED -ne $STS_OK ]; then
        CHASSISCMD="cmd_chassis"
        if [ $ACTIVECP ] ; then
           for_all_contexts check_dwdm_d_port_config
        else
           for_all_contexts_standby check_dwdm_d_port_config
        fi
    else
        check_dwdm_d_port_config
    fi

    if [ $? -eq $STS_OK ]; then
        return $STS_OK
    else
        return $STS_ERR
    fi

}

# check for user wise passwdcfg support 
check_passwdcfg_support()
{
	context_switch chassis
	/fabos/cliexec/config get passwdcfg.perusercfg 5 > /dev/null 2>&1
	ret=$?
	if [ $ret -eq 0 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

#check for TACACS+ in authspec more
#DEFECT TR000421027: check if TACACS+ has configured
check_aaa_tacacs_support()
{
	if [ -s "/etc/fabos/tacplus.conf" ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
#	authspec=`/fabos/cliexec/configshow -all | grep -i authspec.mode |  cut -f 2 -d ':'`
#	if [ "${authspec}" -gt 12 ]; then
#		return $STS_ERR
#	else
#		return $STS_OK
#	fi
}

#Prevent firmware downgrade from FOS7.2 to any pre-7.2 versions, 
#if any TACACS+ secret key configured is of length <= 7
check_tacacs_secret_length_lessthan8()
{
		#obtain tac+ secret key from configshow output
		tac_secret=`CONFIGSHOW -chassis | grep tacacs.server.*.secret | cut -d ":" -f2`
		for i in $tac_secret; do
			if [ ${#i} -le 7 ]; then	
				return $STS_ERR
			fi
		done
		return $STS_OK

}

#Checks any r_rdy mode port is configured as d_port
check_r_rdy_d_port_config()
{
    local isl_ports=`correcthost_to_curr_vfid /fabos/link_bin/portcfgshow | grep "ISL R_RDY Mode" | grep "ON" | wc -l | sed 's/ //g'`
    local d_ports=`correcthost_to_curr_vfid /fabos/link_bin/portcfgshow | grep "D-Port mode" | grep "ON" | wc -l | sed 's/ //g'`

    PORT_NUM=0

    #Either no r-rdy ports or d_ports
    if [ "$isl_ports" == "0" ] || [ "$d_ports" == "0" ]; then
        return $STS_OK
    fi

    D_PORT_CONF=/tmp/tmp_dport_show_tmp.txt
    correcthost_to_curr_vfid /fabos/link_bin/portdporttest --show all | grep "[0-9]" > $D_PORT_CONF

    NEED_SLOT_NUM=`correcthost_to_curr_vfid /fabos/link_bin/portdporttest --show all |  grep -i "slot" |  wc -l`
    while read line
    do
        if [ $NEED_SLOT_NUM -eq 1 ]; then
            tempslot=`echo $line | grep "[0-9]" | cut -d " " -f1`
            tempport=`echo $line | grep "[0-9]" | cut -d " " -f2`
            PORT_NUM="$tempslot/$tempport"
        else
            PORT_NUM=`echo $line | grep "[0-9]" | cut -d " " -f1`
        fi

        isl_ports=`correcthost_to_curr_vfid /fabos/link_bin/portcfgshow $PORT_NUM | grep "ISL R_RDY Mode" | grep "ON" | wc -l | sed 's/ //g'`
        d_ports=`correcthost_to_curr_vfid /fabos/link_bin/portcfgshow $PORT_NUM | grep "D-Port mode" | grep "ON" | wc -l | sed 's/ //g'`


        if [ "$isl_ports" == "1" ] && [ "$d_ports" == "1" ]; then
            return $STS_ERR
        fi

    done < $D_PORT_CONF

    return $STS_OK

}

#check any r_rdy mode port is configured as d_port
check_d_port_r_rdy_support()
{

    if [ $VF_ENABLED -ne $STS_OK ]; then
        CHASSISCMD="cmd_chassis"
        if [ $ACTIVECP ] ; then
           for_all_contexts check_r_rdy_d_port_config
        else
           for_all_contexts_standby check_r_rdy_d_port_config
        fi
    else
        check_r_rdy_d_port_config
    fi

    if [ $? -eq $STS_OK ]; then
        rm -rf /tmp/tmp_dport_show*
        return $STS_OK
    else
        rm -rf /tmp/tmp_dport_show*
        return $STS_ERR
    fi

}

check_fcrdbg_icl_ex_port()
{
	#Get ICL slots
	if `correcthost_to_curr_vfid /fabos/cliexec/fcrdbgport_cfg_exports --icl |
		grep "enabled" 1>/dev/null 2>&1` ; then
		# return error 
		return $STS_ERR
	fi
	return $STS_OK
}

check_icl_ex_port()
{
    #Get ICL slots
    icl_slots=`/fabos/bin/slotshow -m | grep "CORE" | awk {'print $1'}`

    for slt in $icl_slots
    do
        #Get EX ports configured on ICL
        correcthost_to_curr_vfid /fabos/bin/switchshow -slot $slt | grep "FC" |
        while read index slot port restyy
        do
            $ECHO $slt $port "-" "$glb_ls_id" $glb_vf_id $CURRENT_VF
            if `correcthost_to_curr_vfid /fabos/bin/portcfgexport $slt/$port |
                grep -q "Admin.*enabled"` ; then

                # due to the pipe, return is just like break from current while
                # loop.
                return $STS_ERR
            fi
        done
        if [ $? -eq $STS_ERR ] ; then return $STS_ERR ; fi
    done
    return $STS_OK
}


#check if Ex ports are configured on ICL ports 
check_icl_ex_port_configuration()
{
	#if no ICL license present then allow firmware download
	icl_lic=`/fabos/bin/licenseshow |grep "Inter Chassis Link"`

	if [ "$icl_lic" == "" ]; then
		return $STS_OK
	fi

	ACTIVE_MAJOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Major://gp'`
	ACTIVE_MINOR=`correcthost_to_curr_vfid /sbin/getfabosver | sed -n -e 's/Minor://gp'`
	fcrdbgport=`correcthost_to_curr_vfid ls -1 /fabos/cliexec | grep fcrdbgport_cfg_exports | wc -l`

	if [ $ACTIVE_MAJOR -ge 7 -a $ACTIVE_MINOR -ge 2 -a $fcrdbgport -ge 1 ] || 
		[ $ACTIVE_MAJOR -gt 7 ]; then
		check_fcrdbg_icl_ex_port
	else 
		if [ $VF_ENABLED -ne $STS_OK ]; then
			CHASSISCMD="cmd_chassis"
			if [ $ACTIVECP ]; then
				for_all_contexts check_icl_ex_port
			else
				# this is the standby cp, examine the configuration of the
				# active cp
				for_all_contexts_standby check_icl_ex_port
			fi
		else
			check_icl_ex_port
		fi
	fi

	if [ $? -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#check if ICL connections are within the allowed limit
check_icl_port_configuration()
{
	#if no ICL license present then allow firmware download
	icl_lic=`/fabos/bin/licenseshow |grep "Inter Chassis Link"`

	if [ "$icl_lic" == "" ]; then
		return $STS_OK
	fi


	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		for_all_contexts check_icl_limit
	else
		check_icl_limit
	fi

	if [ $? -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#check ICL connected chassis limit in fabric
check_icl_limit()
{
	sw_idx=0
	ch_idx=0
	wwn_cnt=0
	icl_cnt=0
	
	#Get ICL slots
	icl_slots=`/fabos/bin/slotshow -m | grep "CORE" | awk {'print $1'}`

	for slt in $icl_slots
	do
		#Get Switch WWN list of E-Ports
		wwn_list=`/fabos/bin/switchshow -slot $slt |grep "E-Port" | awk {'print $10'} | grep ":" | uniq | sort`

		for wwn in $wwn_list
		do
			wwn_arr[$sw_idx]=$wwn
			sw_idx=`expr $sw_idx + 1`
		done
	done

	wwn_arr_uniq="`for wwn in ${wwn_arr[@]}; do echo ${wwn}; done | sort -u`" 
	wwn_cnt=`echo $wwn_arr_uniq | wc -w`

	#Get Domain ID and Chassis WWN
	for sw_wwn in $wwn_arr_uniq
	do
		dom=`/fabos/bin/fabricshow |grep $sw_wwn | awk {'print $1'} |cut -d ':' -f 1`
		if [ "$dom" != "" ]; then
			ch_wwn[$ch_idx]=`/fabos/bin/ess show dcl $dom |grep "CS_WWN" | awk {'print $8'} |grep ":"`
			ch_idx=`expr $ch_idx + 1`
		fi
	done

	ch_wwn_uniq="`for wwn in ${ch_wwn[@]}; do echo ${wwn}; done | sort -u`" 

	#Get ICL count with each unique Chassis WWNs
	icl_cnt=`echo $ch_wwn_uniq | wc -w`

	#If no ICL license present then allow firmware download
	eicl_lic=`/fabos/bin/licenseshow |grep "Enterprise ICL license"`

	if [ "$eicl_lic" == "" ] && [ $icl_cnt -gt 3 ]; then
		return $STS_ERR
	elif [ "$eicl_lic" != "" ] && [ $icl_cnt -gt 9 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

#Checks AOQ ports have required licenses installed
check_aoq_sao_license()
{
	# For Odin platform, these checks are not applicable
	if [ ${SWBD##SWBD} == '133' ]; then
		return $STS_OK
	fi

	LICENSE_SHOW=/tmp/tmp_license_show.txt
	SLOT_SHOW=/tmp/tmp_slot_show.txt

	correcthost_to_curr_vfid /fabos/bin/licenseshow > $LICENSE_SHOW
	correcthost_to_curr_vfid /fabos/bin/slotshow -m > $SLOT_SHOW

	slot_based=`cat $SLOT_SHOW | grep "Not supported on this platform"`
	if [ "$slot_based" == "" ] ; then
		aoq_port_list=`correcthost_to_curr_vfid /fabos/bin/switchshow | grep "AoQ" | awk '{print $2"/"$3}'`
	else
		aoq_port_list=`correcthost_to_curr_vfid /fabos/bin/switchshow | grep "AoQ" | grep "[FNL]*-Port" | tr -s ' ' ' ' | cut -d ' ' -f 1-2`
	fi

	sao_license=`cat $LICENSE_SHOW | grep "Server Application Optimization"`
	aoq_license=`cat $LICENSE_SHOW | grep "Adaptive Networking"`

	#Check Adaptive Networking license if any device ports is configured as AoQ ports.
	if [ "$aoq_port_list" != "" ] ; then
		for port in $aoq_port_list
		do
			aoq_non_ag=`correcthost_to_curr_vfid /fabos/cliexec/dbgShowIsDeviceAG $port | grep "Non_AG"`

			#Check for SAO license if any AoQ enabled server or HBA's are connected
			if [ "$aoq_non_ag" != "" ]; then
				if [ "$sao_license" == "" ] && [ "$aoq_license" != "" ]  ; then
					add_err_status "$DOWNGDAOQ_SAO_REQ" "$BNA_DOWNGDAOQ_SAO_REQ"
					return $STS_ERR
				fi
				if [ "$sao_license" != "" ] && [ "$aoq_license" == "" ]  ; then
					add_err_status "$DOWNGDAOQ_AN_REQ" "$BNA_DOWNGDAOQ_AN_REQ"
					return $STS_ERR
				fi
				if [ "$aoq_license" == "" ] && [ "$sao_license" == "" ]; then
					add_err_status "$DOWNGDAOQ_AN_SAO_REQ" "$BNA_DOWNGDAOQ_AN_SAO_REQ"
					return $STS_ERR
				fi
			else
				if [ "$aoq_license" == "" ] ; then
					add_err_status "$DOWNGDAOQ_AN_REQ" "$BNA_DOWNGDAOQ_AN_REQ"
					return $STS_ERR
				fi
			fi
		done
	fi
	return $STS_OK
}

#check any AOQ enabled device ports exists
check_aoq_ports()
{

    if [ $VF_ENABLED -ne $STS_OK ]; then
        CHASSISCMD="cmd_chassis"
        if [ $ACTIVECP ] ; then
            for_all_contexts check_aoq_sao_license
        else
            for_all_contexts_standby check_aoq_sao_license
        fi
    else
        check_aoq_sao_license
    fi

    if [ $? -eq $STS_OK ]; then
        rm -rf /tmp/tmp_license_show.txt
        rm -rf /tmp/tmp_slot_show.txt
		return $STS_OK
    else
        rm -rf /tmp/tmp_license_show.txt
        rm -rf /tmp/tmp_slot_show.txt
		return $STS_ERR
    fi
}

#check for auto max speed configured ports
check_auto_max_speed_fwdl()
{

	# Active running < 7.3 already no check required
	if [ $HA_ROLE == "STANDBY" -a $PEER_MINOR -lt 3 ]; then
		return $STS_OK
	fi
	automax_fwdl_ret=`correcthost_to_curr_vfid /fabos/bin/portcfgspeed_automax | grep "Auto"`
	if [ "$?" -eq 0 ]; then
		add_err_status "$automax_fwdl_ret"
		return $STS_ERR;
	fi
		return $STS_OK
}

#
# Block downgrade to lower versions if ports are configured with fec via tts mode
# portcfgfec --enable -TTS option.
#
check_fectts_config()
{
        if [ $VF_ENABLED -ne $STS_OK ]; then
                CHASSISCMD="cmd_chassis"
                if [ $ACTIVECP ] ; then
                        for_all_contexts check_fectts_option_ports
                else
                        for_all_contexts_standby check_fectts_option_ports
                fi
        else
                check_fectts_option_ports
        fi

        if [ $? -eq $STS_OK ]; then
                return $STS_OK
        else
                return $STS_ERR
        fi
}

check_fectts_option_ports()
{
	fec_tts_ret=`correcthost_to_curr_vfid /fabos/bin/portcfgshow | grep "FEC via TTS" | grep -c "ON"`
	if [ "$fec_tts_ret" -ne "0" ]; then
		add_err_status "$fec_tts_ret"
		return $STS_ERR;
	fi
		return $STS_OK
}

#check any QOS enabled device ports exists
check_downgrade_qos_port_mode()
{
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ] ; then
			for_all_contexts check_downgrade_qos_mode
		else
			for_all_contexts_standby check_downgrade_qos_mode
		fi
	else
		check_downgrade_qos_mode
	fi

	retval=$?
	rm -rf /tmp/tmp_switch_show.txt
	rm -rf /tmp/tmp_slot_show.txt
	rm -rf /tmp/tmp_isl_show.txt
	rm -rf /tmp/tmp_portcfg_show.txt

	if [ $retval -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#
# This routine does the following checks.
#
# If AN and SAO license is installed then,
#   No need to block the firmware downgrade.
#
# If AN and/or SAO license is not installed,
#   Firmware downgrade will be blocked in the following cases:
#		I.      QOS mode is set to ON for any of the ports.
#		II.     CSCTL mode is set to ON for any of the ports.
#		III.    Rate Limit is set to ON for any of the ports.
#		IV.     If any E-port is using QOS feature (This can be figured out from "islshow" o/p)
#
#
# In all the disallowed cases, installing Licenses will allow the firmware downgrade
#
# The above checks are not applicable for :
#	1 . Odin platform
#	2 . ICL ports
#
check_downgrade_qos_mode()
{
	# For Odin platform, these checks are not applicable
	if [ ${SWBD##SWBD} == '133' ]; then
		return $STS_OK
	fi

	SWITCH_SHOW=/tmp/tmp_switch_show.txt
	SLOT_SHOW=/tmp/tmp_slot_show.txt
	ISL_SHOW=/tmp/tmp_isl_show.txt
	PORTCFG_SHOW=/tmp/tmp_portcfg_show.txt

	correcthost_to_curr_vfid /fabos/bin/switchshow > $SWITCH_SHOW
	correcthost_to_curr_vfid /fabos/bin/slotshow -m > $SLOT_SHOW
	correcthost_to_curr_vfid /fabos/cliexec/islshow > $ISL_SHOW
	correcthost_to_curr_vfid /fabos/cliexec/portcfgshow > $PORTCFG_SHOW

	slot_based=`cat $SLOT_SHOW | grep "Not supported on this platform"`
	qos_license=`correcthost_to_curr_vfid /fabos/bin/licenseshow | grep "Adaptive Networking"`
	e_port_index=`cat $SWITCH_SHOW | grep "E-Port" | awk '{print $1}'`

	index=0
	found=0
	
	#Check Adaptive Networking license is installed.
	if [ "$qos_license" == "" ] ; then
		#Check for slot based system
		if [ "$slot_based" == "" ] ; then
			e_port_slot=`cat $SWITCH_SHOW | grep "E-Port" | awk '{print $2}'`
			
			#Get ICL slots
			icl_slots=`cat $SLOT_SHOW | grep "CORE" | awk {'print $1'}`

			# check QOS mode is ON on any of the port(s).
			qos_mode=`cat $PORTCFG_SHOW | grep "QOS Port" | grep "ON"`
			if [ "$qos_mode" != "" ] ; then
				add_err_status "$DOWNGDQOS_AN_REQ_MSG1" "$BNA_DOWNGDQOS_AN_REQ_MSG1"
				return $STS_ERR
			fi

			# Check CSCTL mode  is ON on any the port(s).
			csctl_mode=`cat $PORTCFG_SHOW | grep "CSCTL" | grep "ON"`
			if [ "$csctl_mode" != "" ] ; then
				add_err_status "$DOWNGDCSCTL_AN_REQ" "$BNA_DOWNGDCSCTL_AN_REQ"
				return $STS_ERR
			fi
			# Check Rate Limit is set on any the port(s).
			rate_limit=`cat $PORTCFG_SHOW | grep "Rate Limit" | grep "ON"`
			if [ "$rate_limit" != "" ] ; then
				add_err_status "$DOWNGDRATELIMIT_AN_REQ" "$BNA_DOWNGDRATELIMIT_AN_REQ"
				return $STS_ERR
			fi
				
			index=0
			# extract each slot from slot list for e-ports
			for slot in $e_port_slot
			do
				e_slot_array[$index]=$slot
				index=`expr $index + 1`
			done

			index=0
			#Check whether E-port (except ICL ports) is actually running QOS feature, if so block downdgrade.
			for port in $e_port_index
			do
				# extract icl slots and compare
				for icl_slot in $icl_slots
				do
					if [ $icl_slot -eq ${e_slot_array[$index]} ] ; then
						found=1
						break
					fi
				done

				# skip icl ports from the following checks.
				if [ $found -eq 1 ] ; then
					index=`expr $index + 1`
					found=0
					continue
				fi

				qos_eport=`cat $ISL_SHOW | grep "$port->" | grep "QOS"`
				if [ "$qos_eport" != "" ] ; then
					add_err_status "$DOWNGDQOS_AN_REQ_MSG3" "$BNA_DOWNGDQOS_AN_REQ_MSG3"
					return $STS_ERR
				fi
			
				index=`expr $index + 1`
			done
		    # End of slot based system
		else
			# check QOS mode is ON on any of the port(s).
			qos_mode=`cat $PORTCFG_SHOW  | grep "QOS Port" | grep "ON"`
			if [ "$qos_mode" != "" ] ; then
				add_err_status "$DOWNGDQOS_AN_REQ_MSG1" "$BNA_DOWNGDQOS_AN_REQ_MSG1"
				return $STS_ERR
			fi
				
			# Check CSCTL mode  is ON on the port
			csctl_mode=`cat $PORTCFG_SHOW | grep "CSCTL" |  grep "ON"`
			if [ "$csctl_mode" != "" ] ; then
				add_err_status "$DOWNGDCSCTL_AN_REQ" "$BNA_DOWNGDCSCTL_AN_REQ"
				return $STS_ERR
			fi
				
			# Check Rate Limit is set on the port
			rate_limit=`cat $PORTCFG_SHOW | grep "Rate Limit" | grep "ON"`
			if [ "$rate_limit" != "" ] ; then
				add_err_status "$DOWNGDRATELIMIT_AN_REQ" "$BNA_DOWNGDRATELIMIT_AN_REQ"
				return $STS_ERR
			fi

			#Check whether E-port is actually running QOS feature, if so block downdgrade.
			for port in $e_port_index
			do
				qos_eport=`cat $ISL_SHOW | grep "$port->" | grep "QOS"`
				if [ "$qos_eport" != "" ] ; then
					add_err_status "$DOWNGDQOS_AN_REQ_MSG3" "$BNA_DOWNGDQOS_AN_REQ_MSG3"
					return $STS_ERR
				fi
			done
		fi
	fi
}
		

#This routine display warning message about the changes in default QoS mode configuration from AE to OFF.
#actual implementation is done in post-install script.
display_default_qosmode_warning_msg ()
{
	#For Odin platform, these checks are not applicable
	if [ ${SWBD##SWBD} == '133' ]; then
		return $STS_OK 
	fi
	qos_license=`/fabos/bin/licenseshow | grep "Adaptive Networking"`
	if [ "$qos_license" == "" ] ; then
		echo -e "\n$DEFAULT_QOS_WARN_MSG\n"
		echo -e "$BNA_DEFAULT_QOS_WARN_MSG" >> $BNA_STATUS_FILE
	fi
}




#check any port other than the first octet of a blade/switch is configured for 10G/N10 speed.
check_10g_port_other_than_first_octet()
{
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ] ; then
    		for_all_contexts check_10g_speed_port_other_than_first_octet
		else
            for_all_contexts_standby check_10g_speed_port_other_than_first_octet
        fi
    else
        check_10g_speed_port_other_than_first_octet
    fi

    if [ $? -eq $STS_OK ]; then
        return $STS_OK
    else
        return $STS_ERR
    fi
}

# This routine will check any port other the first 8 ports of a
# blade (or) pizzabox has N10/10G speed configured. If so,
# downgrade will be blocked. 
check_10g_speed_port_other_than_first_octet()
{
    slot_based=`correcthost_to_curr_vfid /fabos/bin/slotshow | grep "Not supported on this platform"`
    index=0 
                
        #Check for slot based system
        if [ "$slot_based" == "" ] ; then
            slot_list=`correcthost_to_curr_vfid /fabos/bin/switchshow | grep " FC " | awk '{print $2}'`
            port_list=`correcthost_to_curr_vfid /fabos/bin/switchshow | grep " FC " | awk '{print $3}'`
                    
            # Extract each slot from slot list
            for slot in $slot_list
            do
                slot_array[$index]=$slot
                index=`expr $index + 1`
            done

			# Loop from port 8 in every slot 
            index=0
            # check Octet Speed Combo on each ports
            for port in $port_list
            do
                oct_mode=`correcthost_to_curr_vfid /fabos/cliexec/portcfgshow ${slot_array[$index]}/$port | grep "Octet" | awk '{print $4}'`
				if [ "$port" -gt 7 ] ; then
                	if [ "$oct_mode" == "2(10G|8G|4G|2G)" ] ; then
                    	return $STS_ERR
                	fi
					if [ "$oct_mode" == "3(16G|10G)" ] ; then
						return $STS_ERR
					fi
				fi
                index=`expr $index + 1`
            done

        else
            port_list=`correcthost_to_curr_vfid /fabos/bin/switchshow | grep " FC " | awk '{print $1}'`
			# Loop from port 8 of the switch.
            for port in $port_list
            do
				if [ "$port" -lt 8 ] ; then
					continue
				fi
                oct_mode=`correcthost_to_curr_vfid /fabos/cliexec/portcfgshow $port | grep "Octet" | awk '{print $4}'`
                if [ "$oct_mode" == "2(10G|8G|4G|2G)" ] ; then
                    return $STS_ERR
                fi
				if [ "$oct_mode" == "3(16G|10G)" ] ; then
					return $STS_ERR
				fi
            done

        fi
}

# This routine checks whether any of the 7.1 software
# features are active
check_71_sw_features()
{
	$ECHO check_71_sw_features

	TEST check_passwdcfg_support "$CHECK_PASSWDCFG_SUPPORT"

	TEST check_aaa_tacacs_support "$CHECK_AAA_TAC_SUPPORT"

	TEST check_auth_switch_policy "$UNSUPPORTED_AUTH_SWITCH_POLICY"

	TEST check_fms_lossless_xisl "$FMS_LOSSLESS_XISL_CHECK_ERROR"

	TEST check_switch_enforced_login "$UNSUPPORTED_SWITCH_ENFORCED_LOGIN"

	TEST check_ag_dport_configuration "$REMOVE_DPORT_CONFIGURATION"

	TEST check_d_port_icl_support "$D_PORT_ICL_NOT_SUPPORTED"

	TEST check_for_CR_FPorts_enabled "$CR_ACTIVE" 2> ${NULL}

	TEST check_for_FEC_FPorts_enabled "$FEC_ACTIVE" 2> ${NULL}

	TEST check_CR_configuration "$REMOVE_CREDITRECOVERY_CONFIGURATION"
	
	TEST check_for_auto_csctl_enabled "$AUTO_CSCTL_ACTIVE"

	TEST check_FEC_configuration "$REMOVE_FEC_CONFIGURATION"

	TEST check_LOLA_in_contexts "$LOCATION_ID_CONFIGURED" "$BNA_LOCATION_ID_CONFIGURED"

	TEST check_for_spike_vf "$SPIKE_VF_ENABLED" "$BNA_SPIKE_VF_ENABLED"


	# Block downgrade if EX-port isconfigured for Encryption/Compression
	# Block downgrade to lower versions if more than 2 ports per chip are
	# configured with encryption and compression.
	check_enc_comp_fwdl 2> ${NULL}
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		RET_CODE=$OVERALL_STS
	fi
			
	return $RET_CODE
}

# Return value for the portcfg_eport_credit. It contains the port numbers
# in slot/port format. The E-Port Credit configuration is enabled on these
# ports
# This routine checks whether any of the 7.2 software
# features are active
check_72_sw_features()
{
    $ECHO check_72_sw_features

	TEST check_xfcip_features "$XFCIP_FEATURE_RESTRICTION" "$BNA_XFCIP_FEATURE_RESTRICTION"
	TEST check_Trunk_configuration "$ENABLE_TRUNK_CONFIGURATION"
   	TEST check_aoq_ports
   	TEST check_downgrade_qos_port_mode
	TEST check_flow_on_all_partitions "$FLOW_MANAGER_CONFIGURED"
	TEST check_10g_port_other_than_first_octet "$SPEED_10G_PRESENT_ERROR" "$BNA_10G_SPEED_PRESENT_ERROR"
	TEST check_tacacs_secret_length_lessthan8 "$TACACS_LEN_ERROR_MSG"	
        TEST_FIDS check_authutil_allhash "$AUTHUTIL_CONFIGURATION_HASHSET"
	check_portcfg_eport_credit 2> ${NULL}
	OVERALL_STS=$?

	if [ $OVERALL_STS != $STS_OK ]; then
		$ECHO "failed"
		RET_CODE=$OVERALL_STS
		if [ $OVERALL_STS == $STS_ERR ]; then
			add_err_status "$EPORT_CREDIT_FWDL_RESTRICTION"
		fi
	fi
	TEST check_for_maps_enabled "$MAPS_ENABLED" "$BNA_MAPS_ENABLED"
	TEST check_sim_port_enabled "$SIM_PORT_ENABLED"

    return $RET_CODE
}

#
# Check for VF enabled Spike Platform
#
check_for_spike_vf() {

	if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF enabled
		case ${SWBD##SWBD} in '83')
			return $STS_ERR
		;;
		*)
			return $STS_OK
		;;
		esac
	else
		# VF disabled
		return $STS_OK
	fi
}
#
# maps_enabled_check
#
# Check whether the switch is currently in auto csctl mode
#
maps_enabled_check() {
 # on active cp we need diffrent command than the stand by. dont know the reason why?
	ret=`CONFIGSHOW -chassis | grep maps.migrated:1 |wc -l`
	# need to truncate all the leading blank characters 
	last=`echo $ret | tr -d ' '`
	# ret will have command plus the result so we just need result. result will be 
	# either zero or 1 so we just need last character from the end
	last=${ret: -1:1}
	# this is check for debugging 
	#if  [ $last -eq 1 ]; then
	#echo "1: maps is enabled $last"
    #else
	#echo "1: maps is disabled $last"
    #fi
    # return the status
    return $last
}

# check if there is decom action configured in any logical switch.
# If decom is present, the firmwaredownload should not be allowed.

check_for_maps_decom_action_config()
{

	maps_enabled_check
	if [ $? -le 0 ]; then
		return $STS_OK
	fi
	decom_actions=`CONFIGSHOW | grep '^maps\.actions:' 2> /tmp/.fwdl_mapsconfig_out.txt`
	ret=$?
	if [ $ret -eq 0 ]; then
		decom_bitmap=`echo $decom_actions| cut -f2 -d":"`
	else
		return $STS_OK
	fi
	let ret='decom_bitmap & 2048'
	if [ $ret -ne 0 ]; then
			return $STS_ERR
	fi

	rm -f /tmp/.fwdl_mapsconfig_out.txt
	return $STS_OK

}



# check if there is decom action configured in any logical switch.
# If decom is present, the firmwaredownload should not be allowed.

check_for_maps_action_config()
{
	actions=0
	action_bitmask=$1
#	echo "action_bitmas = $action_bitmask"
	maps_enabled_check
	if [ $? -le 0 ]; then
		return $STS_OK
	fi
	actions=`/fabos/cliexec/configshow | grep '^maps\.actions:' 2> /tmp/.fwdl_mapsconfig_out.txt`
	ret=$?
	if [ $ret -eq 0 ]; then
		actions=`echo $actions| cut -f2 -d":"`
	else
		return $STS_OK
	fi
	let ret="actions & $action_bitmask"
	if [ $ret -ne 0 ]; then
# echo "error is being returned...."
	    return $STS_ERR
	fi

	rm -f /tmp/.fwdl_mapsconfig_out.txt
	return $STS_OK
}

# check if user defined rules have decom action.
# If so, the firmwaredownload should not be allowed.

check_for_maps_decom_rules_config()
{

	maps_enabled_check
	if [ $? -le 0 ]; then
		return $STS_OK
	fi
	CONFIGSHOW > /tmp/.fwdl_configshow_out1.txt
	# get the list of rule names.
	awk '/^maps\.rule\./' /tmp/.fwdl_configshow_out1.txt >/tmp/.fwdl_configshow2.txt

	if [ ! -f "/tmp/.fwdl_configshow2.txt" ]; then
		return $STS_OK
	fi
	if [ ! -s "/tmp/.fwdl_configshow2.txt" ]; then
		return $STS_OK
	fi
	rule_check_failed=0
	echo $rule_check_failed > /tmp/.fwdl_decom_rule_err.txt
	cat /tmp/.fwdl_configshow2.txt|
	while read line
	do
	  action_list=`echo $line| cut -f2 -d" "`
	  echo $action_list | grep -i decom > /dev/null
	  if [ $? -eq 1 ]; then
		  continue
	  fi
	  rule_check_failed=1
	  echo $rule_check_failed > /tmp/.fwdl_decom_rule_err.txt
	done

	check_return_val=`cat /tmp/.fwdl_decom_rule_err.txt`
	rm -f /tmp/.fwdl_*.txt
	if [ $check_return_val -eq 1 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi

}


# check if user defined rules have decom action.
# If so, the firmwaredownload should not be allowed.

check_for_actions_present_in_maps_rules_cfg()
{
    actionStr=$1
    maps_enabled_check
    if [ $? -le 0 ]; then
	return $STS_OK
    fi
    CONFIGSHOW > /tmp/.fwdl_configshow_out1.txt
    # get the list of rule names.
    awk '/^maps\.rule\./' /tmp/.fwdl_configshow_out1.txt >/tmp/.fwdl_configshow2.txt

    if [ ! -f "/tmp/.fwdl_configshow2.txt" ]; then
	return $STS_OK
    fi
    if [ ! -s "/tmp/.fwdl_configshow2.txt" ]; then
	return $STS_OK
    fi
    rule_check_failed=0
    echo $rule_check_failed > /tmp/.fwdl_decom_rule_err.txt
    cat /tmp/.fwdl_configshow2.txt|
    while read line
    do
      action_list=`echo $line| cut -f2 -d" "`
      echo $action_list | grep -i $actionStr > /dev/null
      if [ $? -eq 1 ]; then
	continue
      fi
      rule_check_failed=1
      echo $rule_check_failed > /tmp/.fwdl_decom_rule_err.txt
    done

    check_return_val=`cat /tmp/.fwdl_decom_rule_err.txt`
    rm -f /tmp/.fwdl_*.txt
    if [ $check_return_val -eq 1 ]; then
	return $STS_ERR
    else
	return $STS_OK
    fi
}

#check for auto max speed configured ports
check_maps_netmon_enabled()
{
	maps_enabled_check
	if [ $? -gt 0 ]; then
	context_switch chassis
	netmon_enabled=`correcthost /fabos/cliexec/config get  maps.netmon.enabled 2`
	if [ -n "${netmon_enabled}" ]; then
		if [ "${netmon_enabled}" -eq 1 ]; then
			return $STS_ERR;
		fi
	fi
	fi
	return $STS_OK
}

check_for_maps_enabled()
{
    maps_enabled_check
    if [ $? -gt 0 ]; then
	echo $MAPS_ACTIVE > /tmp/maps.err.log
	echo -e "\n$MAPS_ACTIVE\n"
    fi

    # delete this file. -f is to ignore the warning if it does not exist
    # the reason of this delete is to make sure if user tries to downgrade
    # and abort the downgrade process.
    # later on try to upgrade or downgrade then pre-install evaluate again
    # and create new file if needed.

    rm -f /tmp/maps.err.log
    return $STS_OK
}

#check for csctl auto mode 
check_for_auto_csctl_enabled()
{

	auto_csctl_enabled
	if [ $? -gt 0 ]; then
		return $STS_ERR
	else
		return $STS_OK
	fi
}

#check for any D port is configured
check_ag_dport_configuration()
{
	ag_mode_enabled
	if [ $? -gt 0 ]; then
		 dport=`/fabos/bin/switchshow | grep -c "D-Port"`
			if [ $dport -gt 0 ]; then
				return $STS_ERR
			else
				return $STS_OK 	
			fi
	else
		return $STS_OK
	fi
}

#check any icl port is configured as d_port in the switch.
check_d_port_icl_support()
{

	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ] ; then
			for_all_contexts check_icl_d_port_config
		else
			for_all_contexts_standby check_icl_d_port_config
		fi
	else
		check_icl_d_port_config
	fi

	if [ $? -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi

}

#Checks if there is any icl port per VF/switch is configured as d_port.
check_icl_d_port_config()
{
	local icl_slots=`correcthost_to_curr_vfid /fabos/bin/slotshow -m | grep "CORE" | awk {'print $1'}`

	for slt in $icl_slots
	do
		i=`correcthost_to_curr_vfid /fabos/bin/switchshow -slot $slt | grep D-Port|wc -l`
		if [ $i -ge 1 ]; then
			return $STS_ERR
		fi
	done
	return $STS_OK
}

#Check for CR feature enabled in AG mode
check_CR_configuration()
{
	ag_mode_enabled
	if [ $? -gt 0 ]; then
		port_list=`/fabos/bin/switchshow | grep " FC " | awk '{print $4}'`
		index=0
		for port in $port_list
			do
			if [ $port == "cu" ] ; then
				index=`expr $index + 1`
				continue;
			fi
			CR=`/fabos/link_bin/portcfgshow $index | grep "Credit Recovery" | awk '{print $3}'`
			if [ "$CR" == "ON" ]; then
				return $STS_ERR
			fi
			index=`expr $index + 1`
		done 
		return $STS_OK
	else 
		return $STS_OK
	fi
}

#Check for FEC feature enabled in AG mode
check_FEC_configuration()
{
    ag_mode_enabled
    if [ $? -gt 0 ]; then
		port_list=`/fabos/bin/switchshow | grep " FC " | awk '{print $4}'`
		index=0
		for port in $port_list
			do
			if [ $port == "cu" ] ; then
				index=`expr $index + 1`
				continue;
			fi
        	fec=`/fabos/link_bin/portcfgshow $index | grep "FEC:" | awk '{print $2}'`
	        if [ "$fec" == "ON" ]; then
    	        return $STS_ERR
				
			fi
			index=`expr $index + 1`
		done
		return $STS_OK
        else
            return $STS_OK
        fi
}
 
# This routine checks whether any of the 7.0.1 software
# features are active
check_70_1_sw_features()
{

	$ECHO check_70_1_sw_features

	TEST check_rte_policy_in_contexts "$UNSUPPORTED_DBR_ON_DOWNGRADE" "$BNA_UNSUPPORTED_DBR_ON_DOWNGRADE"
	TEST check_d_port_r_rdy_support "$D_PORT_R_RDY_NOT_SUPPORTED" "$BNA_D_PORT_R_RDY_NOT_SUPPORTED"
	TEST check_d_port_dwdm_support "$D_PORT_DWDM_NOT_SUPPORTED" "$BNA_D_PORT_DWDM_NOT_SUPPORTED"
	#
	# Block downgrade if Ex-Port configured in NOS mode.
	# Though the NOS IM5 mode feaure is supported only from 7.0.1 (toro), we
	# are using this function to handle all the downgrade versions.
	#
	TEST check_nos_ex_ports "$NOS_EX_PORT_RESTRICTION" "$BNA_NOS_EX_PORT_RESTRICTION"

	return $RET_CODE
}

# Check all logical switches to see if
#   1. both Lossless and XISL are enabled. 
#   2. both FMS and XISL use are enabled.
# In either of the two cases, downgrade from 7.1.x (and above) to 7.0.x 
# and below is not allowed. 
check_fms_lossless_xisl() {

	if [ $VF_ENABLED -ne $STS_OK ]; then
		# VF enabled
	    CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ] ; then
	        for_all_contexts check_ctxt_fms_lossless_xisl
		else
			for_all_contexts_standby check_ctxt_fms_lossless_xisl
		fi
	fi
}

fspf_location_id=" "
fspf_location_conf=0
# This routine checks whether LOLA is configured
check_LOLA_configuration(){
	# first check location Id key exists or not
	CONFIGSHOW | grep -q route.locationid

	if [ $? -eq $STS_OK ]; then
		local tmp_loc_id=`CONFIGSHOW | grep route.locationid`
		local loc_id=${tmp_loc_id//[^0-9]}

		if [ "$loc_id" != "0" ]; then
			fspf_location_conf=1
			if [ "$fspf_location_id" == " " ]; then
				fspf_location_id="$fspf_location_id $CURRENT_VF"
			else
				fspf_location_id="$fspf_location_id, $CURRENT_VF"
			fi
		fi
	fi

	# pos argument $1 maintains the number of VFs available in a switch
	eval part='$'$1 ; part=`expr $part - 1`; eval $1=$part
	# after determining Loction ID for all VFs return Error
	if [ "$part" == "0" ] && [ "$fspf_location_conf" == "1" ]; then
		add_err_status " * WARNING!!! A Location ID is configured on the following FID(s):$fspf_location_id"
		return $STS_ERR
	fi

	return $STS_OK
}

# Wrapper routine which checks whether LOLA is configured or not
check_LOLA_in_contexts() {
	partitions=`ls -l /proc/fabos/switch | grep -v total | wc -l`
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ]; then
			for_all_contexts check_LOLA_configuration partitions
		else
			for_all_contexts_standby check_LOLA_configuration partitions
		fi
	else
		check_LOLA_configuration partitions
	fi

	if [ $? -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

check_ctxt_fms_lossless_xisl()
{
	XISL_use=`/fabos/cliexec/config get switch.xisluse 2`
	fms=`/fabos/cliexec/config get ficu.fmsmode 2`
	lossless=`/fabos/cliexec/config get route.lossless 2` ;
	if [ "${XISL_use}" -eq 1 ] && [ $lossless -eq 1 ] && [ $fms -eq 1 ]; then
		#FMS, Lossless and XISL use are all enabled. Downgrade from 7.1.x (and above) to 7.0 is not allowed.
		add_err_status "firmware downgrade from 7.1.x (and above) to 7.0.x (and below) is not allowed because FMS, Lossless and XISL use are enabled in FID $CURRENT_VF. Please disable XISL use before downgrading."
		return $STS_ERR
	elif [ "${XISL_use}" -eq 1 ] && [ $lossless -eq 1 ]; then
		#Lossless and XISL use are both enabled. Downgrade from 7.1.x (and above) to 7.0 is not allowed.
		add_err_status "firmware downgrade from 7.1.x (and above) to 7.0.x (and below) is not allowed because Lossless and XISL use are both enabled in FID $CURRENT_VF. Please disable either of them before downgrading."
		return $STS_ERR
	elif [ "${XISL_use}" -eq 1 ] && [ $fms -eq 1 ]; then
		#FMS and XISL use are both enabled. Downgrade from 7.1.x (and above) to 7.0 is not allowed.
		add_err_status "firmware downgrade from 7.1.x (and above) to 7.0.x (and below) is not allowed because FMS and XISL use are both enabled in FID $CURRENT_VF. Please disable either of them before downgrading."
		return $STS_ERR
	fi
	return $STS_OK;
}


# This routine checks whether any of the 7.0 software
# features are active
#

check_70_sw_features()
{
	$ECHO check_70_sw_features
	TEST check_portname_len "$PORTNAME_LEN_DISALLOWED_MSG" "$BNA_PORTNAME_LEN_DISALLOWED_MSG"

	TEST check_PAD_feature "$PAD_FEATURE_CHECK_MSG" "$BNA_PAD_FEATURE_CHECK_MSG"

	TEST check_ag_staticfports "$UNSUPPORTED_STATICFPORTS_CONFIG_ON_DOWNGRADE" "$BNA_UNSUPPORTED_STATICFPORTS_CONFIG_ON_DOWNGRADE"
    
 	TEST check_ag_eemon_installed "$UNSUPPORTED_EEMON_ON_DOWNGRADE" "$BNA_UNSUPPORTED_EEMON_ON_DOWNGRADE"

	TEST check_ag_fmon_installed "$UNSUPPORTED_FMON_ON_DOWNGRADE" "$BNA_UNSUPPORTED_FMON_ON_DOWNGRADE"

	TEST check_enhanced_licenses_installed "$UNSUPPORTED_LICENSES_ON_DOWNGRADE" "$BNA_UNSUPPORTED_LICENSES_ON_DOWNGRADE"

	TEST check_udrole_users_presence "$UDROLE_FWDL_DISALLOWED_MSG" "$BNA_UDROLE_FWDL_DISALLOWED_MSG"

	TEST check_multi_email_set_allinstances  "$UNSUPPORTED_MULTIPLE_EMAIL_FW_ALERT" "$BNA_UNSUPPORTED_MULTIPLE_EMAIL_FW_ALERT"

	TEST check_veport_threshconfig_allinstances "${UNSUPPORTED_VEPORT_THRESHOLD_CONFIG}" "${BNA_UNSUPPORTED_VEPORT_THRESHOLD_CONFIG}"

	TEST check_ldap_ipv6_configuration "$CHECK_LDAP_CONFIGURED_OVER_IPv6" "$BNA_CHECK_LDAP_CONFIGURED_OVER_IPv6"

	TEST check_ipfilter_forward_rule "$UNSUPPORTED_IPFILTER_POLICY" "$BNA_UNSUPPORTED_IPFILTER_POLICY"

	TEST check_tstimezone_with_three_sections_allinstances "$UNSUPPORTED_TSTIMEZONE" "$BNA_UNSUPPORTED_TSTIMEZONE"

	TEST check_for_vpwwns_configuration "$VPWWN_CONFIGURED" "$BNA_VPWWN_CONFIGURED"

	#TEST check_cfg_speed "$PORTSPEED_DISALLOWED_MSG" "$BNA_PORTSPEED_DISALLOWED_MSG"

	# Check for VE as XISL 
	TEST check_for_ve_xisl_configuration "$VE_AS_XISL_CONFIGURED" "$BNA_VE_AS_XISL_CONFIGURED"

	# Check for FCIP ports in a LS with XISL Use enabled
	TEST check_for_fcip_using_xisl_configuration "$FCIP_LS_WITH_XISL_ON" "$BNA_FCIP_LS_WITH_XISL_ON"

	#
	#Delete new config key of Marginal,Faulty, Missing SFPs component
	#of switchstatuspolicy
	#
	check_swstatus_cfg_key
	#
	# Block downgrade if Ex-Port configured in NOS mode.
	# Though the NOS IM5 mode feaure is supported only from 7.0.1 (toro), we
	# are using this function to handle all the downgrade versions.
	#
	TEST check_nos_ex_ports "$NOS_EX_PORT_RESTRICTION" "$BNA_NOS_EX_PORT_RESTRICTION"

	# Block downgrade if 7.0.1 feature is enabled
	TEST check_rte_policy_in_contexts "$UNSUPPORTED_DBR_ON_DOWNGRADE" "$BNA_UNSUPPORTED_DBR_ON_DOWNGRADE"

	# 7.0.1 sw features (needs to be checked while downgrading.)
	TEST check_d_port_r_rdy_support "$D_PORT_R_RDY_NOT_SUPPORTED" "$BNA_D_PORT_R_RDY_NOT_SUPPORTED"
	TEST check_d_port_dwdm_support "$D_PORT_DWDM_NOT_SUPPORTED" "$BNA_D_PORT_DWDM_NOT_SUPPORTED"	

	return $RET_CODE
}

# Block downgrade from 7.0.1 to pre-7.0.1 in Dcx+ and Pluto+ when
# FC8-16 or FC8-32 or FC8-48 is present
check_FC8_blades_dcx_pluto_plus() {

	ret=$STS_OK
	if [ ${SWBD##SWBD} == '62' ] || [ ${SWBD##SWBD} == '77' ]; then
		check_C3_blades
		if [ $? -ne $STS_OK ]; then
			if `/fabos/bin/slotshow | grep "SW BLADE" | grep -E "37|55|51" 1>/dev/null 2>&1`; then
				ret=$STS_ERR
			fi
		fi
	fi

	return $ret
}

# Block downgrade to pre 7.3 when Windu blade is present
check_windu_blades() {

        ret=$STS_OK
        if `/fabos/bin/slotshow | grep "SW BLADE" | grep -E "153" 1>/dev/null 2>&1`; then
                ret=$STS_ERR
        fi

        return $ret
}

# This routine checks whether any of the 7.0 hardware
# is present
#

check_70_hw_features()
{
	$ECHO check_70_hw_features

	TEST check_C3_blades "$CONDOR3_BLADE_IS_PRESENT" "$BNA_CONDOR3_BLADE_IS_PRESENT"

	TEST check_FC8_blades_dcx_pluto_plus "$FC8_BLADE_IS_PRESENT" "$BNA_FC8_BLADE_IS_PRESENT"

	TEST check_max_zone_size_in_contexts "$UNSUPPORTED_ZONE_SIZE" "$BNA_UNSUPPORTED_ZONE_SIZE"

	return $RET_CODE
}

check_enhanced_fc8_present()
{
	$ECHO check_enhanced_fc8_present

	if [ $TO_MAJOR -eq 7 -a $TO_MINOR -eq 0 -a $TO_PATCH -eq 0 ]; then
		TEST check_ENHANCED_FC8_blades "$ENHANCED_FC8_BLADE_IS_PRESENT" "$BNA_ENHANCED_FC8_BLADE_IS_PRESENT"
		return $RET_CODE
	fi
	
	return $STS_OK
}

# check the platforms supported by Edison
check_platforms_supported_by_edison()
{
	ret=0
	case ${SWBD##SWBD} in
		'62' | '77' | '83'| '76')
			ret=$STS_OK
		;;
		*)
			ret=$STS_ERR
		;;
	esac
	return $ret
}

# check switch authentication policy to upgrade to v7.1 with AG mode enabled
check_auth_switch_policy()
{
	ag_mode=$(correcthost /fabos/link_bin/switchshow | grep -c "Access Gateway Mode")

	if [ $ag_mode -eq 1 ]; then
		auth_sw_policy=`/fabos/cliexec/config get auth.policy 2`;
		if [ $auth_sw_policy -eq 0 -o $auth_sw_policy -eq 1 -o $auth_sw_policy -eq 2 ]; then
			return $STS_ERR
		fi

	fi

	return $STS_OK
}

#Check for Trunking feature enabled in AG mode
check_Trunk_configuration()
{
    ag_mode_enabled
    if [ $? -gt 0 ]; then
		port_list=`/fabos/bin/switchshow | grep " FC " | awk '{print $4}'`
		index=0
		for port in $port_list
			do
			if [ $port == "cu" ] ; then
			    index=`expr $index + 1`
			    continue;
			fi
			Trunk=`/fabos/link_bin/portcfgshow $index | grep "Trunk Port" | awk '{print $3}'`
			if [ "$Trunk" == "OFF" ] ; then
				return $STS_ERR
			fi
			index=`expr $index + 1`
		done
		return $STS_OK	
	else 
		return $STS_OK
	fi
	
}

# check if enforce login is configured to 2, if so return err.
check_switch_enforced_login()
{
	if correcthost_all_vfs /fabos/cliexec/config get switch.login.enforce_login 2 | grep 2 > /dev/null 2>&1; then
		return $STS_ERR
	fi
	return $STS_OK
}

#
# This routine checks whether there are any features or conditions
# to be handled when upgrading
#
check_pre71_sw_features()
{
	$ECHO check_pre71_sw_features
	
	# Added warning message when trapEnterpriseFlag is 0 and sysObjID is other than
	# default sysObjID
	check_snmp_trapEnterpriseFlag

	TEST check_icl_port_configuration "$UNSUPPORTED_ICL_PORT_CONFIGURATION" "$BNA_UNSUPPORTED_ICL_PORT_CONFIGURATION"

	if [ $CUR_MAJOR -lt 7 ]; then
			TEST check_interop_in_contexts "$UNSUPPORTED_INTEROP_MODE" "$BNA_UNSUPPORTED_INTEROP_MODE"
    
			TEST check_multi_fwconfigure_change "$UNSUPPORTED_FWCONFIGURE2" "$BNA_UNSUPPORTED_FWCONFIGURE2"
	
			TEST fcfw_configured "$FCFW_NOT_SUPPORTED" "$BNA_FCFW_NOT_SUPPORTED"

			TEST bstr_configured "$BSTR_NOT_SUPPORTED" "$BNA_BSTR_NOT_SUPPORTED"
			
			TEST check_rrdy_mode_in_contexts "$UNSUPPORTED_RRDY_BASE_SWITCH" "$BNA_UNSUPPORTED_RRDY_BASE_SWITCH"
			#
			# Block if any FW element timebase is configured to seconds
			#

			TEST check_fw_seconds_timebase_allinstances "$UNSUPPORTED_CHECK_SECOND_TIMEBASE2" "$BNA_UNSUPPORTED_CHECK_SECOND_TIMEBASE2"

			TEST check_ioddelay_set_in_contexts "$UNSUPPORTED_IODDELAY_ON_UPGRADE" "$BNA_UNSUPPORTED_IODDELAY_ON_UPGRADE"

			TEST check_dupe_wwpn_in_contexts "$UNSUPPORTED_DUP_PORT_WWN" "$BNA_UNSUPPORTED_DUP_PORT_WWN"
	fi	

	return $RET_CODE
}

#check the top talker config key and remove it
check_tt_config_key()
{
    CONFIGSHOW -all | grep -q "perf.ToptalkerEnabledonC2"

    if [ $? -eq 0 ]; then
    /fabos/cliexec/config remove "perf.ToptalkerEnabledonC2"
    /fabos/cliexec/configcommit
    fi
	return $STS_OK
}

#
# Display duplicate WWPN warning message
# when upgrading to 7.0
#
display_dupe_wwpn_warning_msg()
{
	NSSHOW=/tmp/ns_show.txt
	correcthost_to_curr_vfid /fabos/link_bin/nsshow > $NSSHOW
	correcthost_to_curr_vfid /fabos/link_bin/nscamshow >> $NSSHOW
	SORTED_FILE=/tmp/ns_sort.txt
	UNIQUE_FILE=/tmp/ns_uniq.txt
	PID_FILE=/tmp/ns_pid_wwn.txt
	DUP_WWN=/tmp/ns_dup_wwn.txt

	grep "[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F];" $NSSHOW | gawk -F';' '{ print $3 }' | sort > $SORTED_FILE
	uniq $SORTED_FILE > $UNIQUE_FILE
	if [ `cat $SORTED_FILE|wc -l` -ne `cat $UNIQUE_FILE|wc -l` ]; then
		echo "Duplicate PortWWN Present in the Fabric"
		grep "[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F];" $NSSHOW | gawk -F';' '{ print $3 "    "$1}' | gawk '{ print $1, $3 }' > $PID_FILE
		uniq -d $SORTED_FILE > $DUP_WWN
		BAKIFS=$IFS
		IFS=$(echo -en "\n\b")
			exec 3<&0
			exec 0<"$DUP_WWN"
			while read -r line
			do
				grep $line $PID_FILE
			done
			exec 0<&3
		IFS=$BAKIFS

		return $STS_ERR
	fi 
        
	return $STS_OK
}

#check if duplicate PWWN exists in all contexts
check_dupe_wwpn_in_contexts() {

	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		for_all_contexts display_dupe_wwpn_warning_msg
	else
		display_dupe_wwpn_warning_msg
	fi

	if [ $? -eq $STS_OK ]; then
		rm -f /tmp/ns*
		return $STS_OK
	else
		rm -f /tmp/ns*
		return $STS_ERR
	fi

}

check_duplicate_switch_name() {
	ret=$STS_OK
	/bin/rm -f $FWDL_PREINST_SWITCHNAME

	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		correcthost_all_vfs /fabos/bin/switchname >> $FWDL_PREINST_SWITCHNAME
	else
		# Since there is no VF, Return to caller.
		return $STS_OK
	fi

	dup=`/bin/cat $FWDL_PREINST_SWITCHNAME | /bin/sort | /usr/bin/uniq -d | /usr/bin/wc -l`
	if [ $dup -ne 0 ]; then
		ret=$STS_ERR
	fi

	/bin/rm -f $FWDL_PREINST_SWITCHNAME
	return $ret
}

warningDisplayed=0
check_maps_one_feature_to_give_warning() {
    result=""
    listOfTokens=""
    ret=$STS_OK
    configBuffer=`CONFIGSHOW`
    token=$1
    result=`echo $configBuffer | grep $token`
    if [ -n "$result" ]
    then
		if [ $token == "qt=" ]
		then
			token="Quiet time"
		fi 
		if [ -n "$listOfTokens" ]
		then
	    	listOfTokens="$token, $listOfTokens"
		else
	    	listOfTokens="$token"
		fi    
    fi
    if [ -n "$listOfTokens" ]
    then
		let "warningDisplayed=warningDisplayed+1"
		if [ $warningDisplayed -eq 1 ]
		then
		    warnStr="MAPS user defined rules for $token will not be monitored in pre-FOS 7.4. Please delete these rules from FID: $glb_vf_id"
		fi
		if [ $warningDisplayed -gt 1 ]
		then
	    	warnStr=" ,$glb_vf_id"
		fi
		if [ $warningDisplayed -ge 1 ]
		then    
	    	echo -n $warnStr >> maps_74_features_warn.txt
		fi
    fi
    return $ret
}

check_maps_74_features_to_give_warning()
{
	warnDisplayed=0
    bnaErr=0
    warningDisplayed=0
    tokenList="IO_LATENCY_CLEAR ALL_CIRCUIT_HIGH_QOS ALL_CIRCUIT_MED_QOS ALL_CIRCUIT_LOW_QOS ALL_CIRCUIT_F_QOS DEV_NPIV_LOGINS qt="
    for token in $tokenList
    do
      if [ $VF_ENABLED -ne $STS_OK ]; then
	  if [ $ACTIVECP ] ; then
	      for_all_contexts check_maps_one_feature_to_give_warning $token
	  else
	      for_all_contexts_standby check_maps_one_feature_to_give_warning $token
	  fi
      else
	  check_maps_one_feature_to_give_warning $token
      fi
      warningDisplayed=0
      if [ -f maps_74_features_warn.txt ]
      then
	  	echo -e "\n" >> maps_74_features_warn.txt
		if [ $warnDisplayed -eq 0 ] 
		then
			echo "WARNING:"
			warnDisplayed=1	
		fi
	  	cat maps_74_features_warn.txt
	  	rm maps_74_features_warn.txt  
	  	bnaErr=1
      fi
    done
    if [ $bnaErr -ne 0 ]
    then
#	echo "bna is being logged.."
	add_err_status " " "$BNA_MAPS_74_WARN"
    fi
}


check_maps_feature_to_give_warning() {
    result=""
    listOfTokens=""
    ret=$STS_OK
    tokenList="ALL_2K_QSFP ALL_D_PORTS ETH_MGMT_PORT_STATE L2_DEVCNT_PER LSAN_DEVCNT_PER ZONE_CFGSZ_PER BB_FCR_CNT ALL_D_PORTS ZONE_CFGSZ_PER";
    configBuffer=`/fabos/cliexec/configshow`
    for token in $tokenList
    do
      result=`echo $configBuffer | grep $token`
      if [ -n "$result" ]
      then
      if [ -n "$listOfTokens" ]
      then
          listOfTokens="$token, $listOfTokens"
      else
          listOfTokens="$token"
      fi
      fi
    done
    if [ -n "$listOfTokens" ]
    then
    let "warningDisplayed=warningDisplayed+1"
    if [ $warningDisplayed -eq 1 ]
    then
        echo  "WARNING:"
    fi
    echo "$warningDisplayed. In MAPS, user-defined rules are present for $listOfTokens in FID:$glb_vf_id. These rules will not be monitored in pre-7.3 FOS version."
    add_err_status " " "$BNA_MAPS_73_WARN"
    fi
    return $ret
}



check_maps_feature_for_73()
{
    if [ $VF_ENABLED -ne $STS_OK ]; then
	if [ $ACTIVECP ] ; then
	    for_all_contexts check_maps_feature_to_give_warning
	else
	    for_all_contexts_standby check_maps_feature_to_give_warning
	fi
    else
	check_maps_feature_to_give_warning
    fi
}

#check if more than 2K proxies are downloaded on Ex port 
check_max_proxies_on_export()
{
    count=`/fabos/cliexec/fcrdbgportshow --proxycount`
        if [ "$count" = "True" ]; then
            return $STS_ERR
        fi

    return $STS_OK
}

#check if IO Analyzer is enabled
check_ioanalyzer_enabled()
{
	count=`correcthost /fabos/link_bin/switchshow |grep "Analytics" -c`
	if [ $count -eq 0 ]; then
		return $STS_OK
	fi

	return $STS_ERR
}

#check if AE-Ports are configured
check_AE_Ports_to_SOLO()
{
	count=`correcthost_to_curr_vfid /fabos/bin/switchshow | grep "AE-Port" -c`
	if [ $count -eq 0 ]; then
		return $STS_OK
	fi      
                
	return $STS_ERR
}

#check if AE-Ports are configured in any of the partitions
check_AE_Ports_in_context()
{
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ] ; then
			for_all_contexts check_AE_Ports_to_SOLO
		else
			for_all_contexts_standby check_AE_Ports_to_SOLO
		fi
	else
		check_AE_Ports_to_SOLO
	fi

	if [ "$?" -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

check_74_blocking_maps_features() 
{
   data="4096:BNA_MAPS_PT_CONFIG_ERR:MAPS_PT_CONFIG_ERR 32768:BNA_MAPS_FMS_CONFIG_ERR:MAPS_FMS_CONFIG_ERR 65536:BNA_MAPS_SDDQ_CONFIG_ERR:MAPS_SDDQ_CONFIG_ERR"

    data1="TOGGLE:BNA_MAPS_PT_RULES_CONFIG_ERR:MAPS_PT_RULES_CONFIG_ERR FMS:BNA_MAPS_FMS_RULES_CONFIG_ERR:MAPS_FMS_RULES_CONFIG_ERR SDDQ:BNA_MAPS_SDDQ_RULES_CONFIG_ERR:MAPS_SDDQ_RULES_CONFIG_ERR"

    # check for 7.4 features
    for var in $data
    do
#      echo "var=$var"
      funcArgs=`echo $var | awk -F: ' { print $1 } ' `
      bnaErr=`echo $var | awk -F: ' { print $2 } ' `
      cliErr=`echo $var | awk -F: ' { print $3 } ' `
#      error=$(eval echo $`echo $error`);
#      echo " error = $error funcArgs=$funcArgs"
      TEST_FIDS_ADV check_for_maps_action_config $cliErr $bnaErr funcArgs="$funcArgs"
    done

    # check for 7.4 features
    for var in $data1
    do
      funcArgs=`echo $var | awk -F: ' { print $1 } ' `
      bnaErr=`echo $var | awk -F: ' { print $2 } ' `
      cliErr=`echo $var | awk -F: ' { print $3 } ' `
#      error=$(eval echo $`echo $error`);
#      echo " error = $error funcArgs=$funcArgs"

      TEST_FIDS_ADV check_for_actions_present_in_maps_rules_cfg $cliErr $bnaErr funcArgs="$funcArgs"
    done
}
#
# This function is to block the downgrade if MAPS is enabled
# with default base policy with MAPS license.
# In case of downgrade with license, the minor versions
# doesn't have base policy.
check_ls_maps_basepolicy_with_license()
{
	maps_actpolicy_list=""

	maps_actpolicy_list=`CONFIGSHOW | /bin/grep "maps.activePolicy" | /usr/bin/cut -d ':' -f2`

#	With license, if LS is created, then the dflt_conservative_policy would have enabled
#	and will not found in config. In this case maps_actpolicy list is not set.
	if [ ! -z $maps_actpolicy_list ] && [ $maps_actpolicy_list == "dflt_base_policy" ] ; then
		isMapsLicensed=`/fabos/bin/licenseshow | /bin/grep "Fabric Vision license" | wc -l`
		if [ $isMapsLicensed -eq 1  ]; then
			return $STS_ERR
		fi
		isFWLicensed=`/fabos/bin/licenseshow | /bin/grep "Fabric Watch" | wc -l`
		isAPMLicensed=`/fabos/bin/licenseshow | /bin/grep "Performance Monitor" | wc -l`
		if [ $isFWLicensed -eq 0 ] || [ $isAPMLicensed -eq 0 ]; then 
			return $STS_OK
		else
			return $STS_ERR
		fi
	fi

	return $STS_OK
}

check_secure_syslog_enable()
{
    CONFIGSHOW -all | grep "syslog.IP.secure" > /dev/null 2>&1
    RET=$?
    if [ $RET -eq 0 ]; then
        return $STS_ERR
    fi

    return $STS_OK
}

# This function is to check whether the newly added
# russia timezone configured or not.
# If new timezone configured, block the downgrade.
check_timezone_enable()
{
	timezone=`/fabos/bin/date +%Z | grep "SAMT" -c`
	if [ $timezone -eq 1 ]; then
		return $STS_ERR
	fi

	timezone=`/fabos/bin/date +%Z | grep "SRET" -c`
	if [ $timezone -eq 1 ]; then
		return $STS_ERR
	fi

	timezone=`/fabos/bin/date +%Z | grep "ANAT" -c`
	if [ $timezone -eq 1 ]; then
		return $STS_ERR
	fi

	return $STS_OK	
}

#
# This function checks if there is any 7.4 specific software features.
# Return Error to block downgrade.
#
check_74_sw_features()
{
	$ECHO check_74_sw_features
	TEST check_xfcip_features "$XFCIP_FEATURE_RESTRICTION" "$BNA_XFCIP_FEATURE_RESTRICTION"

    TEST check_max_proxies_on_export "$SCAL_DOWN_TO_2K_PROXY_ON_EXPORT" "$SCAL_DOWN_TO_2K_PROXY_ON_EXPORT"

	TEST_FIDS check_ls_maps_basepolicy_with_license "$MAPS_BASE_POLICY_FIDS_ERR" "$BNA_MAPS_BASE_POLICY_FIDS_ERR"
	TEST check_ioanalyzer_enabled	"$IOANALYZER_ENABLED"

    check_74_blocking_maps_features
    check_maps_74_features_to_give_warning $BNA_MAPS_74_WARN
    TEST check_peer_zone_in_context
	TEST_FIDS check_avq_device_exist "$AVQ_DEVICE_EXIST" "$BNA_AVQ_DEVICE_EXIST"

    TEST check_base_sw_enabled "$BASE_SW_CONFIGURED" "$BNA_BASE_SW_CONFIGURED"

    TEST check_radius_feature_enable "$UNSUPPORTED_RADIUS_ENCRYPTION"

    # v7.3.2 supports AE ports, the following check blocks downgrade for the rest.
    if [ $TO_MAJOR -eq 7 ] && [ $TO_MINOR -eq 3 -a $TO_PATCH -lt 2 ] || [ $TO_MINOR -lt 3 ]; then
        TEST check_AE_Ports_in_context  "$AE_PORTS_EXISTS" "$BNA_AE_PORTS_EXISTS"
	TEST check_rfm_mirror_flow_in_all_contexts "$RFM_ENABLED"
    fi


	TEST check_secure_syslog_enable "$UNSUPPORTED_SECURE_SYSLOG" "$BNA_UNSUPPORTED_SECURE_SYSLOG"

	TEST check_timezone_enable "$UNSUPPORTED_DOWNGRADE_TIMEZONE"

    OVERALL_STS=$?
    if [ "$OVERALL_STS" != "$STS_OK" ]; then
        $ECHO "failed"
        RET_CODE=$OVERALL_STS
        return $RET_CODE
    fi

	return $STS_OK
}

#
# This function checks if there is any hardware that needs 7.4
# Return Error to block downgrade.
#
check_74_hw_features()
{
	$ECHO check_74_hw_features
	return $STS_OK
}

#
# This function checks if there is any 7.3 specific software features.
# Return Error to block downgrade.
#
check_73_sw_features()
{

	$ECHO check_73_sw_features

	#
	# Block downgrade to pre 7.3 when 7.3 default ciphers are 'not' set
	#
	
	TEST_FIDS check_default_cipher_config "$UNSUPPORTED_DOWNGRADE"
	TEST_FIDS check_authutil_allhash "$AUTHUTIL_CONFIGURATION_HASHSET_ALL"
	TEST_FIDS check_for_maps_decom_action_config "$MAPS_DECOM_CONFIG_ERR"
	TEST_FIDS check_for_maps_decom_rules_config "$MAPS_DECOM_RULES_CONFIG_ERR"
	TEST check_maps_netmon_enabled "$MAPS_NETMON_ENABLED" "$BNA_MAPS_NETMON_ENABLED"
	TEST check_flogi_logo_in_contexts "$NPIV_BASE_LOGO_CONFIGURED"
	TEST check_auto_max_speed_fwdl "$AUTO_MAX_SPEED_CONFIGURED" 2> ${NULL}
	TEST check_DiscFrameType "$DISC_FRM_TYPE_CONFIGURED" "$BNA_DISC_FRM_TYPE_CONFIGURED"
        TEST check_fectts_config "$FECTTS_OPTION_RESTRICTION"
	TEST check_inflight_encryption	"$INFLIGHT_ENCRYPTION_CONFIGURED"
	TEST check_lfm_mirror_flow_in_all_contexts "$LFM_ENABLED"
	TEST check_core_blade_status "$CORE_BLADE_OFF_CHECK"
	TEST check_ag_pod_license	"$POD"
	TEST check_FCOE_blades_in_dcx_pluto_plus "$FCOE_BLADE_CHECK_IN_DCX_PLUTO_PLUS"

	TEST check_xfcip_features "$XFCIP_FEATURE_RESTRICTION" "$BNA_XFCIP_FEATURE_RESTRICTION"
	TEST_FIDS check_remotefosexec_config "$REMOTE_FOSEXEC_CONFIGURED" "$BNA_REMOTE_FOSEXEC_CONFIGURED"

	# Please add all 73 software feature check above HIF test
	TEST check_HIFmode_in_context "$HIF_MODE_CONFIGURED" "$BNA_HIF_MODE_CONFIGURED"
	TEST check_maps_feature_for_73

	OVERALL_STS=$?

	if [ "$OVERALL_STS" != "$STS_OK" ]; then
		$ECHO "failed"
		RET_CODE=$OVERALL_STS
		return $RET_CODE
	fi
	TEST check_sim_port_enabled "$SIM_PORT_ENABLED"
    return $RET_CODE
}

#
# This function checks if there is any hardware that needs 7.3
# Return Error to block downgrade.
#
check_73_hw_features()
{
        $ECHO check_73_hw_features

        TEST check_windu_blades "$WINDU_BLADE_IS_PRESENT"
        OVERALL_STS=$?

        if [ $OVERALL_STS != $STS_OK ]; then
                $ECHO "failed"
                RET_CODE=$OVERALL_STS
        fi

        return $RET_CODE
}

#
# This routinue actually checks whether High Integrity Fabric Mode
# is enabled in a switch
#
cas_enabled_vf=" "
cas_flag=0
check_ficon_manual_cascading_feature()
{
	local cas_set=`correcthost_to_curr_vfid /fabos/link_abin/ficonmanualcascading --show | grep Disabled`
	if [ "$cas_set" == "" ]; then
		cas_flag=1
		if [ "$cas_enabled_vf" == " " ]; then
			cas_enabled_vf="$cas_enabled_vf $CURRENT_VF"
		else
			cas_enabled_vf="$cas_enabled_vf, $CURRENT_VF"
		fi
	fi

	# pos argument $1 maintains the number of VFs available in a switch
	eval part='$'$1 ; part=`expr $part - 1`; eval $1=$part
	# after determining HIF mode for all VFs, return Error
	if [ "$part" == "0" ] && [ "$cas_flag" == "1" ]; then
		add_err_status " * WARNING!!! Ficonmanualcasacding feature is enabled on the following FID(s):$cas_enabled_vf"
		return $STS_ERR
	fi

	return $STS_OK
}

#
# This routine resets the stale hif mode config key
#
reset_hifmode_config_key() {
	/fabos/cliexec/config set "fabric.hifmode" 2 0
	/fabos/cliexec/configcommit
}
#
# This routine checks for necessary security attribute in place for upgrade in
# FMS mode
#
fms_vf=" "
hif_warn_vf=" "
security_err=0
check_security_features_fms_mode() {
	local fms_set=`correcthost_to_curr_vfid /fabos/cliexec/config get "ficu.fmsmode" 2`
	local idid_set=`correcthost_to_curr_vfid /fabos/cliexec/config get "fabric.ididmode" 2`
	local scc_policy=`correcthost_to_curr_vfid /fabos/link_bin/secpolicydump active| grep SCC_POLICY`
	local scc_strict=`correcthost_to_curr_vfid /fabos/link_abin/fddcfg --show | grep SCC:S`

	if [ "$fms_set" == "1" ]; then
		if [ "$idid_set" == "0" ] || [ "$scc_policy" == "" ] || [ "$scc_strict" == "" ];
		then
			security_err=1
			if [ "$fms_vf" == " " ]; then
				fms_vf="$fms_vf $CURRENT_VF"
			else
				fms_vf="$fms_vf, $CURRENT_VF"
			fi
		else
		# On upgrade, Set HIF key if FMS mode and other security attributes are present
			/fabos/cliexec/config set "fabric.hifmode" 2 1
			/fabos/cliexec/configcommit
		fi
        else
                # If FMS mode is not set while the 3 security parameters are
                # set, append FID to list of HIF warning FIDs
                if [ "$idid_set" == "1" ] && [ "$scc_policy" != "" ] && [ "$scc_strict" != "" ];
                then
                        if [ "$hif_warn_vf" == " " ]; then
				hif_warn_vf="$hif_warn_vf $CURRENT_VF"
			else
				hif_warn_vf="$hif_warn_vf, $CURRENT_VF"
			fi
                fi
	fi

	# pos argument $1 maintains the number of VFs available in a switch
	eval part='$'$1 ; part=`expr $part - 1`; eval $1=$part
	# after determining HIF mode for all VFs, return Error
	if [ "$part" == "0" ]; then
		if [ "$security_err" == "1" ]; then
			# In case of error clear the HIF key that are accidentally set
			if [ $VF_ENABLED -ne $STS_OK ]; then
				if [ $ACTIVECP ] ; then
					for_all_contexts reset_hifmode_config_key
				else
					for_all_contexts_standby reset_hifmode_config_key
				fi
			else
				reset_hifmode_config_key
			fi
			add_err_status " * WARNING!!! Incorrect Security parameters in FMS mode on the following FID(s):$fms_vf"
			return $STS_ERR
		fi
		# Display HIF FICON warning if detected in any LS
		if [ "$hif_warn_vf" != " " ]; then
			echo -e $HIF_FICON_WARNING_1 $hif_warn_vf $HIF_FICON_WARNING_2
		fi
	fi

	return $STS_OK
}

#
# This routinue actually checks whether High Integrity Fabric Mode
# is enabled in a switch
#
hif_enabled_vf=" "
hif_flag=0
check_hifmode_config()
{
	local hif_set=`/fabos/cliexec/config get "fabric.hifmode" 2`
	if [ "$hif_set" != "0" ]; then
		hif_flag=1
		if [ "$hif_enabled_vf" == " " ]; then
			hif_enabled_vf="$hif_enabled_vf $CURRENT_VF"
		else
			hif_enabled_vf="$hif_enabled_vf, $CURRENT_VF"
		fi
	fi

	# pos argument $1 maintains the number of VFs available in a switch
	eval part='$'$1 ; part=`expr $part - 1`; eval $1=$part
	# after determining HIF mode for all VFs, return Error
	if [ "$part" == "0" ] && [ "$hif_flag" == "1" ]; then
		add_err_status " * WARNING!!! HIF mode is configured on the following FID(s):$hif_enabled_vf"
		return $STS_ERR
	fi

	return $STS_OK
}

#
# This is a wrapper function thats used to block downgrade from 7.3,
# if HIF mode is configured in a switch
#
check_HIFmode_in_context() 
{
	partitions=`ls -l /proc/fabos/switch | grep -v total | wc -l`
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ]; then
			for_all_contexts check_hifmode_config partitions
		else
			for_all_contexts_standby check_hifmode_config partitions
		fi
	else
		check_hifmode_config partitions
	fi

	if [ "$?" -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#
# This is a function thats used to block downgrade from 7.3,
# if Remote Fosexec feature is configured on a switch
#
check_remotefosexec_config()
{
	fosexec_set=`/fabos/cliexec/config get fabric.remoteFosexec 2`
	if [ "$fosexec_set" != "0" ]; then
		return $STS_ERR
	fi

	return $STS_OK
}

#
# This function checks whether a peer zone is present in the effective zone
# configuration of a switch
#
peer_zone_enabled_vf=" "
peer_zone_flag=0
check_peer_zone_config()
{
	local peer_zone_set=`correcthost_to_curr_vfid /fabos/cliexec/ns peerzonetest`

	if [ "$peer_zone_set" == "peer zone exists" ]; then
		peer_zone_flag=1
		peer_zone_enabled_vf="$peer_zone_enabled_vf $CURRENT_VF"
	fi

	# pos argument $1 maintains the number of VFs available in a switch
	eval part='$'$1 ; part=`expr $part - 1`; eval $1=$part
	# after checking for all VFs, display warning
	if [ "$part" == "0" ] && [ "$peer_zone_flag" == "1" ]; then
		if [ $VF_ENABLED -ne $STS_OK ]; then
			echo "$PEER_ZONE_CONFIGURED  Affected FID(S):$peer_zone_enabled_vf"
		else
			echo "$PEER_ZONE_CONFIGURED"
		fi
	fi

	return $STS_OK
}

#
# This function displays a warning message if a peer zone is present
# in the effective configuration
#
check_peer_zone_in_context() 
{
	partitions=`ls -l /proc/fabos/switch | grep -v total | wc -l`
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ]; then
			for_all_contexts check_peer_zone_config partitions
		else
			for_all_contexts_standby check_peer_zone_config partitions
		fi
	else
		check_peer_zone_config partitions
	fi

	if [ "$?" -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#
# This function is used to block downgrade from 7.4,
# to <7.4 releases if auto VC quarantined device exist
# in the fabric
#
check_avq_device_exist()
{
	avq_bit_set_local=`correcthost_to_curr_vfid /fabos/link_bin/nsshow | grep "Slow Drain Device: Yes"`
	avq_bit_set_remote=`correcthost_to_curr_vfid /fabos/link_bin/nscamshow | grep "Slow Drain Device: Yes"`

	if [ "$avq_bit_set_local" == "" ] && [ "$avq_bit_set_remote" == "" ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

check_perf_mon_installed_all_context()
{
	if [ $VF_ENABLED -ne $STS_OK ]; then
		if [ $ACTIVECP ] ; then
			for_all_contexts check_perf_mon_installed
		else
			for_all_contexts_standby check_perf_mon_installed
		fi
	else
		check_perf_mon_installed
	fi

	if [ "$?" -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#
# This function is used to block upgrade to 7.4 if performance monitor
# configurations are present on the switch
#
check_perf_mon_installed()
{
	fmon_count=`CONFIGSHOW | grep "perf.framemonc." | /usr/bin/cut -d '|' -f4 | grep -c "[0-9]"`
	if [ $fmon_count -ne 0 ]; then
		return $STS_ERR
	fi

	# If base switch then skip checking if EE monitor and TT monitors are
	# present. They will be removed as a part of postinstall.
	BASE=`correcthost_to_curr_vfid /fabos/bin/switchshow | grep "Base Switch:" | cut -d ' ' -f 6 | cut -d ',' -f 1`
	if [ "$BASE" == "Yes" ]; then
		return $STS_OK
	fi

	eemon_count=`CONFIGSHOW | grep -c "eemonc\."`
	if [ $eemon_count -ne 0 ]; then
		return $STS_ERR
	fi
	ttmon_count=`CONFIGSHOW | grep -c "ttmonc"`
	if [ $ttmon_count -ne 0 ]; then
		return $STS_ERR
	fi

	return $STS_OK
}

#
#
# This routine check if at most timeout discard frame type is enabled
#
check_DiscFrameType()
{
	local disc_frm_type=`cat /etc/fabos/fabos.0.conf | grep framelog.*type`

	if [ -n "$disc_frm_type" ]; then
		disc_frm_type=${disc_frm_type:23}
		if [ "$disc_frm_type" != "1" ]; then
			return $STS_ERR
		fi
	fi

	return $STS_OK
}

check_radius_feature_enable()
{
    #
    # Check radius configurations encryption level is ON
    #
    result=`/fabos/abin/aaaconfig --show | grep "Encryption level  : AES256" | wc -l`
    if [ $result -ge 1 ]; then
        return $STS_ERR
    fi

    return $STS_OK

}

#
# This routine checks fcap protocol configured with in-flight encryption.
#
check_inflight_encryption() {

    if [ $VF_ENABLED -ne $STS_OK ]; then
        CHASSISCMD="cmd_chassis"
        # VF is enabled
        if [ $ACTIVECP ] ; then
            for_all_contexts check_authutil_fcap_set
        else
            # this is the standby cp 
            for_all_contexts_standby check_authutil_fcap_set
        fi
    else
        check_authutil_fcap_set
    fi
    if [ "$?" -eq 0 ]; then
        return $STS_OK
    else
        return $STS_ERR
    fi
}

#check for any POD license is installed in the switch
check_ag_pod_license()
{
	ag_mode_enabled
	if [ $? -gt 0 ]; then
		# Check for POD License in SPIRIT,TOMAHAWK,STINGER and TOMTOO only.
		if [ ${SWBD##SWBD} == '66' ] || [ ${SWBD##SWBD} == '71' ] || [ ${SWBD##SWBD} == '109' ] || [ ${SWBD##SWBD} == '118' ]; then
			if [ ${SWBD##SWBD} == '118' ]; then
				POD_LIC=1;
			else 
				POD_LIC=2;
			fi
			Full_POD=`/fabos/bin/licenseshow | grep -c "Full Ports on Demand license"`
			if [ $Full_POD -ge 1 ]; then
				return $STS_OK
			else
				pod=`/fabos/bin/licenseshow | grep -c "Ports on Demand license"`
				if [ $pod -ge $POD_LIC ]; then
					return $STS_OK 	
				else
					return $STS_ERR 	
				fi
			fi
		else
			return $STS_OK
		fi
	else 
		return $STS_OK
	fi
}

check_authutil_fcap_set()
{
	ret=$STS_OK

    encryption_port=`correcthost_to_curr_vfid /fabos/cliexec/portenccompshow | grep "Yes" | wc -l`
    if [ $encryption_port -ne $STS_OK ]; then
        fcap_set=`correcthost_to_curr_vfid /fabos/sbin/authutil --show | grep "fcap" | wc -l`
        if [ $fcap_set -ne $STS_OK ]; then
            ret=$STS_ERR
        else
            ret=$STS_OK
        fi
    else
        ret=$STS_OK
    fi

    return $ret
}

#
# Fabric Watch is deprecated in FOS 7.4. Check for maps migration.
#
check_74_fw_to_maps_migration_warn()
{
	migrate=0

	migrate=`CONFIGSHOW -chassis | /bin/grep "maps.migrated" | /usr/bin/cut -d ':' -f2`

	#
	# before upgrade to 7.4, if maps is not enabled, then display the warnings.
	#
	if [ -n "$migrate" ]; then
		if [ $migrate -ne 1 ]; then

			echo -e $MIGRATE_TO_MAPS_WARN_MSG
			# log warn msg to BNA status file
			echo -e $BNA_MIGRATE_TO_MAPS_WARN_MSG >> $BNA_STATUS_FILE
		fi
	fi

	return $STS_OK

}

#
# Warning for MAPs rule cleanup
#
check_74_mapsrule_cleanup()
{
	swbd=`sin | awk ' {print $2} ' | grep SWBD | sed 's@,@@'`
	if [ $swbd == "SWBD118" ]; then
		ruleCount=`mapspolicy --show -all | grep -E "defCHASSISBAD_PWR_CRIT|defCHASSISBAD_PWR_MARG|defCHASSISBAD_FAN_MARG|defCHASSISBAD_FAN_CRIT" | wc -l`
		if [ $ruleCount -gt 0 ]; then
			echo -e $MAPS_PS_RULE_DELETION
			echo -e $BNA_MAPS_PS_RULE_DELETION >> $BNA_STATUS_FILE
		fi
	fi
	return $STS_OK
}


#
# HIF feature upgrade checks
#
# Please copy this checks to all the future releases
#			(WITHOUT FAIL)
#
hif_feature_upgrade_to_73_or_later()
{
	
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -lt 3 ]; then

		TEST clear_hifmode_key_chassis "$HIFMODE_RESET_FAILED"
		TEST verify_fms_mode_features "$SECURITY_ATTRIB_FOR_FMS" "$BNA_SECURITY_ATTRIB_FOR_FMS"
		TEST verify_ficon_manual_casc_feature "$ERROR_FICON_MAN_CASCADING" "$BNA_ERROR_FICON_MAN_CASCADING" 
	fi
	return $STS_OK
}

#
# This is upgrade to 7.4 case
# Disallow upgrade with 24-bit/legacy licenses present except for selected OUI's
#
check_24_bit_license_migration_check()
{
    OLD_LICENSE_FILE=/etc/fabos/licenses

    # if no file, no older licenses are installed
    if [ ! -e $OLD_LICENSE_FILE ] ; then
        # echo "No older licenses found"
        return $STS_OK
    fi
    # echo "Older licenses found" # REMOVE ME

    licenses=`ls -l $OLD_LICENSE_FILE | awk -F " " '{ print $5 }'`

    if [ -n "$licenses" ]; then
        if [ "$licenses" -gt 0 ]; then
            oui=`/fabos/cliexec/licenseidshow | awk -F ":" '{ print $3 $4 $5 }'`
            if  [ $oui == "50eb1a" ] ; then return $STS_OK; fi
            if  [ $oui == "0027f8" ] ; then return $STS_OK; fi
            if  [ $oui == "006069" ] ; then return $STS_OK; fi
            if  [ $oui == "00051e" ] ; then return $STS_OK; fi
            if  [ $oui == "00110a" ] ; then return $STS_OK; fi
            if  [ $oui == "000533" ] ; then return $STS_OK; fi
            #if  [ $oui == "c4f57c" ] ; then return $STS_OK; fi # test only - REMOVE ME

            # echo -e $ERROR_24_BIT_LICENSES
            # echo $ERROR_24_BIT_LICENSES >> $STATUS_FILE
            # echo $ERROR_24_BIT_LICENSES >> $BNA_STATUS_FILE
            return $STS_ERR
        fi
    fi
    return $STS_OK
}

#
handle_to_74()
{

	$ECHO handle_to_74

	#
	# We don't allow 7.1 and previous to upgrade to this version
	#
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -le 1 -o $CUR_MAJOR -lt 7 ]; then
		#check if it is an embedded platfrom SH3 or Pharos or Dragon2T
		if [ ${SWBD##SWBD} == '130' ] || [ ${SWBD##SWBD} == '125' ] || [ ${SWBD##SWBD} == '117' ]; then
			add_err_status "$UNSUPPORTED_EMBD_UP_VERMSG" "$BNA_UNSUPPORTED_EMBD_UP_VERMSG"
			return $STS_ERR
		else
			add_err_status "$UNSUPPORTED_UP_VERMSG" "$BNA_UNSUPPORTED_UP_VERMSG"
			return $STS_ERR
		fi
	fi

	#
	# Allow only disruptive Firmware download from 7.2
	#

	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 2 ]; then
		# Upgrading to v7.4.1d (version with UID0/FIle permissions changes)
		# allow_disruptive_single_mode_fwdl
		# if [ $? -ne $STS_OK ]; then
			add_err_status "$UNSUPPORTED_72_TO_74_FWDL" "$BNA_UNSUPPORTED_72_TO_74_FWDL"
			return $STS_ERR
		# fi
	fi

	#
	# Note to developers:
	# ----------------------------------------------
	# Below routine is to test HIF Security parameters on upgrade
	# Please copy this check to all the release handle from v7.4.x
	#
	hif_feature_upgrade_to_73_or_later

	# Block firmwareupgrade to 7.4 from 7.2 when SIM ports are present.
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 2 ]; then
		TEST check_sim_port_enabled "$SIM_PORT_ENABLED"
	fi

	#
	# Fabric Watch is deprecated in 7.4. Warning message to migrate to maps.
	#
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -le 3 ]; then
		TEST check_74_fw_to_maps_migration_warn
	fi

	#
	# APM is deprecated in 7.4
	#
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 2 -o $CUR_MINOR -eq 3 ]; then
		TEST check_perf_mon_installed_all_context "$APM_CONFIG_EXIST" "$BNA_APM_CONFIG_EXIST"
	fi

	#If the upgrade is from build < 7.4.1d to build => 7.4.1d then the check_features.sh.in doesn't 
	#contain code of keeping new preinst in /tmp/ as a backup. so initializing the path manually.
	if ! [ -f $NEW_PREINST ] ; then
		NEW_PREINST="$0"
	fi

	# Since some of the things will not be cleared in config replay. RFM needs to be
	# deactivated before the downgrade from 7.4.1 to 7.4.0

	# Tagged features checking is recommended to be done in check_features.sh.in
	# (only the tag is required to be added in preinst to flag support for the feature)
	# The checking is being done here (for this feature) on an exceptional basis due to prior history.
	# We do not want this to be replicated via cut/paste for future features
	check_rfm_compatibility
	check_rfm_ecb_compatibility

	TEST check_24_bit_license_migration_check "$ERROR_24_BIT_LICENSES" "$BNA_ERROR_24_BIT_LICENSES"
	TEST check_invalid_mapsrules "$INVALID_MAPSRULES" "$BNA_INVALID_MAPSRULES"
	TEST check_74_mapsrule_cleanup 
	return $RET_CODE
}

#
# Reset HIF config key ONLY on firmware upgrades, to avoid any nuisance of
# stale config. Anyways this key is not used in lower version firmware.
#
clear_hifmode_key_chassis()
{
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ] ; then
			for_all_contexts reset_hifmode_config_key
		else
			for_all_contexts_standby reset_hifmode_config_key
		fi
	else
		reset_hifmode_config_key
	fi

	if [ "$?" -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#
# Following routine checks for the necessary security parameters to be in place
# for upgrade to 7.3 or later in FMS mode. It will prevent user from upgrade,
# if any of the parameters is missing.
#
verify_fms_mode_features()
{
	partitions=`ls -l /proc/fabos/switch | grep -v total | wc -l`
	if [ $VF_ENABLED -ne $STS_OK ]; then
		chassiscmd="cmd_chassis"
		if [ $ACTIVECP ] ; then
			for_all_contexts check_security_features_fms_mode partitions 
		else
			for_all_contexts_standby check_security_features_fms_mode partitions
		fi
	else
		check_security_features_fms_mode partitions
	fi

	if [ "$?" -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#
# Prevent firmware upgrade to 7.3 if ficon manual cascading feature is enabled
#
verify_ficon_manual_casc_feature()
{
	partitions=`ls -l /proc/fabos/switch | grep -v total | wc -l`
	if [ $VF_ENABLED -ne $STS_OK ]; then
		CHASSISCMD="cmd_chassis"
		if [ $ACTIVECP ]; then
			for_all_contexts check_ficon_manual_cascading_feature partitions
		else
			for_all_contexts_standby check_ficon_manual_cascading_feature partitions
		fi
	else
		check_ficon_manual_cascading_feature partitions
	fi

	if [ "$?" -eq $STS_OK ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

#
# This is downgrade to 7.3 case
#
handle_to_73()
{

	$ECHO handle_to_73

		TEST check_ex_ports_IM "$McDATA_EX_PORT_RESTRICTION" "$BNA_McDATA_EX_PORT_RESTRICTION"
		TEST check_vex_ports_IM "$McDATA_EX_PORT_RESTRICTION" "$BNA_McDATA_EX_PORT_RESTRICTION"
		check_snmp_73_priv_proto
		if [ $? -ne $STS_OK ]; then
			add_err_status "$UNSUPPORTED_SNMP_73_PRIV_PROTO" "$BNA_UNSUPPORTED_SNMP_PRIVPROTOCOL"
			RET_CODE=$STS_ERR
		fi

	#
	# Block downgrade if any 7.4 specific sw  and feature is enabled.
	#
	check_74_sw_features
	check_74_hw_features
	if [ $RET_CODE -ne $STS_OK ]; then
		return $RET_CODE
	fi

	#
	# Routine to test HIF Security parameters on upgrade
	# Please copy this check to all the releases
	#
	hif_feature_upgrade_to_73_or_later

	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -lt 3 ]; then

		TEST_FIDS check_default_cipher_config "$UNSUPPORTED_UPGRADE"
		TEST check_sim_port_enabled "$SIM_PORT_ENABLED"

	fi

	return $RET_CODE

}

check_fips_mode() {
	if /fabos/abin/fipscfg --show | grep "FIPS mode" | grep Enabled > /dev/null 2>&1 ;then
		return 1
	fi
}

check_authutil_allhash() {

	check_fips_mode
	if [ $? -eq 1 ]; then
		fipsmode=1
	else
		fipsmode=0
	fi

	if [ $TO_MAJOR -eq 7 -a $TO_MINOR -eq 2 -a $TO_PATCH -eq 1 ] &&
		[ $fipsmode -eq 1 ]; then
			return $STS_OK
	fi
		check_authutil_hashset $@
	if [ $? -eq 0 ]; then
		return $STS_OK
	else
		return $STS_ERR
	fi
}

check_authutil_hashset() {
	ret=$STS_OK
	if /fabos/sbin/authutil --show | grep "sha256" > /dev/null  2>&1 ;then
		ret=$STS_ERR
	fi
	return $ret
}

check_default_cipher_config()
{
	ret=$STS_OK
	cipher_string=`/fabos/cliexec/config get cipher.https 5`
	if [ $cipher_string == "!ECDH:!DH:HIGH:-MD5:!CAMELLIA:!SRP:!PSK:!AESGCM" ] || [ $cipher_string == "!DH:HIGH:-MD5" ]; then
		cipher_default=1
	else
		cipher_default=0
	fi
        if [ "$cipher_default" -eq 0 ]; then
		ret=$STS_ERR
	fi
	return $ret
}

#
# This is downgrade to 7.2 case
#

handle_to_72()
{
	$ECHO handle_to_72

	#
	# Allow only disruptive download to 7.2
	#
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 4 ]; then
		allow_disruptive_single_mode_fwdl
		if [ $? -ne $STS_OK ]; then
			add_err_status "$UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL" "$BNA_UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL"
			return $STS_ERR
		fi
	fi

	
	#
	# Block downgrade if any 7.4 specific sw feature is enabled.
	#
	check_74_sw_features
	check_73_sw_features
	check_73_hw_features
	check_74_hw_features
	if [ $RET_CODE -ne $STS_OK ]; then
		return $RET_CODE
	fi

	# From 7.2.0 3DES, AES192, AES256 are not supported. So if any user is configured with such protocols
	# then firmware upgrade to 7.2.0 has to be blocked.
	TEST check_snmp_priv_protocol "$UNSUPPORTED_SNMP_PRIVPROTOCOL" "$BNA_UNSUPPORTED_SNMP_PRIVPROTOCOL"

    #
    # to display warning msg about changes in default qos port configuration
    #
    if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -lt 2 ]; then
        display_default_qosmode_warning_msg
    fi

	if [ $CUR_MAJOR -ge 7 -a $CUR_MINOR -ge 2 -a $CUR_PATCH -ge 1 -a $TO_PATCH -lt 1 ]; then
		TEST_FIDS check_authutil_allhash "$AUTHUTIL_CONFIGURATION_HASHSET"
		OVERALL_STS=$?
        if [ $OVERALL_STS != $STS_OK ]; then
			RET_CODE=$OVERALL_STS
		fi
    fi
	return $RET_CODE
}


#
# This is downgrade to 7.1 case
#
handle_to_71()
{
	$ECHO handle_to_71

	#
	# Allow only disruptive download to 7.1
	#
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 3 ]; then
		allow_disruptive_single_mode_fwdl
		if [ $? -ne $STS_OK ]; then
			add_err_status "$UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL" "$BNA_UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL"
			return $STS_ERR
		fi
		# Active running < 7.3 already. No check reqd
        if [ $HA_ROLE == "STANDBY" -a $PEER_MINOR -lt 3 ]; then
            OVERALL_STS=$STS_OK
        else
			ret=`correcthost_all_vfs /fabos/cliexec/ntplen | grep "FAIL" | wc -l`
			if [ $ret -ne 0 ]; then
				OVERALL_STS=$STS_ERR
			else
				OVERALL_STS=$STS_OK
			fi
        fi

		if [ $OVERALL_STS != $STS_OK ]; then
			add_err_status "$NTP_LENGTH"
			RET_CODE=$OVERALL_STS
		fi
	fi

	#
	# Block downgrade if any 7.3 specific sw feature is enabled.
	#
	check_73_sw_features

	#
    # Block downgrade to pre 7.3 when Windu blade is present
    #
    check_73_hw_features
	#
	# check pre ElDorado features present.
	#
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -lt 1 ] || [ $CUR_MAJOR -eq 6 ]; then
		check_pre_71_hw_features
		check_pre71_sw_features
	fi	
	
	# Block downgrade if Ex port configured on ICLs
	TEST check_icl_ex_port_configuration  "$EX_PORT_ICL_NOT_SUPPORTED"
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		RET_CODE=$OVERALL_STS
	fi

	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -lt 1 ] || [ $CUR_MAJOR -eq 6 ]; then
		#
		# Block Upgrade 7.0 -> 7.1 if Ex-Port configured in McDATA mode.
		# The IM1, IM2 and IM3 modes are removed from Eldorado release.
		#
		TEST check_ex_ports_IM "$McDATA_EX_PORT_RESTRICTION" "$BNA_McDATA_EX_PORT_RESTRICTION"
		TEST check_vex_ports_IM "$McDATA_EX_PORT_RESTRICTION" "$BNA_McDATA_EX_PORT_RESTRICTION"
	fi
	#
    # Block 7.2 -> 7.1 if 7.2 feature is enabled
    #
	check_72_sw_features

	return $RET_CODE

}

#
# This is downgrade to 7.0 case. This handle is not cleaned up since few embeded releases
# may require downgrade to 7.0. Currently downgrade to 7.0 is blocked and this handle
# will not be called.
#
handle_to_70()
{
	$ECHO handle_to_70

	#
	# Allow only disruptive download to 7.0
	#
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 2 ]; then
		allow_disruptive_single_mode_fwdl
		if [ $? -ne $STS_OK ]; then
			add_err_status "$UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL" "$BNA_UNSUPPORTED_NON_DISRUPTIVE_MODE_FWDL"
			return $STS_ERR
		fi
	fi

	#
	# Block for 7.0.1 -> 7.0.0 for Tom-2
	#
	if [ ${SWBD##SWBD} == '118' ]; then 
		if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 0 -a $CUR_PATCH -gt 0 ] ||
			[ $CUR_MAJOR -eq 7 -a $CUR_MINOR -gt 0 ]; then
			if [ $TO_MAJOR -eq 7 -a $TO_MINOR -eq 0 -a $TO_PATCH -eq 0 ]; then
				add_err_status "$UNSUPPORTEDPLATFORMMSG" "$BNA_UNSUPPORTEDPLATFORMMSG"
				return $STS_ERR
			fi
		fi
	fi

	#
        # Block downgrade to pre 7.3 when Windu blade is present
        #
        check_73_hw_features
        if [ $? -ne $STS_OK ]; then
                return $STS_ERR
        fi

	# Block downgrade to 7.0.0 in Dcx+ and Pluto+ when
	# FC8-16 or FC8-32 or FC8-48 is present.
	if [ $TO_MAJOR -eq 7 -a $TO_MINOR -eq 0 -a $TO_PATCH -eq 0 ]; then
		TEST check_FC8_blades_dcx_pluto_plus "$FC8_BLADE_IS_PRESENT" "$BNA_FC8_BLADE_IS_PRESENT"
		if [ $? -ne $STS_OK ]; then
			return $STS_ERR
		fi
	fi

	#
	# Block if any FCIP feature checks fail
	#
	TEST check_xfcip_features "$XFCIP_FEATURE_RESTRICTION" "$BNA_XFCIP_FEATURE_RESTRICTION"
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi

    check_71_0_enc_sw_features
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi
	#
	# Block if any condor ex-port present
	#
	TEST check_condor_ex_ports_configured "$CONDOR_EX_PORT_RESTRICTION" "$BNA_CONDOR_EX_PORT_RESTRICTION"
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi
	#
	# Check for the co-existence of Marathon and Striker blades
	#
	TEST check_blades_marathon_striker_enabled "$MARATHON_STRIKER_ERR_MSG" "$BNA_MARATHON_STRIKER_ERR_MSG"
	if [ $? -ne $STS_OK ]; then
		return $STS_ERR
	fi

	#
	# Block downgrade if any Enhanced FC8 blade is present.
	#
	check_enhanced_fc8_present
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi

	# Block downgrade if Ex port configured on ICLs
	TEST check_icl_ex_port_configuration  "$EX_PORT_ICL_NOT_SUPPORTED"
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi

	check_sec_auth_certificate_database_for_brcd
	if [ $? -ne $STS_OK ]; then
		add_err_status "$UNSUPPORTED_BRCD_CERTIFICATE_DATABASE_VALUE" "$BNA_UNSUPPORTED_BRCD_CERTIFICATE_DATABASE_VALUE"
		return $STS_ERR
	fi

	#
	# Block downgrade to lower versions if ports are configured with longdistance
	# -buffer option.
	#
	check_longdist_buffer_option_ports 
	if [ $? -ne $STS_OK ]; then
		add_err_status "$LONGDIST_BUFFER_OPTION_RESTRICTION"
		return $STS_ERR
	fi


	if [ $TO_MAJOR -eq 7 -a $TO_MINOR -eq 0 -a $TO_PATCH -eq 0 ]; then
		check_70_1_sw_features
		OVERALL_STS=$?
		if [ $OVERALL_STS != $STS_OK ]; then
			return $OVERALL_STS
		fi
	fi
	
	#
	# Block 7.1 -> 7.0 if 7.1 feature is enabled
	#
	check_71_sw_features
	OVERALL_STS=$?
	if [ $OVERALL_STS != $STS_OK ]; then
		return $OVERALL_STS
	fi

	#
    # Block 7.2 -> 7.0 if 7.2 feature is enabled
    #
	if [ $CUR_MAJOR -eq 7 -a $CUR_MINOR -eq 2 ]; then
	    check_72_sw_features
	fi
    OVERALL_STS=$?
    if [ $OVERALL_STS != $STS_OK ]; then
        return $OVERALL_STS
    fi
}

asic_db_blade_type_() {

	# initialize to unknown blade id & type
	blade_type=""
	num_c2s=0
	if test -f /proc/fabos/blade/$1/info; then

		# ref. blade id is defined in linux/include/brocade/swbd.h		
		bladeid=`cat /proc/fabos/blade/$1/info | /bin/grep --binary-files=text bladeId | sed 's/[^0-9]//g'`

      case "$bladeid" in
		"58" ) blade_type="littlebear";num_c2s=1;;
		"60" ) blade_type="bulova";num_c2s=1;;
		"61" ) blade_type="blazer3";num_c2s=1;;
		"63" ) blade_type="superhawk2";num_c2s=1;;
		"64" ) blade_type="utah";num_c2s=1;;
		"70" ) blade_type="falcon2";num_c2s=1;;
		"73" ) blade_type="kestrel2";num_c2s=1;;
		"37" ) blade_type="despina";num_c2s=1;;
		"55" ) blade_type="larissa";num_c2s=2;;
		"51" ) blade_type="triton";num_c2s=2;;
		"46" ) blade_type="hydra";num_c2s=2;;
		"56" ) blade_type="spirit";num_c2s=1;;
		"79" ) blade_type="gladius";num_c2s=1;;
		"59" ) blade_type="tomahawk";num_c2s=1;;
		"53" ) blade_type="thor";num_c2s=9;;
		"52" ) blade_type="proteus";num_c2s=4;;
		"77" ) blade_type="quattro";num_c2s=4;;
		"45" ) blade_type="elara";num_c2s=1;;
		"74" ) blade_type="europa";num_c2s=1;;
		"69" ) blade_type="spike";num_c2s=1;num_blaster=1;;
		"75" ) blade_type="striker";num_c2s=1;num_blaster=2;;
		"42" ) blade_type="mace";num_c2s=2;;
		"43" ) blade_type="lance";num_c2s=2;;
		* ) blade_type="others";num_c2s=0;
      esac

	fi
}

# This is to block firmwaredownload from Coruscant
# to 7.1 or previous versions of 7.1
handle_to_71_lower()
{
	$ECHO handle_to_71_lower
	#check if it is an embedded platfrom SH3 or Pharos or Dragon2T
	if [ ${SWBD##SWBD} == '130' ] || [ ${SWBD##SWBD} == '125' ] || [ ${SWBD##SWBD} == '117' ]; then
		add_err_status "$UNSUPPORTED_EMBD_DL_VERMSG" "$BNA_UNSUPPORTED_EMBD_DL_VERMSG"
		return ${STS_ERR}
	else
		add_err_status "$UNSUPPORTED_DL_VERMSG" "$BNA_UNSUPPORTED_DL_VERMSG"
		return ${STS_ERR}
	fi
}

# get the current firmware version
get_current_version()
{
	CUR_MAJOR=$(/sbin/getfabosver | sed -n -e 's/Major://gp')
	CUR_MINOR=$(/sbin/getfabosver | sed -n -e 's/Minor://gp')
	CUR_PATCH=$(/sbin/getfabosver | sed -n -e 's/Patch://gp')
	PEER_MAJOR=$(correcthost /sbin/getfabosver | sed -n -e 's/Major://gp')
	PEER_MINOR=$(correcthost /sbin/getfabosver | sed -n -e 's/Minor://gp')
	
}

# Function to check whether marathon and striker blades are present.
# If both the blades are present, then the firmwaredownload needs
# to be blocked
check_blades_marathon_striker_enabled()
{
	STRIKER_PRESENT=0
	MARATHON_PRESENT=0
	blade_count=0

	slotshow_out=`/fabos/cliexec/slotshow -d576 | /bin/grep "AP BLADE" | /bin/sed 's/[ \t][ \t]*/;/g'`
	blade_count=`echo $slotshow_out | /bin/grep "BLADE" | /usr/bin/wc -w`

	if [ $blade_count -le 1 ]; then
		return $STS_OK
	fi

	count=1

	while [ $count -le $blade_count ]
	do
		temp_str=`echo $slotshow_out | /usr/bin/cut -d ' ' -f $count`
		blade_id=`echo $temp_str | /usr/bin/cut -d ';' -f 5`

		if [ $blade_id -eq 75 ]; then
			STRIKER_PRESENT=1
		elif [ $blade_id -eq 24 ]; then
			MARATHON_PRESENT=1
		fi

		count=`/usr/bin/expr $count + 1`
	done

	if [ $STRIKER_PRESENT -eq 1 -a $MARATHON_PRESENT -eq 1 ]; then
		ret=$STS_ERR
	else
		ret=$STS_OK
	fi

	if [ $ret -eq $STS_OK ]; then
		if [ $MARATHON_PRESENT -eq 1 -a $STRIKER_PRESENT -eq 0 ]; then
			DISPLAY_MARATHON_STRIKER_WARN_MSG=1	
		fi
	fi

	return $ret
}

#
# main()
#
#$ECHO Requested version is ${TO_MAJOR}.${TO_MINOR}.${TO_PATCH} Type is $TYPE

if [ -z $TYPE ]; then
	TEST check_hcl_switchstate "$SWITCH_FAULTY_MSG" "$BNA_SWITCH_FAULTY_MSG"
	RET=$?
	if [ $RET != $STS_OK ]; then
		exit $RET_CODE
	fi

	#
	# clean up to free up disk space on /mnt before firmwaredownload
	#
	$ECHO removing tracedump.dmp
	rm -f /mnt/var/tracedump.dmp
	# Overwrite raslog.int and raslog.ext file with FWDL version
	# This ensures that we do not overwrite the raslog files of new standby with
	# new active CP files.
	RASLOG_INT_FILE=/mnt/etc/raslog.int
	RASLOG_EXT_FILE=/mnt/etc/raslog.ext

	echo "RASLOG" > $RASLOG_INT_FILE
	echo "RASLOG" > $RASLOG_EXT_FILE
fi

get_current_version
#
# Handle a downgrade to less than 7.2.1
#
if [ $TO_MAJOR -eq 7 -a $TO_MINOR -eq 2 -a $TO_PATCH -lt 1 ]; then
	SSHD_CONFIG_FILE=/etc/sshd_config
	SSH_CONFIG_FILE=/etc/ssh_config
	SSHD_CONFIG_FILE_MNT=/mnt/etc/sshd_config
	SSH_CONFIG_FILE_MNT=/mnt/etc/ssh_config
	GREP=/bin/grep
	ret=STS_OK

	FABOS_SWITCHNO_TEMP=$FABOS_SWITCHNO
	FABOS_SWITCHNO=0
	retVal=`/fabos/cliexec/config get fips.mode 2`
	FABOS_SWITCHNO=$FABOS_SWITCHNO_TEMP
	if [ $retVal -eq 1 ]; then
		#check in /etc
		if $GREP "^ShaValue" $SSH_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi		
		if $GREP "^MinPrime" $SSH_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^ServerHostKeySize" $SSH_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^KexAlgorithms diffie-hellman-group-exchange-sha256" $SSH_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi

		if $GREP "^ShaValue" $SSHD_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^MinPrime" $SSHD_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^KexAlgorithms diffie-hellman-group-exchange-sha256" $SSHD_CONFIG_FILE >/dev/null ; then		
			ret=STS_ERR
		fi
		
		#check in /mnt/etc
		if $GREP "^ShaValue" $SSH_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^MinPrime" $SSH_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^ServerHostKeySize" $SSH_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^KexAlgorithms diffie-hellman-group-exchange-sha256" $SSH_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi

		if $GREP "^ShaValue" $SSHD_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^MinPrime" $SSHD_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi
		if $GREP "^KexAlgorithms diffie-hellman-group-exchange-sha256" $SSHD_CONFIG_FILE_MNT >/dev/null ; then		
			ret=STS_ERR
		fi
		if [ $ret == STS_ERR ]; then
			add_err_status "$UNSUPPORTED_DOWNGRADE_721"		
			exit $STS_ERR
		fi
	fi
fi

#
# Handle a specific firmware version
#
case "${TO_MAJOR}.${TO_MINOR}" in
	'7.4')
		handle_to_74
		RET=$?
	;;
	'7.3')
		handle_to_73
		RET=$?
	;;
	'7.2')
		handle_to_72
		RET=$?
	;;
		*)
		handle_to_71_lower
		RET=$?
	;;
esac

#
# Preinstall check fails
#
if [ $RET != $STS_OK ]; then
	exit $RET;
fi

#
# Preinstall checks passed - check for HCL readiness
#
# This will not actually prevent any firmware operation from continuing
# but will just print any warnings to the user and fall through to the
# normal FWDL prompt asking if they wish to proceed.
check_fcip_hcl

# Pre-installation has completed successfully. Need to print the
# Marathon-striker warning message before firmwaredownload starts
if [ -z $TYPE ]; then
	if [ $DISPLAY_MARATHON_STRIKER_WARN_MSG -eq 1 ]; then
		echo -e "\n$MARATHON_STRIKER_WARN_MSG\n"
		echo -e "$BNA_MARATHON_STRIKER_WARN_MSG" >> $BNA_STATUS_FILE
	fi
fi

#
# remove /mnt/var/images so it will not run into
# "Unable to uninstall old packages" issue when attempting to remove bpimage-swbd36
# If not doing firmwaredownload -s then remove it from the standbyCP as well
#
rm -rf /mnt/var/images/* 2>/dev/null
is_fwdl_arg "s"
if [ $? -ne 0 ]; then
	pizzabox=$(/fabos/link_bin/hashow | grep -c "Not supported on this platform") 2>/dev/null
	if [ $pizzabox -eq 0 ]; then
		#
		# Remove these only on chassis switches
		#
		/usr/bin/rsh -n $(otherhost) ROLE_ID=root LOGIN_ID=root CURRENT_AD=0 "/bin/rm -rf /mnt/var/images/*" 2>/dev/null
	fi
fi

#
# Firmwaredownload check passes, return
#
if [ -z $TYPE ]; then
	$ECHO return code is $RET
	exit $RET
fi

#
# For firmwarerestore, we will perform the firmwarerestore here.
# it will not return to the caller. That is to workaround a
# 2.4.19 kernel and 2.3.6 glibc mismatch issue. (79299). Read
# more comments in fwdl_undo() in the fwdl.c file.
#
baddev=`bootenv BadRootDev 2>/dev/null`
upgrade=`bootenv Upgrade 2>/dev/null`
softupgrade=`bootenv SoftUpgrade 2>/dev/null`
osloader=`bootenv OSLoader 2>/dev/null`

dev_p=`bootenv OSRootPartition 2>/dev/null | cut -d ';' -f 1`
dev_s=`bootenv OSRootPartition 2>/dev/null | cut -d ';' -f 2`
kern_p=`bootenv OSLoader 2>/dev/null | cut -d ';' -f 1`
kern_s=`bootenv OSLoader 2>/dev/null | cut -d ';' -f 2`

mount_p=`cat /proc/mounts | grep " / " | grep -v rootfs |sed 's? .*??g;s?^.*dev/??g'`
mount_s=`cat /proc/mounts |grep "/mnt" | sed 's? .*??g;s?^.*dev/??g'`

if [ -n "$baddev" ]; then
	add_err_status "$FWDL_RUNNING_MSG" "$BNA_FWDL_RUNNING_MSG"
    	exit 1;
fi

if [ -n "$softupgrade" ]; then
	add_err_status "$FWDL_RUNNING_MSG" "$BNA_FWDL_RUNNING_MSG"
	exit 1;
fi

if [ -z "$upgrade" ]; then
	add_err_status "$FWRESTORE_DISALLOWED_MSG" "$BNA_FWRESTORE_DISALLOWED_MSG"
	exit 1;
fi

if [ "$upgrade" == /dev/$mount_s ]; then
	add_err_status "$FWRESTORE_DISALLOWED_MSG" "$BNA_FWRESTORE_DISALLOWED_MSG"
    	exit 1;
fi


#
# prevent firmwarerestore from 6.3 to 6.1.2_cee because
# the we can not restore the PROM image in this case
#
case ${SWBD##SWBD} in
	'76')
		if [ ! -s /mnt/boot/bootrom.bin ]; then
			add_err_status "$FWRESTORE_VER_DISALLOWED_MSG" "$BNA_FWRESTORE_VER_DISALLOWED_MSG"
			exit 1;
		fi
	esac

# The following steps restores the old RBAC dynamic db
if [ $CUR_MAJOR -eq 7 -a $TO_MAJOR -eq 7 ]; then
	/usr/sbin/chroot /mnt /fabos/libexec/userdb_convert $CUR_MAJOR.$CUR_MINOR $TO_MAJOR.$TO_MINOR > /dev/null 2>&1
	cp /mnt/etc/fabos/rbac/dynamic /etc/fabos/rbac/dynamic
fi

#Push Manufacturing key to SP
if [ -f '/fabos/libexec/spmPublicKeyUpdate' ] ; then
	/fabos/libexec/spmPublicKeyUpdate
fi

# Resotoring only the 8548 and 440epx prom images
echo "Restoring the PROM image ..."
if [ -s /mnt/boot/bootrom.bin ]; then
    /usr/sbin/chroot /mnt /sbin/prominst
fi

bootenv OSRootPartition "$dev_s;$dev_p"

if [ -n "$osloader" ] ; then
	bootenv OSLoader "$kern_s;$kern_p"
fi
bootenv Upgrade "/dev/$dev_s"
bootenv SoftUpgrade "commit"

# Pre-installation has completed successfully. Need to print the
# Marathon-striker warning message before firmwarerestore reboots
# the switch
if [ $DISPLAY_MARATHON_STRIKER_WARN_MSG -eq 1 ]; then
	echo -e "\n$MARATHON_STRIKER_WARN_MSG\n"
	echo -e "$BNA_MARATHON_STRIKER_WARN_MSG" >> $BNA_STATUS_FILE
fi

if [ $CUR_MAJOR -eq 6 -a $CUR_MINOR -le 2 ]; then
echo "The system is rebooting now!! After reboot, firmwarecommit" \
    "will be started and the partitions will be restored to the" \
    "original firmware."
/fabos/cliexec/reboot -s -r FirmwareDownload -f
fi

exit 0
